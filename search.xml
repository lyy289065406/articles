<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>找 BUG 记</title>
      <link href="/articles/zhao-bug-ji.html"/>
      <url>/articles/zhao-bug-ji.html</url>
      
        <content type="html"><![CDATA[<h2 id="令人头痛的陈年老BUG（序章）"><a href="#令人头痛的陈年老BUG（序章）" class="headerlink" title="令人头痛的陈年老BUG（序章）"></a>令人头痛的陈年老BUG（序章）</h2><p>前几天，码农朋友甲（下文简称“甲”）拿着我5年前发表在某博文的代码问我：“这段代码是有bug吧？”下面就是他给我指出来的一段C++代码，大家可以先尝试能不能找到甲看到的bug：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Initial</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    TimeStamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 时间戳</span>    DFN <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 搜索次序</span>    Low <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 能够回溯的最早次序号</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>DFN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Low<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SCC_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    SCC <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 辅助栈</span>    Status <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 辅助栈状态</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sp <span class="token operator">=</span> new Shrink_point<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缩点（极大强连通分量）</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>诚然，突然要我查一段几年前写下的代码是否有bug，我内心是比较抗拒的——尤其是我自己写的代码（我对自己还是有相当自信的）——毕竟人的弱点就是不善于揭发自己的短处。不过这都只是次要的心理因素。</p><p>归根结底，所谓打铁趁热，bug也是越早发现越好，**<em>新代码的bug总是要比历史代码的bug更容易处理**</em>。而面对这个陈年老bug，我已经完全忘记了我在5年前写这段代码的思绪，所以要我马上就应付甲的质疑是不可能的。与其再花费一番周折琢磨我自己的代码，我干脆直接就举手投问：“所有测试用例运行可以通过，是哪里有bug呢？”</p><h2 id="因注释而蔓延"><a href="#因注释而蔓延" class="headerlink" title="因注释而蔓延"></a>因注释而蔓延</h2><p>甲告诉我，是memset函数使用错误：在C++中，函数memset的作用是对一段连续的内存块赋值，即赋值的单位是字节，换而言之memset只能用于字节数组，但int数组不是字节数组。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老实说，我很高兴甲会如此仔细的看我5年前的代码。而且毫无疑问，他的观点是正确的。但是也不见得我就是错的。因为早在那时我就已经知道memset函数的局限所在，但我坚持要用这个函数做数组的初始化，是因为我看中了它的效率——</p><p>相对于逐个赋值的方法初始化数组元素、memset的效率要高得多，因为从寻址次数来看，前者的时间复杂度是O(n)、后者是O(1)，更何况当时所解决问题的n是上千万级别的。虽然我把memset用在非字节数组，只要我保证初始化的值只为0就不会有任何问题。事实上也是如此。</p><p>于是我自信满满地告诉甲，单纯断章取义地看我这个方法，确实是一个bug。但如果整体地去看我的代码就恰恰相反，**<em>我只是利用了bug，并得到了更高效的处理**</em>。</p><p>但是甲之后的一席话确实值得我深思：</p><p>“或许对目前的这份代码而言，这个bug是被你巧妙地利用了，但是我觉得**<em>真正的bug或许不是你的代码，而是你没有文字注释去说明你的想法**</em>。不要忘记你已经共享了你的代码，当更多人看到这段程序时，如果他们不了解menset的原理就照样搬用，那么你就无异于在别人的代码中散播了bug，因为你不能把他们代码中的val限制为0。”</p><h2 id="最危险的组合"><a href="#最危险的组合" class="headerlink" title="最危险的组合"></a>最危险的组合</h2><p>不得不承认，甲是对的。即使我有足够的自信在5年后仍然记得利用这个bug的前因后果，但在这5年间早已误了不少别人的子弟……</p><p>不过话说回来，先不论这个bug的蔓延性，甲能够如此深入琢磨我的历史遗留物、并发现这个bug实属难得——在软件中有一种bug是最难被发现的：组合式的bug。组合式的bug有两种类型：相辅相成型、相互弥补型——甲在我代码中发现的bug就属于后者。</p><p>相辅相成型：举例而言，一个bug是楼梯很滑，另一个bug扶手坏了，但除非这两个bug同时存在，否则只有其中一个bug是不足以让人摔下楼梯的。</p><p>相互弥补型：它与相辅相成型刚好相反，只有两个bug同时存在（或不存在）程序才会正常运行。若只修正了其中一个bug，另一个bug就会曝露出来，而且会让人有误以为自己改错了的假象，因为修改之前程序是可以正常运行的。</p><p>之所以说它难以发现，因为组合bug几乎无迹可寻，尤其是相互弥补型。除非是编译原理的狂热爱好者、抑或出现了非常极端的运行环境。**<em>存在组合bug的程序，其通常状态无异于正常程序，而且可能正常运行了很长时间都没有曝露出来**</em>。</p><p>回到我的代码，它已经正常运行5年了。如果甲没有向我质问他心中的疑惑，而是擅自修改了他所发现的bug，那么我的程序就无法正常运行了——而甲就很可能会因此陷入怀疑自己的正确性的境地。</p><h2 id="令人头痛的陈年老BUG（终章）"><a href="#令人头痛的陈年老BUG（终章）" class="headerlink" title="令人头痛的陈年老BUG（终章）"></a>令人头痛的陈年老BUG（终章）</h2><p>事实上，不是所有bug都需要解决掉的。很多时候我们明明知道正在为代码引入一个bug，但是我们却依然保留它。因为回避它的代价太大了，我们宁愿限制它的前提条件不让它轻易发生、或者将其“圈养”起来（如try-catch）不让它暴走——**<em>如何容忍bug也是一门学问**</em>。</p><p>不过也总有一些技术葩喜欢另辟蹊径，誓言要代表月亮消灭所有bug维护代码界安全——先不说甲就是这种人，反正我是不会去消灭一个几年前就已经知道的bug的。如果要消灭它，我当时就做了，何必等到现在。</p><p>这前面提到的“新bug更易于旧bug被解决”是一个原因，但我真正担忧的是我或许会引入更多不可控的bug——代码的历史太久远了，我已经近乎忘记了它的逻辑，我一旦盲目修改，完全有可能采用了更危险的方法去解决那个稳定了5年的bug。</p><p>很多时候，我们写完一段代码，只要程序能够编译运行、完成需求功能就算完成了，鲜有考究bug的可能性，大部分的bug都是通过日后使用时再去发现和解决的。其实解决bug的黄金时间在于代码刚被编写的时候，这时候我们往往只需看到异常提示，就可以马上定位异常原因，因为潜意识中我们已经隐约觉得哪个位置会报什么异常了。</p><p>所以当我们在面对一些陈年老bug的时候，其实早就已经错过了解决它的最好时机。这时候不妨将其圈养起来，可能相比于消灭它，会令代码更安全。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>半杯水</title>
      <link href="/articles/ban-bei-shui.html"/>
      <url>/articles/ban-bei-shui.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>读 《<a href="https://book.douban.com/subject/6709809/">暗时间</a>》 有感</p></blockquote><h2 id="这应该算是引子"><a href="#这应该算是引子" class="headerlink" title="这应该算是引子"></a>这应该算是引子</h2><p>半杯水 —— 思如杯，技如水，技盈则满，思盈则空。虚而不满，似无物，可容万物。</p><p>有一个辩题为「能力和思维哪个更重要」。我不选边站，「学而不思则惘，思而不学则怠」，物极必反是亘古之理。只是现在社会的竞争过大，很多人为了眼下的生活，都过份追求自身能力的发展，而忽略了不时反思自身的那份态度。</p><p>我之前问过一个海纳百川的朋友：「你什么新技能都去试，也不想想学得多而不精有什么用？」 于是他告诉我，这样才能在短时间内让上司知道自己有什么变化，而且新东西可以显得自己与众不同。</p><p>我想说，其实如果你可以坚持每天不穿衣服去上班，也是可以起到同样效果的…… 同理，我也不认为一味思考人生就会变得很好，当然如果你想成为下一个「深井冰」，那就另当别论了。</p><p>其实辩题不应该是哪个更重要，因为都重要。关键是如何在两者之间寻求平衡，保持半杯水的「状态」 —— 但我更倾向于认为这是种互补的「心态」：不过分依赖能力、也不过分依赖思考，不过分依赖自己、也不过分依赖他人，为身边的一切寻求互补，不卑不亢，聪明地做事。</p><h2 id="分节目录"><a href="#分节目录" class="headerlink" title="分节目录"></a>分节目录</h2><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">●  苦逼程序猿，劳模运维狮</td><td align="left">—— 工作怪圈</td></tr><tr><td align="left">●  你需要K.I.S.S</td><td align="left">—— 跳出怪圈（程序猿篇）</td></tr><tr><td align="left">●  掌控你的资源</td><td align="left">—— 跳出怪圈（运维狮篇）</td></tr><tr><td align="left">●  能力与方法</td><td align="left">—— 正确地使用你的能力</td></tr><tr><td align="left">●  囚徒困境</td><td align="left">—— 别宅了，抱团吧</td></tr><tr><td align="left">●  人的核心竞争力</td><td align="left">—— 技能不是万能</td></tr><tr><td align="left">●  书写是为了更好地思考</td><td align="left">—— 你的思维需要降速</td></tr></tbody></table><h2 id="苦逼程序猿，劳模运维狮"><a href="#苦逼程序猿，劳模运维狮" class="headerlink" title="苦逼程序猿，劳模运维狮"></a>苦逼程序猿，劳模运维狮</h2><p>对程序猿而言，「重构」永远是最大的课题。</p><p>程序猿最困扰的，莫过于总要面对一堆乱七八糟的历史代码 —— 历史代码其本身可能并不混乱，只是经手的人多了，面目全非罢了。从心理上看，一份代码越混乱，对于维护结果抱着「无所谓」的心态越明显。但不负责任的恶性维护，尽头只能是重构，而即使重构了，却也只是新循环的开始。</p><p>而对于运维狮，「自动」应是他们最终所追求的幻想。</p><p>运维狮的工作核心基本无一例外的就是要面对大量的机器、大量的程序副本、不知何时会崩坏的线程，还要时常排查天文数字一样的监控数据，到头来却不知道自己究竟在维护什么。</p><p>即使渴望可以自动化完成这一切，但「羊群效应」却使得大多数运维狮无意识地从众，因为有安全感的，尤其所面对的东西是未知的时候 —— 既然已经有那么多非自动化部署的程序 …… 于是又手动拷贝了一份程序副本。</p><p>我们总是在嘲笑历史上的别人留下一堆麻烦，历史却总是惊人的相似 —— 因为我们在抱怨别人的烂摊子的同时，一边给别人制造烂摊子却不自知。若始终不肯抛弃「自我感觉良好」的心态，所有人都只能苦逼地活在别人制造的圈子里，然后成为别人嘲笑的劳模。这个循环是时候结束了。</p><h2 id="你需要K-I-S-S"><a href="#你需要K-I-S-S" class="headerlink" title="你需要K.I.S.S"></a>你需要K.I.S.S</h2><p>首先要声明的是，不要理会别人的维护质量有多烂，从自身做起，保持良好的心态，负责任地维护每一份代码才是一个程序猿应有的职业素质。</p><p>但是总有一些代码经过历史不断的修补而变得过于复杂，复杂到我们宁愿放弃80%的功能（这并不是确切的划分，只是我深受二八定律影响罢了）去重构一份简洁的代码 —— 当然如果还有保有我们所需要的那些功能就更好了。</p><p>良好的开端比什么都重要。程序猿觉得代码维护困难，根本原因在于程序设计阶段没有做好。所以无论如何，只要你一下定决心要重构，请务必由始至终把K.I.S.S原则铭记在心。K.I.S.S，即「Keep it simple,stupid!」，直译过来就是「保持简单，傻瓜」。确实，把程序复杂化无助于性能和资源的管控，也使得后续的使用和维护更加困难。</p><p>有一条程序猿悖论如是说：「程序猿的工作效率并不会随着资历的增加而有显著提高」。究其原因，年轻的程序猿会耗费大量的工作时间去敲写几万行代码以体现能力；而老程序猿更倾向于在深入思考后再写出几百行代码以体现质量，即使偶尔花了大量时间在写代码上，一般也只是为了这几百行代码找到最优的组合而已。</p><p>这是因为所有老程序猿都明白，华而不实的工作能力，只会使我们的工作变得更加困难。只有简单才是美，为了简单我们不惜付出任何代价。</p><h2 id="掌控你的资源"><a href="#掌控你的资源" class="headerlink" title="掌控你的资源"></a>掌控你的资源</h2><p>相对于程序猿，运维狮没有推翻一切重来的「重构」手段，因此需要的更多是务实的精神，但务实不等同于蛮干，技巧也很重要。一个合格的运维狮应该思考的不是「能做多少」，而是「如何做得最少」。</p><p>如果你觉得维护工作开始变得困难，或者已经很困难，就需要审视自己是否有正确利用身边的资源以提高自身的工作效率和质量。不要奢望「自家的」程序猿什么时候能提供自动化的程序使你的工作变得轻松，关注第三方的运维工具并利用起来才是王道，毕竟现在的社会，什么东西都是「别人家的」更好啊。</p><p>有一条成功的箴言如是说：「要看一个人是否成功，看他晚上8点之后在干什么」。其实也是很浅显的道理，白天谋生、晚上谋事。作为运维狮，虽然少有晚上时间，但闲下来的时候必须学会充实自己。如果你还在迷茫应该学习什么，或者我能够为你指两个方向：</p><ul><li>掌握shell/sed/awk三剑客编程：学会编写定制化的脚本</li><li>掌握自动化部署工具ansible：用程序生成程序、而不是手工复制</li></ul><p>特别一提的是，不少运维狮容易受工作内容所限，生疏于编程语言、甚至不懂编程语言。其实不妨走出自己的圈子，学习一些编程语言，打通前后端，更有利于自身的工作。在维护出现问题的程序的时候，「知道用什么方法解决」和「知道为什么可以这样解决」是两种截然不同的境界。</p><p>这里说一个题外话，我在协助现场维护工作的时候，发现运维狮和用户之间总有争取硬件资源的矛盾。所谓「宁花机器一分，不费程序员一秒」，程序量提高了，用户却迟迟不肯放宽硬件资源，很多时候可能是没有看到有力的「证据」。如果能够做到常态化监控，并把性能数据持续集成健康的报表，对用户透明化，或许争取资源会更容易，这也是一种做事手段。</p><h2 id="能力与方法"><a href="#能力与方法" class="headerlink" title="能力与方法"></a>能力与方法</h2><blockquote><p>「如果你手里有一把锤子，所有东西看上去都像钉子」。  —— 这不是我说的。</p></blockquote><p>往往我们可能花费了大量时间去学习一项技能，而学无所用是所有人最不愿意发生的事情。于是我们就会尝试在各个方面炫耀这项新技能，而不管它是否适用。</p><p>在我学习设计模式之初，就陷入了这种状态，几乎不能自拔。确实，设计模式为我打开了一扇大门，我首次知道原来代码也可以写得如此优美，使得我迫不及待地寻找可以应用它们的项目，哪怕只有一点可以用得上。但牵强附会总是没有好结果的。</p><p>再如我现在所参与的技术框架开发，虽然一些工具组件已经被成功推广起来了，但一些工具组件却依然不为人所知。不是说这些组件没有技术性，究其原因也是适用性问题。所谓的工具是为了提高开发效率才被制造出来的，而很多同事就投诉说，为了使用一个工具必须注意这注意那，还要配置一堆有的没的东西，甚至还可能与业务逻辑不兼容，如此复杂还不如自己实现。于是他们真的选择了抛弃这些工具。</p><p>所以其实正确的做事态度应该是：「如果你想钉一个钉子，所有东西看上去都像是锤子」。</p><p>即我们在处理问题时，优先考虑的是要做什么What，而不是怎么做How。只有先明确目的，才去选择合适的工具，而不是拿着一把工具对所有事情都勉而为之。正确而有效率地做事，谨记以下几点，受用无穷：</p><ul><li>方向比努力更重要：莫要南辕北辙</li><li>流程比修补更重要：无规矩不成方圆</li><li>方法比拼命更重要：事半功倍</li></ul><h2 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h2><p>在信息时代，「大鱼吃小鱼」已成为过去，如今是「快鱼吃慢鱼」。但如何能够「快」？在软件开发中，如果单凭一个人在闭关修炼技术，无论学习能力多么像海绵，也不可能短时间内海纳百川，又如何能快得起来？其实这也恰好说明你开始需要一个团队了 —— 为了综合实力，取长补短。</p><p>软件开发的本质就是一项团队运动，人与人的因素对结果的影响完全不亚于技术因素。一个项目成功的关键不仅仅是写出漂亮的代码，团队中的所有人朝着同一个目标一起合作也是同样重要的。但团队工作经常遇到的问题，就是沟通问题，我遇到的主要有两种情况：不愿意沟通，或无法正确表达自己想法。</p><p>举一个博弈中的著名栗子，「囚徒困境」。大概是描述这样的一个问题：两个疑犯被隔离审讯，由于证据不足，若两个都抵赖则均判1年，两个都坦白则均判8年，一个坦白一个抵赖则坦白的释放、抵赖判10年。</p><p>从整体利益上考量，最优的方案是两者均抵赖。但由于两个疑犯不知对方所想，在对方可能会抵赖的怀疑下，局限于自身利益进行判断，都会选择坦白，以保证自身利益最大化。</p><p>囚徒困境也是在团队工作中，缺乏沟通或沟通不当的必然结果。所谓的团队任务，就是要每个人承担一块工作，分别完成后再整合。如果都只从自身角度做考量而不顾他人，即使自己工作得非常出色，但最终却无法与他人的工作完成整合，那么也只是在做无用功。</p><p>只有通过不断的沟通、磨合，才可能保证整体的利益最大化，一盘散沙，终难成事。所谓「要学做事，先学做人」，时刻谨记我们都只是半杯水：内修本领、追求极致，固然重要；外联朋志、寻求互补，方是王道 —— 抱团取暖 = 力量大。</p><h2 id="人的核心竞争力"><a href="#人的核心竞争力" class="headerlink" title="人的核心竞争力"></a>人的核心竞争力</h2><p>前面讲述的都是一些现实性的东西，那些确实都是我们用来竞争的实质性资本。但毕竟随着工作的更替，很多东西也就过时了。而不过时的只有思考的方式，或者说只有思考才真正是我们作为人的不可替代的核心竞争力。</p><p>下面这些是我平时或蒐集、或所悟的「箴言」，既然是分享，我就不要脸地「借鉴」过来了。有时这些看似与技能毫无关系的东西，可能恰好就在某个转折点决定了人生，所以都参考着看一下吧：</p><ul><li>万事先修德，养性必制怒。</li><li>广交朋友并为他们做事情。</li><li>多参与社区活动，积极分享，锻炼口才。</li><li>锻炼身体，笑到最后得有一副好身体。</li><li>反思是让人得以改进自己的最重要的思维品质。</li><li>「教」是最好的「学」。</li><li>我们都是半杯水，正是这样人生才有意义，不卑不亢，寻找互补。</li><li>人生就是一场修行，人必自助而天助之。</li><li>读书，尤其是读那些非实用性的书（如心理学等）。</li><li>潜心一到两项业余爱好，参与一些艺术活动。</li><li>不断寻找偷懒的方法，聪明地工作。</li><li>越努力，越幸运。</li><li>与智者交谈，思考，并常做笔记。</li><li>犯错趁早，防微杜渐。</li><li>因上努力，果上求缘。</li></ul><h2 id="书写是为了更好地思考"><a href="#书写是为了更好地思考" class="headerlink" title="书写是为了更好地思考"></a>书写是为了更好地思考</h2><p>最后，这是一个我自身的一个小故事。  —— 一个我成为「作家（虚伪的）」之前的故事。</p><p>以前我们读书的时候，每天的工作就是写。而现在工作了，扪心自问，又还有谁拿起过笔？恐怕都差不多执笔忘字了吧。</p><p>那为什么我们需要书写？</p><p>众所周知，物理上速度的极限是光速。但撇开物理不谈，比光速更快的，则是人的思维 —— 因为光从地球到火星都需要400秒，而人想一下就到了。</p><p>这不是脑筋急转弯，大部分人应该有过这样的经历：在思考一个问题很久却不得果时，都会试着问一下别人的想法。但当我们把问题描述一次给对方的时候，对方还没做出回答，我们就突然「想通」了。</p><p>这是因为，我们在思考问题的时候，往往已经想明白了各个细节要如何解决，但由于思维速度过快、跳跃性太大，在想细节A的时候、忘记了细节B，想B的时候又忘记了A，从而引起「想不透」或「总觉得哪里不对」的假象。</p><p>而通过文字将问题重新描述一次，实际上就是一个将思考「降速」并「梳理」的过程。因此如果一直想不透一个问题，不妨用笔将其写下来，往往问题就迎刃而解了。有时可能还会因此有意外的收获。</p><p>以上。</p><p>所以….</p><p>所以我好像丝毫没有提到那个故事，这是因为我知道你们不会想看的。</p><p>但其实你已经猜到那个故事了 —— </p><p>所以大家都积极地写一点东西去记录自己的点点滴滴吧！</p><p>或许一开始你可能会纠结怎样可以写出令人眼前一亮的东西，但当你意识到这可以让你更好地思考的时候，你就会摒弃这种纠结。当你慢慢习惯怎样用文字去描述你的想法时，所谓「思如泉涌」也不过如是罢了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>别让你的能力成为绊脚石</title>
      <link href="/articles/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi.html"/>
      <url>/articles/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi.html</url>
      
        <content type="html"><![CDATA[<p>在溺水时拼命抓住的，真的是救命稻草吗？</p><p>能力越强的人，往往对自己的能力越是依赖。但相对地，处理危机的灵活性可能就越弱——尤其在环境发生巨大变化时，这种能力或许就是妨碍自身拓展最大的绊脚石。</p><p>人都是善于习惯的动物：长期沉溺在单一的环境中，虽培养了能力、但同时也习惯了一成不变的感觉。尤其是在自身日益卓越的时候，更易于陶醉于自己的能力，稍有不慎便会让自负的优越感侵蚀全身，甚至于逐渐对其他技能产生淡漠感、对环境变化产生迟钝感。</p><p>俗话说“居安思危”。自身能力越是接近临界点的时候，也就是最容易让人安于现状的时候——擅长的能力难以提升、其他能力又无心拓展，一旦连最基本的危机感都失去，离被淘汰也就不远了。在此节骨眼上，往往是我们选择的分岔口：是追求精益求精、抑或探求一专多长？我不能帮任何人做出选择，但我个人认为，仅满足于一种能力对自身未必有益：在职业生涯中需要的能力是多元化的，因为这有利于我们可以在环境变化时快速反应、调整自身。我们更需要的是能及时抓住机遇，永远不要被一叶障目、成为井底之蛙。</p><p>或许终将有一日，海上刮起大浪，我们都翻船了、溺水了。这不是危言耸听。于是乎，我们为了自救，出于本能地拼命去抓住身边能够抓住的一切——而我们的能力就是我们的一切——但若是我们只有一种能力，那么能抓住的就只有这根稻草。这毫无办法，即使我们深知这根稻草恐怕无法让我们活命。</p><p>当然，并不是能力越多，活命的机会就越大，这两者并无绝对的相关性。我只是说，能力越多，我们能够选择自救的机会就越多——或者会出现浮板、甚至是木船——至少不会是那根弱不禁风的稻草。</p><p>我很清楚，我也只是个溺水的人。</p><p>但我们都将会是溺水的人。不过，我们都不应该只有一根稻草。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
